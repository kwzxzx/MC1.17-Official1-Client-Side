#version 150 core
#define MC_GL_NV_vertex_buffer_unified_memory

#define MC_GL_EXT_texture_filter_anisotropic

#define MC_GL_KHR_shader_subgroup

#define MC_GL_NV_gpu_program_fp64

#define MC_GL_ARB_timer_query

#define MC_GL_NV_register_combiners

#define MC_GL_NV_half_float

#define MC_GL_ARB_framebuffer_sRGB

#define MC_GL_ARB_texture_gather

#define MC_GL_NV_geometry_shader4

#define MC_GL_EXT_texture_edge_clamp

#define MC_GL_NV_multisample_filter_hint

#define MC_GL_VENDOR_NVIDIA

#define MC_GL_ARB_texture_rgb10_a2ui

#define MC_GL_ARB_transpose_matrix

#define MC_GL_ARB_texture_stencil8

#define MC_GL_NV_framebuffer_multisample_coverage

#define MC_GL_NV_conditional_render

#define MC_GL_NV_copy_image

#define MC_GL_ARB_vertex_buffer_object

#define MC_GL_EXT_direct_state_access

#define MC_GL_EXT_texture_object

#define MC_GL_ARB_window_pos

#define MC_GL_NV_gpu_shader5

#define MC_GL_KHR_parallel_shader_compile

#define MC_GL_ARB_point_parameters

#define MC_GL_ARB_draw_buffers_blend

#define MC_GL_EXT_semaphore

#define MC_GL_EXT_vertex_array_bgra

#define MC_GL_EXT_blend_func_separate

#define MC_GL_EXT_texture_compression_dxt1

#define MC_GL_EXT_compiled_vertex_array

#define MC_GL_EXT_blend_minmax

#define MC_GL_EXT_pixel_buffer_object

#define MC_GL_NV_shader_atomic_float64

#define MC_GL_NV_clip_space_w_scaling

#define MC_GL_NV_conservative_raster_pre_snap_triangles

#define MC_GL_ARB_shader_image_size

#define MC_GL_NV_texgen_reflection

#define MC_GL_ARB_sparse_texture2

#define MC_GL_ARB_bindless_texture

#define MC_GL_ARB_texture_buffer_object_rgb32

#define MC_GL_ARB_get_program_binary

#define MC_GL_NV_shader_subgroup_partitioned

#define MC_GL_EXTX_framebuffer_mixed_formats

#define MC_GL_EXT_shader_image_load_formatted

#define MC_GL_ARB_texture_rectangle

#define MC_GL_ARB_shading_language_100

#define MC_GL_ARB_debug_output

#define MC_GL_NV_shader_atomic_fp16_vector

#define MC_GL_NV_packed_depth_stencil

#define MC_GL_NV_conservative_raster

#define MC_GL_ARB_vertex_program

#define MC_GL_ARB_fragment_coord_conventions

#define MC_GL_ARB_compute_variable_group_size

#define MC_GL_EXT_framebuffer_blit

#define MC_GL_EXT_fog_coord

#define MC_GL_ARB_shading_language_packing

#define MC_GL_ARB_texture_filter_anisotropic

#define MC_GL_NVX_blend_equation_advanced_multi_draw_buffers

#define MC_GL_EXT_packed_float

#define MC_GL_NV_fragment_program_option

#define MC_GL_VERSION 320

#define MC_GL_ARB_texture_barrier

#define MC_VERSION 11700

#define MC_GL_ARB_buffer_storage

#define MC_GL_NVX_linked_gpu_multicast

#define MC_GL_NV_blend_square

#define MC_GL_EXT_shadow_funcs

#define MC_GL_NV_copy_depth_to_color

#define MC_GL_EXT_multiview_texture_multisample

#define MC_GL_ARB_shader_precision

#define MC_GL_ARB_shader_atomic_counter_ops

#define MC_GL_EXT_texture_env_combine

#define MC_GL_EXT_point_parameters

#define MC_OS_WINDOWS

#define MC_GL_EXT_semaphore_win32

#define MC_GL_ARB_texture_border_clamp

#define MC_GL_ARB_sparse_buffer

#define MC_GL_ARB_vertex_attrib_64bit

#define MC_GL_NV_fill_rectangle

#define MC_GL_ARB_cull_distance

#define MC_GL_NV_fragment_shader_interlock

#define MC_GL_ARB_texture_env_add

#define MC_GL_EXT_depth_bounds_test

#define MC_GL_ARB_fragment_layer_viewport

#define MC_GL_ARB_conditional_render_inverted

#define MC_GL_EXT_provoking_vertex

#define MC_GL_NV_vertex_attrib_integer_64bit

#define MC_GL_NV_shader_atomic_float

#define MC_GL_ARB_texture_query_lod

#define MC_GL_NV_stereo_view_rendering

#define MC_GL_ARB_map_buffer_alignment

#define MC_GL_NV_path_rendering

#define MC_GL_ARB_gl_spirv

#define MC_GL_NV_ES1_1_compatibility

#define MC_GL_NV_geometry_shader_passthrough

#define MC_GL_ARB_pipeline_statistics_query

#define MC_GL_EXT_bindable_uniform

#define MC_GL_ARB_shader_image_load_store

#define MC_GL_ARB_separate_shader_objects

#define MC_GL_NV_fog_distance

#define MC_GL_NV_shader_buffer_load

#define MC_GL_NV_vertex_program2

#define MC_GL_NV_texture_barrier

#define MC_GL_ARB_vertex_type_2_10_10_10_rev

#define MC_GL_NV_vertex_program3

#define MC_GL_EXT_texture_sRGB_R8

#define MC_GL_ARB_transform_feedback2

#define MC_GL_EXT_texture3D

#define MC_GL_ARB_transform_feedback3

#define MC_GL_ARB_shader_storage_buffer_object

#define MC_GL_ARB_arrays_of_arrays

#define MC_GL_NV_register_combiners2

#define MC_GL_EXT_texture_shadow_lod

#define MC_GL_EXT_packed_depth_stencil

#define MC_GL_ARB_texture_compression_rgtc

#define MC_GL_EXT_geometry_shader4

#define MC_GLSL_VERSION 150

#define MC_GL_NV_texture_rectangle_compressed

#define MC_GL_EXT_separate_specular_color

#define MC_GL_ARB_shader_bit_encoding

#define MC_GL_EXT_draw_instanced

#define MC_GL_EXT_blend_equation_separate

#define MC_GL_ARB_occlusion_query2

#define MC_GL_ARB_half_float_vertex

#define MC_GL_NV_blend_equation_advanced_coherent

#define MC_GL_NV_texture_rectangle

#define MC_GL_EXT_texture_storage

#define MC_GL_ARB_texture_rg

#define MC_GL_EXT_polygon_offset_clamp

#define MC_GL_NV_shader_atomic_counters

#define MC_GL_NV_alpha_to_coverage_dither_control

#define MC_GL_AMD_vertex_shader_layer

#define MC_GL_ARB_shader_texture_lod

#define MC_GL_NV_draw_texture

#define MC_GL_ARB_copy_image

#define MC_GL_ARB_framebuffer_object

#define MC_GL_EXT_raster_multisample

#define MC_GL_EXT_transform_feedback2

#define MC_GL_ARB_color_buffer_float

#define MC_GL_EXT_draw_range_elements

#define MC_GL_NV_compute_program5

#define MC_GL_ARB_texture_mirror_clamp_to_edge

#define MC_GL_ARB_robust_buffer_access_behavior

#define MC_GL_ARB_explicit_uniform_location

#define MC_GL_ARB_ES3_compatibility

#define MC_GL_ARB_half_float_pixel

#define MC_GL_ATI_draw_buffers

#define MC_GL_ARB_shader_ballot

#define MC_GL_NV_fence

#define MC_GL_EXT_separate_shader_objects

#define MC_GL_NV_primitive_restart

#define MC_GL_NV_feature_query

#define MC_GL_NV_transform_feedback2

#define MC_GL_EXT_texture_env_dot3

#define MC_GL_ARB_draw_buffers

#define MC_GL_EXT_import_sync_object

#define MC_GL_NV_texture_shader2

#define MC_GL_ARB_sparse_texture_clamp

#define MC_GL_ARB_compressed_texture_pixel_storage

#define MC_GL_NV_gpu_multicast

#define MC_GL_NV_blend_minmax_factor

#define MC_GL_ARB_texture_env_dot3

#define MC_GL_NV_texture_shader3

#define MC_GL_NV_path_rendering_shared_edge

#define MC_GL_KHR_no_error

#define MC_GL_NV_multisample_coverage

#define MC_GL_EXT_blend_subtract

#define MC_GL_EXT_sparse_texture2

#define MC_GL_NV_ES3_1_compatibility

#define MC_GL_EXT_secondary_color

#define MC_GL_EXT_memory_object

#define MC_GL_EXT_framebuffer_object

#define MC_GL_NV_texture_multisample

#define MC_GL_ARB_spirv_extensions

#define MC_GL_NV_sample_locations

#define MC_GL_ARB_viewport_array

#define MC_GL_ARB_transform_feedback_overflow_query

#define MC_GL_NV_occlusion_query

#define MC_GL_EXT_framebuffer_multisample

#define MC_GL_ARB_seamless_cubemap_per_texture

#define MC_GL_EXT_texture_compression_latc

#define MC_GL_NV_texture_compression_vtc

#define MC_GL_EXT_multiview_timer_query

#define MC_GL_S3_s3tc

#define MC_GL_ARB_vertex_shader

#define MC_GL_KHR_blend_equation_advanced

#define MC_GL_ARB_depth_texture

#define MC_GL_ARB_framebuffer_no_attachments

#define MC_GL_WIN_swap_hint

#define MC_GL_EXT_window_rectangles

#define MC_GL_ARB_shader_viewport_layer_array

#define MC_GL_EXT_texture_mirror_clamp

#define MC_GL_NV_parameter_buffer_object2

#define MC_GL_NV_vertex_program

#define MC_GL_ARB_sparse_texture

#define MC_GL_ARB_indirect_parameters

#define MC_GL_EXT_framebuffer_multisample_blit_scaled

#define MC_GL_ARB_invalidate_subdata

#define MC_GL_ARB_texture_swizzle

#define MC_GL_NV_viewport_swizzle

#define MC_GL_EXT_packed_pixels

#define MC_GL_AMD_multi_draw_indirect

#define MC_GL_ARB_polygon_offset_clamp

#define MC_GL_NV_conservative_raster_dilate

#define MC_GL_ARB_seamless_cube_map

#define MC_GL_ARB_geometry_shader4

#define MC_GL_EXT_texture_env_add

#define MC_GL_ARB_stencil_texturing

#define MC_GL_NV_shader_storage_buffer_object

#define MC_GL_ARB_compute_shader

#define MC_GL_ARB_shader_objects

#define MC_GL_NV_gpu_program4_1

#define MC_GL_ARB_multi_draw_indirect

#define MC_GL_ARB_parallel_shader_compile

#define MC_GL_EXT_texture_array

#define MC_GL_ARB_get_texture_sub_image

#define MC_GL_SUN_slice_accum

#define MC_GL_NV_vertex_array_range2

#define MC_GL_NV_gpu_program5_mem_extended

#define MC_GL_EXT_Cg_shader

#define MC_GL_NVX_gpu_multicast2

#define MC_GL_ARB_pixel_buffer_object

#define MC_GL_ARB_tessellation_shader

#define MC_GL_ARB_texture_cube_map_array

#define MC_GL_NV_memory_attachment

#define MC_GL_SGIX_shadow

#define MC_GL_EXT_memory_object_win32

#define MC_GL_ARB_vertex_array_bgra

#define MC_GL_NV_fragment_coverage_to_color

#define MC_GL_EXT_vertex_attrib_64bit

#define MC_GL_NVX_conditional_render

#define MC_GL_NVX_progress_fence

#define MC_GL_EXT_texture_lod_bias

#define MC_GL_EXT_rescale_normal

#define MC_GL_NV_uniform_buffer_unified_memory

#define MC_GL_NVX_multigpu_info

#define MC_GL_ARB_clear_buffer_object

#define MC_GL_EXT_win32_keyed_mutex

#define MC_GL_NV_vertex_program1_1

#define MC_GL_NV_query_resource_tag

#define MC_GL_ARB_transform_feedback_instanced

#define MC_GL_ARB_uniform_buffer_object

#define MC_GL_NV_float_buffer

#define MC_GL_KHR_blend_equation_advanced_coherent

#define MC_GL_EXT_texture_cube_map

#define MC_GL_ARB_conservative_depth

#define MC_GL_EXT_texture_shared_exponent

#define MC_GL_KHR_robust_buffer_access_behavior

#define MC_GL_IBM_rasterpos_clip

#define MC_GL_ARB_fragment_shader

#define MC_GL_ARB_ES2_compatibility

#define MC_GL_ARB_direct_state_access

#define MC_GL_ARB_draw_instanced

#define MC_GL_EXT_shader_image_load_store

#define MC_GL_ARB_gpu_shader_fp64

#define MC_GL_ARB_texture_buffer_object

#define MC_GL_NV_sample_mask_override_coverage

#define MC_GL_ARB_instanced_arrays

#define MC_GL_ARB_sync

#define MC_GL_ARB_sample_locations

#define MC_GL_NV_point_sprite

#define MC_GL_ARB_base_instance

#define MC_GL_ARB_texture_compression

#define MC_GL_ARB_gpu_shader5

#define MC_GL_NV_viewport_array2

#define MC_GL_EXT_blend_color

#define MC_GL_EXT_gpu_shader4

#define MC_GL_ARB_texture_query_levels

#define MC_GL_EXT_post_depth_coverage

#define MC_GL_ARB_texture_non_power_of_two

#define MC_GL_EXT_draw_buffers2

#define MC_GL_EXT_multi_draw_arrays

#define MC_GL_EXT_vertex_array

#define MC_GL_ARB_texture_filter_minmax

#define MC_GL_ARB_texture_buffer_range

#define MC_GL_ARB_shadow

#define MC_GL_ARB_clip_control

#define MC_GL_ARB_ES3_2_compatibility

#define MC_GL_ARB_shading_language_include

#define MC_GL_ARB_texture_compression_bptc

#define MC_GL_ARB_multisample

#define MC_GL_ARB_point_sprite

#define MC_GL_ARB_fragment_program

#define MC_GL_ARB_vertex_array_object

#define MC_GL_OVR_multiview2

#define MC_GL_EXT_texture_compression_rgtc

#define MC_WGL_EXT_swap_control

#define MC_GL_ARB_multitexture

#define MC_GL_OVR_multiview

#define MC_GL_ARB_clear_texture

#define MC_GL_NV_shader_thread_group

#define MC_GL_ARB_shader_subroutine

#define MC_GL_ARB_query_buffer_object

#define MC_GL_NV_parameter_buffer_object

#define MC_GL_ARB_ES3_1_compatibility

#define MC_GL_ARB_occlusion_query

#define MC_GL_ARB_draw_indirect

#define MC_GL_ARB_texture_view

#define MC_GL_ARB_internalformat_query

#define MC_GL_NV_draw_vulkan_image

#define MC_GL_NV_query_resource

#define MC_GL_EXT_texture_filter_minmax

#define MC_GL_NV_framebuffer_mixed_samples

#define MC_GL_KHR_robustness

#define MC_GL_EXT_texture_sRGB_decode

#define MC_GL_NVX_gpu_memory_info

#define MC_GL_ARB_shading_language_420pack

#define MC_GL_ATI_texture_mirror_once

#define MC_GL_EXT_texture_lod

#define MC_GL_EXT_framebuffer_sRGB

#define MC_GL_NV_texture_env_combine4

#define MC_GL_ARB_texture_multisample

#define MC_GL_ARB_sample_shading

#define MC_GL_ARB_draw_elements_base_vertex

#define MC_GL_EXT_gpu_program_parameters

#define MC_GL_KHR_context_flush_control

#define MC_GL_AMD_seamless_cubemap_per_texture

#define MC_GL_ARB_depth_buffer_float

#define MC_GL_NV_internalformat_sample_query

#define MC_GL_ARB_texture_storage

#define MC_GL_ARB_provoking_vertex

#define MC_GL_ARB_vertex_attrib_binding

#define MC_GL_ARB_texture_env_crossbar

#define MC_GL_ARB_fragment_program_shadow

#define MC_GL_NV_shader_atomic_int64

#define MC_GL_NV_explicit_multisample

#define MC_GL_NV_light_max_exponent

#define MC_GL_ARB_texture_float

#define MC_GL_ARB_texture_storage_multisample

#define MC_GL_ARB_blend_func_extended

#define MC_GL_KTX_buffer_region

#define MC_GL_ARB_fragment_shader_interlock

#define MC_GL_ARB_derivative_control

#define MC_GL_NV_blend_equation_advanced

#define MC_GL_ARB_depth_clamp

#define MC_GL_ARB_shader_atomic_counters

#define MC_GL_EXT_bgra

#define MC_GL_ARB_texture_cube_map

#define MC_GL_ARB_shader_texture_image_samples

#define MC_GL_NV_vertex_array_range

#define MC_GL_ARB_shader_draw_parameters

#define MC_GL_ARB_imaging

#define MC_GL_ARB_texture_mirrored_repeat

#define MC_GL_NV_fragment_program

#define MC_GL_NV_depth_buffer_float

#define MC_GL_EXT_texture_buffer_object

#define MC_GL_SGIX_depth_texture

#define MC_GL_ARB_vertex_type_10f_11f_11f_rev

#define MC_GL_EXT_texture_integer

#define MC_GL_EXT_texture_compression_s3tc

#define MC_GL_KHR_debug

#define MC_GL_ARB_robustness

#define MC_GL_EXT_shader_integer_mix

#define MC_GL_NV_fragment_program2

#define MC_GL_NV_pixel_data_range

#define MC_GL_EXT_timer_query

#define MC_GL_ARB_shader_group_vote

#define MC_GL_ARB_internalformat_query2

#define MC_GL_IBM_texture_mirrored_repeat

#define MC_GL_NV_bindless_multi_draw_indirect_count

#define MC_GL_NV_vertex_program2_option

#define MC_GL_ARB_sampler_objects

#define MC_GL_EXT_stencil_wrap

#define MC_GL_ARB_map_buffer_range

#define MC_GL_EXT_texture_swizzle

#define MC_GL_ARB_program_interface_query

#define MC_GL_ARB_enhanced_layouts

#define MC_GL_ARB_texture_env_combine

#define MC_GL_ARB_post_depth_coverage

#define MC_GL_ATI_texture_float

#define MC_GL_NV_command_list

#define MC_GL_SGIS_generate_mipmap

#define MC_GL_ARB_copy_buffer

#define MC_GL_NV_shader_thread_shuffle

#define MC_GL_NV_depth_clamp

#define MC_GL_AMD_vertex_shader_viewport_index

#define MC_GL_NVX_nvenc_interop

#define MC_GL_ARB_multi_bind

#define MC_GL_SGIS_texture_lod

#define MC_GL_ARB_shader_clock

#define MC_GL_EXT_abgr

#define MC_GL_NV_bindless_texture

#define MC_GL_NV_transform_feedback

#define MC_GL_EXT_stencil_two_side

#define MC_GL_NV_bindless_multi_draw_indirect

#define MC_GL_NV_texture_shader

#define MC_GL_RENDERER_GEFORCE

#define MC_GL_ARB_explicit_attrib_location

#define MC_GL_ARB_gpu_shader_int64

#define MC_GL_NV_gpu_program4

#define MC_GL_EXT_texture_sRGB

#define MC_GL_NV_gpu_program5

#define varying out
#define attribute in
#define gl_Vertex vec4(Position, 1.0)
#define gl_ModelViewProjectionMatrix (gl_ProjectionMatrix * gl_ModelViewMatrix)
#define gl_ModelViewMatrix (iris_ModelViewMat * _iris_internal_translate(iris_ChunkOffset))
#define gl_NormalMatrix mat3(transpose(inverse(gl_ModelViewMatrix)))
#define gl_Normal Normal
#define gl_Color (Color * iris_ColorModulator)
#define gl_MultiTexCoord7  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord6  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord5  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord4  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord3  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord2  vec4(0.0, 0.0, 0.0, 1.0)
#define gl_MultiTexCoord1 vec4(UV2, 0.0, 1.0)
#define gl_MultiTexCoord0 vec4(UV0, 0.0, 1.0)
#define gl_ProjectionMatrix iris_ProjMat
#define gl_FrontColor iris_FrontColor
#define gl_FogFragCoord iris_FogFragCoord
uniform mat4 iris_LightmapTextureMatrix;
uniform mat4 iris_TextureMat;
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

struct iris_FogParameters {
    vec4 color;
    float density;
    float start;
    float end;
    float scale;
};

iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0 / (iris_FogEnd - iris_FogStart));

#define gl_Fog iris_Fog
out float iris_FogFragCoord;
vec4 iris_FrontColor;
uniform mat4 iris_ProjMat;
in vec2 UV0;
in ivec2 UV2;
uniform vec4 iris_ColorModulator;
in vec4 Color;
in vec3 Normal;
uniform mat4 iris_ModelViewMat;
uniform vec3 iris_ChunkOffset;
mat4 _iris_internal_translate(vec3 offset) {
    // NB: Column-major order
    return mat4(1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                offset.x, offset.y, offset.z, 1.0);
}
in vec3 Position;
vec4 ftransform() { return gl_ModelViewProjectionMatrix * gl_Vertex; }
vec4 texture2D(sampler2D sampler, vec2 coord) { return texture(sampler, coord); }
vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod) { return textureLod(sampler, coord, lod); }
vec4 shadow2D(sampler2DShadow sampler, vec3 coord) { return vec4(texture(sampler, coord)); }
vec4 shadow2DLod(sampler2DShadow sampler, vec3 coord, float lod) { return vec4(textureLod(sampler, coord, lod)); }

#define OVERWORLD
#define WATER
#define VSH

/*
Complementary Shaders by EminGT, based on BSL Shaders by Capt Tatsu
*/

//Common//
/*
Complementary Shaders by EminGT, based on BSL Shaders by Capt Tatsu
*/

//Shader Options//

  #define SECRET 0 //[0]

//#define COMPATIBILITY_MODE
  #define RP_SUPPORT 1 //[1 2 3 4]
  #define GLOWING_ENTITY_FIX
  #define END_PORTAL_REWORK
  #define LIGHTNING_BOLTS_FIX
//#define NIGHT_TWILIGHT_FOREST
  #define LIGHT_LEAK_FIX
//#define SHOW_LIGHT_LEVELS
  #define ENTITY_NORMAL_FIX
  #define THE_FORBIDDEN_OPTION 0 //[0 1 2 3]
  #define WRONG_MIPMAP_FIX
  #define FLICKERING_FIX
  #define SKY_REF_FIX_1 2 //[1 2 3]
  #define OVERLAY_FIX
//#define SMOKEY_WATER_LIGHTSHAFTS
//#define MIN_LIGHT_EVERYWHERE
//#define FOG1_CHECK
//#define METALLIC_WORLD
//#define WAVING_EVERYTHING
//#define SQUARE_BLUR
//#define GBUFFER_CODING
//#define SHOW_RAY_TRACING
//#define RANDOM_BLOCKLIGHT
//#define OVERDRAW
  #define RAIN_REF_BIOME_CHECK
//#define RAIN_REF_FORCED

  #define AURORA_BIOME_CHECK
  #define AURORA_FULL_MOON_CHECK
  #define AURORA_HEIGHT 0.75 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00]

  #define WAVING_SPEED 1.00 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00]
//#define DO_WAVING_UNDERGROUND
//#define DO_WAVING_ON_COMPATIBILITY
  #define WAVING_FOLIAGE
//#define WAVING_LEAVES
  #define WAVING_CROPS
//#define WAVING_VINES
//#define WAVING_LILY_PADS

  #define NEBULA_COMPRESSION 0.00 //[-1.00 -0.95 -0.90 -0.85 -0.80 -0.75 -0.70 -0.65 -0.60 -0.55 -0.50 -0.45 -0.40 -0.35 -0.30 -0.25 -0.20 -0.15 -0.10 -0.05 0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define NEBULA_SMOOTHING 0.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define NEBULA_DISTRIBUTION 2.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0 8.2 8.4 8.6 8.8 9.0 9.2 9.4 9.6 9.8 10.0 10.2 10.4 10.6 10.8 11.0 11.2 11.4 11.6 11.8 12.0 12.2 12.4 12.6 12.8 13.0 13.2 13.4 13.6 13.8 14.0 14.2 14.4 14.6 14.8 15.0 15.2 15.4 15.6 15.8 16.0]
  #define NEBULA_SIZE 0.03 //[0.01 0.015 0.02 0.025 0.03 0.035 0.04 0.045 0.05 0.055 0.06 0.065 0.07 0.075 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25]
  #define NEBULA_PURPLE_BRIGHTNESS 1.00 //[0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00]
  #define NEBULA_ORANGE_BRIGHTNESS 1.00 //[0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00]
  #define NEBULA_STAR_BRIGHTNESS 1.00 //[0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00]

//#define WATERMARK
  #define WATERMARK_DURATION 1 //[1 999]
//#define GRAY_START
//#define BLURRY_START
//#define PARTICLE_VISIBILITY
  #define HAND_BLOOM_REDUCTION
//#define LAVA_VISIBILITY
//#define GLOWING_DEBRIS
//#define GLOWING_REDSTONE_BLOCK
//#define GLOWING_LAPIS_BLOCK
//#define GREEN_SCREEN
  #define ENTITY_EFFECT
  #define HAND_SWAY 0.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0]
//#define SNOW_MODE
  #define NIGHT_VISION 1 //[1 2]
  #define DYNAMIC_SHADER_LIGHT
  #define DYNAMIC_LIGHT_DISTANCE 14.0 //[4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0 9.5 10.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0 19.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0 34.0 36.0 38.0 40.0 44.0 48.0 52.0 56.0 60.0 64.0]
  #define GLINT_BRIGHTNESS 1.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0 8.2 8.4 8.6 8.8 9.0 9.2 9.4 9.6 9.8 10.0 10.2 10.4 10.6 10.8 11.0 11.2 11.4 11.6 11.8 12.0 12.2 12.4 12.6 12.8 13.0 13.2 13.4 13.6 13.8 14.0 14.2 14.4 14.6 14.8 15.0 15.2 15.4 15.6 15.8 16.0 18.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0]
  #define AO
  #define AO_STRENGTH 1.6 //[0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 3.0 4.0 5.0 7.0 9.0]
  #define AO_QUALITY 1 //[1 2 3 4]
  #define LIGHT_SHAFTS
  #define LIGHT_SHAFT_STRENGTH 0.50 //[0.01 0.02 0.03 0.04 0.05 0.07 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.60 0.75 1.00 1.25 1.50 1.75 2.00 2.50 3.00 1000.0]
  #define LIGHT_SHAFT_MODE 2 //[1 2 3]
  #define LIGHT_SHAFT_NOON_MULTIPLIER 0.50 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00 25.00 50.00]
  #define LIGHT_SHAFT_NIGHT_MULTIPLIER 2.00 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00 25.00 50.00]
  #define LIGHT_SHAFT_RAIN_MULTIPLIER 2.00 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00 25.00 50.00]
  #define LIGHT_SHAFT_UNDERWATER_MULTIPLIER 1.00 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00 25.00 50.00]
  #define LIGHT_SHAFT_THE_END_MULTIPLIER 0.25 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00 25.00 50.00]
  #define REFLECTION
  #define REFLECTION_TRANSLUCENT
  #define WATER_TRANSLUCENT_SKY_REF
  #define WATER_CAUSTICS
//#define PROJECTED_CAUSTICS
//#define WATER_REFRACT
  #define REFRACT_STRENGTH 1.00 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]
//#define BLACK_OUTLINE
//#define PROMO_OUTLINE
  #define PROMO_OUTLINE_MODE 3 //[1 2 3]
  #define PROMO_OUTLINE_STRENGTH 4.00 //[1.00 1.50 2.00 2.50 3.00 3.50 4.00 4.50 5.00 5.50 6.00 6.50 7.00 7.50 8.00]
  #define PROMO_OUTLINE_THICKNESS 1 //[1 2 3 4]
//#define OUTLINE_ON_EVERYTHING

  #define REFLECTION_SPECULAR
  #define REFLECTION_ROUGH
//#define SPECULAR_SKY_REF
//#define REFLECTION_RAIN
  #define REFLECTION_RAIN_COVERAGE 50 //[05 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100]
  #define EMISSIVE_MULTIPLIER 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 6.00 7.00 8.00 9.00 10.00 12.50 15.00 17.50 20.00 30.00 40.00 50.00 100.00]
  #define EMISSIVE_ORES
  #define ORE_EMISSION 1.00 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 6.00 7.00 8.00]
//#define EMISSIVE_NETHER_ORES
  #define EMISSIVE_NETHER_STEMS
  #define EMISSIVE_NETHER_PORTAL
  #define LAVA_INTENSITY 1.00 //[0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00]
  #define FIRE_INTENSITY 1.00 //[0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00]
  #define NORMAL_MAPPING
  #define PARALLAX
  #define PARALLAX_DEPTH 0.50 //[0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00]
  #define SELF_SHADOW
  #define SELF_SHADOW_ANGLE 2.0 //[0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0]
  #define PARALLAX_QUALITY 128 //[16 32 64 128 256 512]
  #define PARALLAX_DISTANCE 16 //[0 8 16 24 32 40 48 56 64 72 80 88 96 104 112 120 128]
  #define DIRECTIONAL_LIGHTMAP
  #define DIRECTIONAL_LIGHTMAP_STRENGTH 3.0 //[7.0 6.5 6.0 5.5 5.0 4.5 4.0 3.5 3.0 2.5 2.0 1.5 1.0]
  #define NORMAL_MULTIPLIER 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00]
//#define GENERATED_NORMALS

  #define DOF 2 //[1 2]
//#define DOF_IS_ON
  #define RAIN_BLUR_MULT 3.00 //[0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 5.25 5.50 5.75 6.00 6.25 6.50 6.75 7.00 7.25 7.50 8.00 8.50 9.00 9.50 10.0 11.0 12.0 13.0 14.0 15.0 17.5 20.0 25.0 30.0 35.0 40.0 45.0 50.0 55.0 60.0 65.0 70.0 75.0 80.0 90.0]
  #define UNDERWATER_BLUR_MULT 4.00 //[0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 5.25 5.50 5.75 6.00 6.25 6.50 6.75 7.00 7.25 7.50 8.00 8.50 9.00 9.50 10.0 11.0 12.0 13.0 14.0 15.0 17.5 20.0 25.0 30.0 35.0 40.0 45.0 50.0 55.0 60.0 65.0 70.0 75.0 80.0 90.0]
  #define NETHER_BLUR
//#define ANAMORPHIC_BLUR
  #define DOF_STRENGTH 32.0 //[1.0 2.0 3.0 4.0 6.0 8.0 12.0 16.0 24.0 32.0 64.0 96.0 128.0 192.0 256.0 384.0 512.0 768.0 1024.0 1536.0 2048.0 3072.0 4096.0]
  #define NETHER_BLUR_STRENGTH 64.0 //[1.0 2.0 3.0 4.0 6.0 8.0 12.0 16.0 24.0 32.0 64.0 96.0 128.0 192.0 256.0 384.0 512.0 768.0 1024.0 1536.0 2048.0 3072.0 4096.0]
//#define MOTION_BLUR
  #define MOTION_BLUR_STRENGTH 1.50 //[0.05 0.07 0.10 0.15 0.20 0.25 0.35 0.50 0.75 1.00 1.25 1.50 1.75 2.00 3.00 5.00 10.00]
  #define BLOOM
  #define BLOOM_STRENGTH 0.40 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.75 1.00 100]
  #define NETHER_BLOOM_MULTIPLIER 1.00 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
//#define LENS_FLARE
  #define LENS_FLARE_STRENGTH 1.00 //[0.10 0.15 0.20 0.25 0.30 0.40 0.50 0.75 1.00 1.25 1.50 1.75 2.00]
  #define AA 3 //[0 1 2 3 4]
  #define SHARPEN 0 //[0 1 2 3 4 5 6 7 8 9 10]
  #define AUTO_EXPOSURE 0 //[0 1 2]
  #define VIGNETTE
  #define VIGNETTE_STRENGTH 0.50 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 4.00 5.00 10.00]
  #define SUN_GLARE
  #define SUN_GLARE_STRENGTH 1.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.5 3.0 4.0 5.0]

//#define COLOR_GRADING
  #define TONEMAP_EXPOSURE 5.6 //[1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0 8.2 8.4 8.6 8.8 9.0 9.2 9.4 9.6 9.8 10.0 10.2 10.4 10.6 10.8 11.0 11.2 11.4 11.6 11.8 12.0 12.2 12.4 12.6 12.8 13.0 13.2 13.4 13.6 13.8 14.0 14.2 14.4 14.6 14.8 15.0 15.2 15.4 15.6 15.8 16.0]
  #define TONEMAP_WHITE_CURVE 2.0 //[1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.5 4.0 4.5 5.0 6.0 7.0 8.0 9.0]
  #define TONEMAP_LOWER_CURVE 1.15 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]
  #define TONEMAP_UPPER_CURVE 1.15 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]
  #define SATURATION 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]
  #define VIBRANCE 1.20 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]

  #define CG_RR 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_RG 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_RB 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_RI 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define CG_RM 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_RC 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define CG_GR 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_GG 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_GB 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_GI 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define CG_GM 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_GC 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define CG_BR 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_BG 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_BB 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_BI 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define CG_BM 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_BC 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define CG_TR 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_TG 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_TB 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_TI 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define CG_TM 0.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0]

  const float sunPathRotation = -40.0; //[-60.0 -55.0 -50.0 -45.0 -40.0 -35.0 -30.0 -25.0 -20.0 -15.0 -10.0 -5.0 0.0 5.0 10.0 15.0 20.0 25.0 30.0 35.0 40.0 45.0 50.0 55.0 60.0]
  const int shadowMapResolution = 2048; //[256 1024 2048 3072 4096 8192]
  const float shadowDistance = 256.0; //[64.0 96.0 128.0 192.0 256.0 384.0 512.0 768.0 1024.0]
  #define SHADOWS
  #define SHADOW_FILTER
  #define SHADOW_SUBSURFACE 2 //[0 1 2]
  #define SCATTERING_LEAVES 0.50 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define SCATTERING_FOLIAGE 0.80 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  const float shadowMapBias = 1.0 - 25.6 / shadowDistance;
//#define CLOUD_SHADOW
//#define NO_FOLIAGE_SHADOWS
  #define VAO_STRENGTH 1.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.2 2.4 2.6 2.8 3.0 3.5 4.0 4.5 5.0]
  #define SHADING_STRENGTH 0.85 //[0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]

  #define LIGHT_MR 236 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_MG 184 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_MB 132 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_MI 1.05 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define AMBIENT_MR 212 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_MG 196 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_MB 228 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_MI 0.25 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define LIGHT_DR 180 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_DG 172 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_DB 164 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_DI 1.40 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define AMBIENT_DR 156 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_DG 188 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_DB 228 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_DI 0.40 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define LIGHT_ER 236 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_EG 180 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_EB 132 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_EI 1.05 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define AMBIENT_ER 212 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_EG 196 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_EB 228 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_EI 0.25 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define LIGHT_NR 152 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_NG 192 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_NB 248 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_NI 0.75 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define AMBIENT_NR 120 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_NG 164 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_NB 228 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_NI 0.40 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define BLOCKLIGHT_R 220 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define BLOCKLIGHT_G 176 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define BLOCKLIGHT_B 140 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define BLOCKLIGHT_I 0.45 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]


//#define COLORED_LIGHT_DEFINE

  #define LIGHT_GROUND 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define AMBIENT_GROUND 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define WATER_R 172 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WATER_G 212 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WATER_B 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WATER_I 0.50 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define WATER_OPACITY 0.50 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define WATER_FOG 64.0 //[4.0 8.0 16.0 32.0 48.0 64.0 96.0 128.0 160.0 192.0 224.0 256.0 512.0]
  #define WATER_V 0.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0]
  #define UNDERWATER_R 0.33 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.30 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44 0.45 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59 0.60 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74 0.75 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89 0.90 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00]
  #define UNDERWATER_G 0.21 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.30 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44 0.45 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59 0.60 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74 0.75 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89 0.90 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00]
  #define UNDERWATER_B 0.26 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.30 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44 0.45 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59 0.60 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74 0.75 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89 0.90 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00]
  #define UNDERWATER_I 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define WEATHER_RR 172 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WEATHER_RG 204 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WEATHER_RB 248 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WEATHER_RI 1.60 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define NETHER_R 128 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define NETHER_G 64 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define NETHER_B 64 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define NETHER_I 1.75 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00 4.25 4.50 4.75 5.00 5.50 6.00 7.00 8.00 9.00 10.00]

  #define END_R 36 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define END_G 28 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define END_B 52 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define END_I 2.25 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00 4.25 4.50 4.75 5.00 5.50 6.00 7.00 8.00 9.00 10.00]

  #define SELECTION_R 164 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define SELECTION_G 128 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define SELECTION_B 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define SELECTION_I 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define SELECTION_MODE 0 //[0 1 2 3]

  #define AURORA_UP_R 112 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_UP_G 80 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_UP_B 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_UP_I 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define AURORA_DOWN_R 80 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_DOWN_G 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_DOWN_B 180 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_DOWN_I 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define ENDER_NEBULA
  #define AURORA
  #define ROUND_SUN_MOON
//#define VANILLA_SKYBOX
  #define SKYBOX_BRIGHTNESS 2.00 //[0.01 0.02 0.03 0.05 0.07 0.10 0.15 0.20 0.25 0.35 0.40 0.45 0.50 0.60 0.75 1.00 1.25 1.50 1.75 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00]
  
  #define SKY_DAY 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00]
  #define SKY_NOON 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00]
  #define SKY_NIGHT 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00]
  #define SKY_RAIN_DAY 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00]
  #define SKY_RAIN_NIGHT 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00]

  #define CLOUDS
  #define CLOUD_THICKNESS 4.00 //[0.25 0.50 0.75 1.00 2.00 3.00 4.00 5.00 6.00 7.00 8.00]
  #define CLOUD_AMOUNT 10.5 //[14.0 13.5 13.0 12.5 12.0 11.5 11.0 10.5 10.0 9.5 9.0 8.5 8.0 7.5 7.0 6.5 6.0]
  #define CLOUD_HEIGHT 30.0 //[2.5 5.0 10.0 15.0 20.0 25.0 30.0 35.0 40.0 45.0 50.0]
  #define CLOUD_SPEED 1.00 //[0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.50 3.00 3.50 4.00 5.00]
  #define CLOUD_OPACITY 0.6 //[0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0]
  #define CLOUD_BRIGHTNESS 2.00 //[0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00]

  #define LIGHTSHAFT_ENDURANCE 1.20 //[0.10 0.25 0.40 0.50 0.60 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.75 2.00 2.50 3.00 4.00 5.00 5.50 10.00]
  #define LIGHTSHAFT_MIN_DISTANCE 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.75 2.00 2.50 3.00 4.00 5.00 7.50 10.00]
  #define LIGHTSHAFT_MAX_DISTANCE 96.0 //[32.0 64.0 96.0 128.0 160.0 192.0 224.0 256.0 320.0 384.0 448.0 512.0]
  #define LIGHTSHAFT_DISTANCE_EXPONENT 1.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0 8.2 8.4 8.6 8.8 9.0 9.2 9.4 9.6 9.8 10.0 10.2 10.4 10.6 10.8 11.0 11.2 11.4 11.6 11.8 12.0 12.2 12.4 12.6 12.8 13.0 13.2 13.4 13.6 13.8 14.0 14.2 14.4 14.6 14.8 15.0 15.2 15.4 15.6 15.8 16.0]
  #define LIGHTSHAFT_BREAK 1 //[0 1]
  #define LIGHTSHAFT_SAMPLE_INTENSITY 7.8 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0 8.2 8.4 8.6 8.8 9.0 9.2 9.4 9.6 9.8 10.0 10.2 10.4 10.6 10.8 11.0 11.2 11.4 11.6 11.8 12.0 12.2 12.4 12.6 12.8 13.0 13.2 13.4 13.6 13.8 14.0 14.2 14.4 14.6 14.8 15.0 15.2 15.4 15.6 15.8 16.0 18.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0 36.0 40.0 44.0 48.0 52.0 56.0 60.0 64.0]
  #define LIGHTSHAFT_SAMPLE_COUNT 9 //[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 17 20 25 30 35 40 50 60 70 80 90 100 120 150 200 250 300 350 400 500 700 1000]
  

//#define GALAXIES
  #define GALAXY_BRIGHTNESS 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define SHADER_STARS
  #define STAR_BRIGHTNESS 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define STAR_AMOUNT 1 //[1 2]
  #define SUNSET_STARS

  #define WATER_TYPE 0 //[0 1 2]
//#define WATER_DISPLACEMENT
  #define WATER_PARALLAX
  #define WATER_BUMP 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 5.50 6.00 6.50 7.00 7.50 8.00]
  #define WATER_NOISE_1 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
  #define WATER_NOISE_2 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
  #define WATER_NOISE_3 0.40 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
  #define WATER_NOISE_4 0.30 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
  #define SUN_MOON_WATER_REF 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 5.50 6.00 6.50 7.00 7.50 8.00 8.50 9.00 9.50 10.0 11.0 12.0 13.0 14.0 15.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0]
  #define MOON_WATER_REF 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
  #define WATER_SHARPNESS 0.25 //[0.01 0.02 0.03 0.05 0.07 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50]
  #define WATER_SIZE 450.0 //[25.0 50.0 100.0 150.0 200.0 250.0 300.0 350.0 400.0 450.0 500.0 550.0 600.0 650.0 700.0 750.0 800.0 850.0 900.0 950.0 1000.0 1100.0 1200.0 1300.0 1400.0 1500.0]
  #define WATER_SPEED 1.25 //[0.05 0.10 0.15 0.20 0.25 0.35 0.50 0.60 0.75 0.90 1.00 1.10 1.25 1.50 1.75 2.00 2.50 3.00 3.50 4.00 4.25 4.50 4.75 5.00 5.50 6.00 6.50 7.00 7.50 8.00]
  #define UNDERWATER_DISTORT 1.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 100.0 1000.0]

//#define WHITE_WORLD
  #define NETHER_FOG
//#define NETHER_SMOKE
  #define FOG1
  #define FOG1_DISTANCE 10 //[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 18 20 22 24 26 28 30 32 36 40 44 48 52 56 60 64]
  #define FOG1_TYPE 1 //[0 1 2]
  #define FOG2
  #define FOG2_ALTITUDE_MODE
  #define FOG2_BRIGHTNESS 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define FOG2_END_BRIGHTNESS 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define FOG2_DISTANCE 10.0 //[0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0 9.5 10.0 11.0 12.0 13.0 14.0 15.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0 36.0 40.0 44.0 48.0 52.0 56.0 60.0 64.0]
  #define FOG2_ALTITUDE 95 //[0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300]
  #define FOG2_OPACITY 0.30 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define FOG2_END_DISTANCE 8.0 //[0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0 9.5 10.0 11.0 12.0 13.0 14.0 15.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0 36.0 40.0 44.0 48.0 52.0 56.0 60.0 64.0]
  #define FOG2_END_ALTITUDE 80 //[0 5 10 15 20 25 30 35 40 45 50 55 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300]
  #define FOG2_END_OPACITY 0.65 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define FOG2_RAIN_OPACITY_M 3.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00 4.25 4.50 4.75 5.00 5.25 5.50 5.75 6.00 6.25 6.50 6.75 7.00 7.50 8.00 8.50 9.00 9.50 10.0]
  #define FOG2_RAIN_BRIGHTNESS_M 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00 4.25 4.50 4.75 5.00 5.25 5.50 5.75 6.00 6.25 6.50 6.75 7.00 7.50 8.00 8.50 9.00 9.50 10.0]
  #define FOG2_RAIN_ALTITUDE_M 0.25 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define FOG2_RAIN_DISTANCE_M 1.00 //[-1.00 -0.95 -0.90 -0.85 -0.80 -0.75 -0.70 -0.65 -0.60 -0.55 -0.50 -0.45 -0.40 -0.35 -0.30 -0.25 -0.20 -0.15 -0.10 -0.05 0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00 4.25 4.50 4.75 5.00 5.25 5.50 5.75 6.00 6.25 6.50 6.75 7.00 7.50 8.00 8.50 9.00 9.50 10.0]
//#define WORLD_CURVATURE
  #define OVERWORLD_CURVATURE_SIZE 2048 //[-256 -512 -1024 -2048 -4096 -8192 -16384 -32768 999999 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16]
  #define NETHER_CURVATURE_SIZE 2048 //[-256 -512 -1024 -2048 -4096 -8192 -16384 -32768 999999 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16]
  #define END_CURVATURE_SIZE 2048 //[-256 -512 -1024 -2048 -4096 -8192 -16384 -32768 999999 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16]
  #define WORLD_TIME_ANIMATION 1 //[0 1 2]
  #define ANIMATION_SPEED 1.00 //[0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.50 3.00 3.50 4.00 5.00 6.00 7.00 8.00 16.00 32.00 64.00 128.00]
  #define MIN_LIGHT 32 //[0 1 2 4 8 16 32 64 128 256 512 1024 2048]
//#define NO_PARTICLES
//#define BLOCKLIGHT_FLICKER
  #define BLOCKLIGHT_FLICKER_STRENGTH 0.60 //[0.00 0.10 0.20 0.30 0.40 0.50 0.60 0.70 0.80 0.90 1.00 1.50 2.00 3.00 4.00]

//Define Handling//
  #if (RP_SUPPORT == 1 && !defined COMPATIBILITY_MODE) || RP_SUPPORT > 2 
    #define ADV_MAT
  #endif

  #if !defined COMPATIBILITY_MODE && RP_SUPPORT == 1
    #define COMPBR
    #undef PARALLAX
    #undef SELF_SHADOW
    #undef DIRECTIONAL_LIGHTMAP
    #ifndef GENERATED_NORMALS
      #undef NORMAL_MAPPING
    #endif
  #endif
  
  #ifndef NORMAL_MAPPING
    #undef PARALLAX
    #undef SELF_SHADOW
    #undef DIRECTIONAL_LIGHTMAP
  #endif

  #if defined ENTITY_NORMAL_FIX && MC_VERSION >= 11500 && MC_VERSION < 11700 && (defined GBUFFERS_ENTITIES || defined GBUFFERS_HAND || defined GBUFFERS_BLOCK)
    #undef PARALLAX
    #undef SELF_SHADOW
    #undef DIRECTIONAL_LIGHTMAP
    #undef NORMAL_MAPPING
  #endif

  #ifndef SHADOWS
    #undef LIGHT_SHAFTS
  #endif

  #ifdef COMPATIBILITY_MODE
    #undef LIGHTNING_BOLTS_FIX
    #undef FLICKERING_FIX
    #ifndef DO_WAVING_ON_COMPATIBILITY
      #undef WAVING_FOLIAGE
      #undef WAVING_LEAVES
      #undef WAVING_CROPS
      #undef WAVING_VINES
      #undef WAVING_LILY_PADS
    #endif
  #endif

  #if defined ADV_MAT && !defined COMPATIBILITY_MODE && defined COLORED_LIGHT_DEFINE
    #define COLORED_LIGHT
    #undef RANDOM_BLOCKLIGHT
  #endif

//Dimension Undefine//
  #ifdef NETHER
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
  #endif

  #ifdef END
    #undef LENS_FLARE
  #endif
  
  #ifdef SEVEN_2
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
    #undef CLOUDS
  #endif
  
  #ifdef TWO
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
  #endif

  #ifdef SEVEN
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
  #endif

  #ifdef TWO
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
  #endif

  #ifdef ONESEVEN
    #undef LIGHT_SHAFTS
  #endif

  #ifdef TWENTY
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
  #endif

//Shenanigans//
  #ifdef GLOWING_ENTITY_FIX
  #endif
  #ifdef NETHER_BLUR
  #endif
  #ifdef DOF_IS_ON
  #endif
  #ifdef ENTITY_NORMAL_FIX
  #endif
  #ifdef WATER_DISPLACEMENT
  #endif
  #ifdef NO_PARTICLES
  #endif
  #ifdef FOG2_ALTITUDE_MODE
  #endif
  #ifdef HAND_BLOOM_REDUCTION
  #endif
  #ifdef EMISSIVE_NETHER_PORTAL
  #endif
  #ifdef FOG1_CHECK
  #endif
  #ifdef LIGHTSHAFT_WATER_CAUSTICS
  #endif
  #ifdef OUTLINE_ON_EVERYTHING
  #endif
  #ifdef FOG2
  #endif
  #ifdef CLOUD_SHADOW
  #endif
  #ifdef LIGHT_SHAFTS
  #endif
  #ifdef NETHER_FOG
  #endif
  #ifdef REFLECTION_SPECULAR
  #endif
  #ifdef GENERATED_NORMALS
  #endif
  #ifdef VANILLA_SKYBOX
  #endif
  #ifdef COLORED_LIGHT_DEFINE
  #endif

//Very Common Functions//
float pow2(float number) {
    return number * number;
}

float sqrt1(float number) { // Faster sqrt() for numbers that are between 0 and 1
    number = 1.0 - number;
    number *= number;
    return 1.0 - number;
}

float sqrt2(float number) {
    number = 1.0 - number;
    number *= number;
    number *= number;
    return 1.0 - number;
}
float sqrt3(float number) {
    number = 1.0 - number;
    number *= number;
    number *= number;
    number *= number;
    return 1.0 - number;
}
float sqrt4(float number) {
    number = 1.0 - number;
    number *= number;
    number *= number;
    number *= number;
    number *= number;
    return 1.0 - number;
}
float sqrt5(float number) { // Barely faster than pow(number, 0.03125)
    number = 1.0 - number;
    number *= number;
    number *= number;
    number *= number;
    number *= number;
    number *= number;
    return 1.0 - number;
}

float sqrt1inv(float number) {
    number = 1.0 - number;
    number *= number;
    return number;
}

vec3 sqrt1vec3(vec3 vector) {
    vector = vec3(1.0) - vector;
    vector *= vector;
    return vec3(1.0) - vector;
}

vec3 TextureSample3R(sampler2D texture, vec2 coord) {
    vec3 result = texture2D(texture, coord).rgb;
    return result;
}

//Varyings//
varying float mat;

varying vec2 texCoord, lmCoord;

varying vec3 normal, binormal, tangent;
varying vec3 sunVec, upVec;
varying vec3 viewVector;

varying vec4 color;

#if defined ADV_MAT && defined NORMAL_MAPPING && !defined COMPBR
varying vec4 vTexCoord, vTexCoordAM;
#endif

//////////Fragment Shader//////////Fragment Shader//////////Fragment Shader//////////
#ifdef FSH

//Uniforms//
uniform int frameCounter;
uniform int isEyeInWater;
uniform int worldTime;
uniform int worldDay;
uniform int moonPhase;

#ifdef DYNAMIC_SHADER_LIGHT
	uniform int heldItemId, heldItemId2;

	uniform int heldBlockLightValue;
	uniform int heldBlockLightValue2;
#endif

uniform float frameTimeCounter;
uniform float blindFactor, nightVision;
uniform float far, near;
uniform float rainStrengthS;
uniform float screenBrightness; 
uniform float shadowFade;
uniform float timeAngle, timeBrightness, moonBrightness;
uniform float viewWidth, viewHeight;
uniform float eyeAltitude;

uniform ivec2 eyeBrightnessSmooth;

uniform vec3 cameraPosition;
uniform vec3 skyColor;
uniform vec3 fogColor;

uniform mat4 gbufferProjection, gbufferPreviousProjection, gbufferProjectionInverse;
uniform mat4 gbufferModelView, gbufferPreviousModelView, gbufferModelViewInverse;
uniform mat4 shadowProjection;
uniform mat4 shadowModelView;

uniform sampler2D texture;
uniform sampler2D gaux2;
uniform sampler2D depthtex1;
uniform sampler2D noisetex;

#if defined ADV_MAT && defined NORMAL_MAPPING && !defined COMPBR
uniform sampler2D normals;
#endif

#ifdef AURORA
uniform float isDry, isRainy, isSnowy;
#endif

#ifdef COLORED_LIGHT
uniform sampler2D colortex9;
#endif

//Optifine Constants//

//Common Variables//
float eBS = eyeBrightnessSmooth.y / 240.0;
float sunVisibility  = clamp(dot( sunVec,upVec) + 0.0625, 0.0, 0.125) * 8.0;
float vsBrightness = clamp(screenBrightness, 0.0, 1.0);

#if WORLD_TIME_ANIMATION == 2
float modifiedWorldDay = mod(worldDay, 100.0) + 5.0;
float frametime = (worldTime + modifiedWorldDay * 24000) * 0.05 * ANIMATION_SPEED;
float cloudtime = frametime;
#endif
#if WORLD_TIME_ANIMATION == 1
float modifiedWorldDay = mod(worldDay, 100.0) + 5.0;
float frametime = frameTimeCounter * ANIMATION_SPEED;
float cloudtime = (worldTime + modifiedWorldDay * 24000) * 0.05 * ANIMATION_SPEED;
#endif
#if WORLD_TIME_ANIMATION == 0
float frametime = frameTimeCounter * ANIMATION_SPEED;
float cloudtime = frametime;
#endif

#if defined ADV_MAT && defined NORMAL_MAPPING
vec2 dcdx = dFdx(texCoord.xy);
vec2 dcdy = dFdy(texCoord.xy);
#endif

#ifdef OVERWORLD
	vec3 lightVec = sunVec * ((timeAngle < 0.5325 || timeAngle > 0.9675) ? 1.0 : -1.0);
#else
	vec3 lightVec = sunVec;
#endif

#if WATER_TYPE == 0
float waterBump = WATER_BUMP * 1.2;
#else
float waterBump = WATER_BUMP * 0.20;
#endif

//Common Functions//
float GetLuminance(vec3 color) {
	return dot(color,vec3(0.299, 0.587, 0.114));
}

float InterleavedGradientNoise() {
	float n = 52.9829189 * fract(0.06711056 * gl_FragCoord.x + 0.00583715 * gl_FragCoord.y);
	return fract(n + frameCounter / 8.0);
}
 
float GetWaterHeightMap(vec3 worldPos, vec3 nViewPos) {
	float verticalOffset = worldPos.y * 0.005;

	vec2 wind = vec2(frametime) * 0.0015;
	wind *= WATER_SPEED;
	wind -= verticalOffset;

	float noiseA = texture2D(noisetex, (worldPos.xz) / (1.0 * WATER_SIZE) - wind).g;
	float noiseB = texture2D(noisetex, (worldPos.xz) / (0.6 * WATER_SIZE) + wind).g;
	float noiseC = texture2D(noisetex, (worldPos.xz) / (0.35 * WATER_SIZE) + wind).g;
	float noiseD = texture2D(noisetex, (worldPos.xz) / (0.3 * WATER_SIZE) - wind).g;
	vec4 noiseS = vec4(noiseA, noiseB, noiseC, noiseD);
	noiseS *= - noiseS;
	float noise = noiseS.r * WATER_NOISE_1 
				- noiseS.r * noiseS.g * WATER_NOISE_2 
				+ noiseS.g * WATER_NOISE_3 
				+ (noiseS.b - noiseS.a) * WATER_NOISE_4;

	noise *= waterBump * (lmCoord.y*0.9 + 0.1) * 0.35;

    return noise;
}

vec3 GetParallaxWaves(vec3 worldPos, vec3 nViewPos, vec3 viewVector, float lViewPos) {
	vec3 parallaxPos = worldPos;
	
	for(int i = 0; i < 4; i++) {
		float height = (GetWaterHeightMap(parallaxPos, nViewPos) - 0.5);
		parallaxPos.xz += 0.05 * height * viewVector.xy / sqrt(lViewPos);
	}
	return parallaxPos;
}

vec3 GetWaterNormal(vec3 worldPos, vec3 nViewPos, vec3 viewVector, float lViewPos) {
	vec3 waterPos = worldPos + cameraPosition;
	#ifdef WATER_PARALLAX
		waterPos = GetParallaxWaves(waterPos, nViewPos, viewVector, lViewPos);
	#endif

	float normalOffset = WATER_SHARPNESS;

	float h1 = GetWaterHeightMap(waterPos + vec3( normalOffset, 0.0, 0.0), nViewPos);
	float h2 = GetWaterHeightMap(waterPos + vec3(-normalOffset, 0.0, 0.0), nViewPos);
	float h3 = GetWaterHeightMap(waterPos + vec3(0.0, 0.0,  normalOffset), nViewPos);
	float h4 = GetWaterHeightMap(waterPos + vec3(0.0, 0.0, -normalOffset), nViewPos);

	float xDelta = (h1 - h2) / normalOffset;
	float yDelta = (h3 - h4) / normalOffset;
	float aDelta = xDelta * xDelta + yDelta * yDelta;

	vec3 normalMap = vec3(xDelta, yDelta, 1.0 - aDelta);

	#if defined REFLECTION_ROUGH && WATER_TYPE == 2
		vec3 roughMap = texture2D(noisetex, texCoord * 2097152).rgb;
		normalMap = normalMap + 0.5 * (roughMap - vec3(0.5, 0.5, 1.0));
	#endif

	vec3 normalClamp = vec3(1.75);
	normalMap = clamp(normalMap, normal - normalClamp, normal + normalClamp);
	normalMap = normalMap * 0.03 + vec3(0.0, 0.0, 0.75);

	return normalMap;
}

float GetWaterOpacity(float alpha, float difT, float fresnel, float lViewPos) {
	//Fake water fog
	float waterFogDist = 1.0 - min(difT / WATER_FOG * 2.0, 1.0);
	waterFogDist *= waterFogDist;
	alpha = mix(0.97, alpha, min(waterFogDist, 1.0 - fresnel));

	//Hide shadows not being good enough
	alpha = max(min(sqrt(lViewPos) * 0.075, 0.9), alpha);

	return alpha;
}

//Includes//
#ifndef COLORED_LIGHT
vec3 blocklightColSqrt = vec3(BLOCKLIGHT_R, BLOCKLIGHT_G, BLOCKLIGHT_B) * BLOCKLIGHT_I / 255.0;
vec3 blocklightCol = blocklightColSqrt * blocklightColSqrt;
#else
vec3 blocklightColSqrt = vec3(0.387, 0.31, 0.247);
vec3 blocklightCol = vec3(0.15, 0.096, 0.061);
#endif
#if defined OVERWORLD || defined SEVEN
vec3 lightMorning    = vec3(LIGHT_MR, LIGHT_MG, LIGHT_MB) * LIGHT_MI / 255.0;
vec3 lightDay        = vec3(LIGHT_DR, LIGHT_DG, LIGHT_DB) * LIGHT_DI / 255.0;
vec3 lightEvening    = vec3(LIGHT_ER, LIGHT_EG, LIGHT_EB) * LIGHT_EI / 255.0;
#ifndef ONESEVEN
vec3 lightNight      = vec3(LIGHT_NR, LIGHT_NG, LIGHT_NB) * LIGHT_NI * (vsBrightness*0.125 + 0.80) * 0.4 / 255.0;
#else
vec3 lightNight      = (vec3(LIGHT_NR, LIGHT_NG, LIGHT_NB) * LIGHT_NI * 0.195 / 255.0) + vec3(0.37, 0.31, 0.25) * 0.35 ;
#endif

vec3 ambientMorning  = vec3(AMBIENT_MR, AMBIENT_MG, AMBIENT_MB) * AMBIENT_MI * 1.1 / 255.0;
vec3 ambientDay      = vec3(AMBIENT_DR, AMBIENT_DG, AMBIENT_DB) * AMBIENT_DI * 1.1 / 255.0;
vec3 ambientEvening  = vec3(AMBIENT_ER, AMBIENT_EG, AMBIENT_EB) * AMBIENT_EI * 1.1 / 255.0;
vec3 ambientNight    = vec3(AMBIENT_NR, AMBIENT_NG, AMBIENT_NB) * AMBIENT_NI * (vsBrightness*0.20 + 0.70) * 0.495 / 255.0;

vec3 weatherCol = vec3(WEATHER_RR, WEATHER_RG, WEATHER_RB) * WEATHER_RI / 255.0;
vec3 weatherIntensity = vec3(WEATHER_RI);

float mefade = 1.0 - clamp(abs(timeAngle - 0.5) * 8.0 - 1.5, 0.0, 1.0);
float dfade = 1.0 - timeBrightness;

vec3 CalcLightColor(vec3 morning, vec3 day, vec3 afternoon, vec3 night, vec3 weatherCol) {
	vec3 me = mix(morning, afternoon, mefade);
	float dfadeModified = dfade * dfade;
	vec3 dayAll = mix(me, day, 1.0 - dfadeModified * dfadeModified);
	vec3 c = mix(night, dayAll, sunVisibility);
	c = mix(c, dot(c, vec3(0.299, 0.587, 0.114)) * weatherCol, rainStrengthS*0.6);
	return c * c;
}

vec3 lightCol   = CalcLightColor(lightMorning,   lightDay,   lightEvening,   lightNight,
								 weatherCol * (vsBrightness*0.1 + 0.9));
vec3 ambientCol = CalcLightColor(ambientMorning, ambientDay, ambientEvening, ambientNight,
								 weatherCol * (vsBrightness*0.1 + 0.9));
#endif

#ifdef NETHER
#if MC_VERSION <= 11600
vec3 netherColSqrt = vec3(NETHER_R, NETHER_G, NETHER_B) * 0.25 * NETHER_I / 255.0;
vec3 netherCol = netherColSqrt * netherColSqrt;
#else
vec3 netherCol = fogColor * (1 - length(fogColor / 3.0)) * 0.25 * NETHER_I;
#endif
#endif

#ifdef END
vec3 endColSqrt = vec3(END_R, END_G, END_B) * 2.25 / 255.0;
vec3 endCol = endColSqrt * endColSqrt;
#endif
vec3 sky_ColorSqrt = vec3(136.0, 172.0, 236.0) * 1.10 / 255.0;

vec3 skyColCustom = sky_ColorSqrt * sky_ColorSqrt;
vec4 underwaterColor = vec4(pow(fogColor, vec3(UNDERWATER_R, UNDERWATER_G, UNDERWATER_B)) * UNDERWATER_I * 0.2, 1.0);
vec4 waterColorSqrt = vec4(WATER_R, WATER_G, WATER_B, 255.0) * WATER_I / 255.0;
vec4 waterColor = waterColorSqrt * waterColorSqrt;

const float waterFog = WATER_FOG;

const float waterAlpha = WATER_OPACITY;
//GGX area light approximation from Horizon Zero Dawn
float GetNoHSquared(float radiusTan, float NoL, float NoV, float VoL) {
    float radiusCos = 1.0 / sqrt(1.0 + radiusTan * radiusTan);
    
    float RoL = 2.0 * NoL * NoV - VoL;
    if (RoL >= radiusCos)
        return 1.0;

    float rOverLengthT = radiusCos * radiusTan / sqrt(1.0 - RoL * RoL);
    float NoTr = rOverLengthT * (NoV - RoL * NoL);
    float VoTr = rOverLengthT * (2.0 * NoV * NoV - 1.0 - RoL * VoL);

    float triple = sqrt(clamp(1.0 - NoL * NoL - NoV * NoV - VoL * VoL + 2.0 * NoL * NoV * VoL, 0.0, 1.0));
    
    float NoBr = rOverLengthT * triple, VoBr = rOverLengthT * (2.0 * triple * NoV);
    float NoLVTr = NoL * radiusCos + NoV + NoTr, VoLVTr = VoL * radiusCos + 1.0 + VoTr;
    float p = NoBr * VoLVTr, q = NoLVTr * VoLVTr, s = VoBr * NoLVTr;    
    float xNum = q * (-0.5 * p + 0.25 * VoBr * NoLVTr);
    float xDenom = p * p + s * ((s - 2.0 * p)) + NoLVTr * ((NoL * radiusCos + NoV) * VoLVTr * VoLVTr + 
                   q * (-0.5 * (VoLVTr + VoL * radiusCos) - 0.5));
    float twoX1 = 2.0 * xNum / (xDenom * xDenom + xNum * xNum);
    float sinTheta = twoX1 * xDenom;
    float cosTheta = 1.0 - twoX1 * xNum;
    NoTr = cosTheta * NoTr + sinTheta * NoBr;
    VoTr = cosTheta * VoTr + sinTheta * VoBr;
    
    float newNoL = NoL * radiusCos + NoTr;
    float newVoL = VoL * radiusCos + VoTr;
    float NoH = NoV + newNoL;
    float HoH = 2.0 * newVoL + 2.0;
    return clamp(NoH * NoH / HoH, 0.0, 1.0);
}

float SchlickGGX(float NoL, float NoV, float roughness) {
    float k = roughness * 0.5;
        
    float smithL = 0.5 / (NoL * (1.0 - k) + k);
    float smithV = 0.5 / (NoV * (1.0 - k) + k);

    return smithL * smithV;
}

float GGX(vec3 normal, vec3 viewPos, vec3 lightVec, float smoothness, float f0, float sunSize) {
    float roughness = 1.0 - smoothness;
    if (roughness < 0.05) roughness = 0.05;
    float roughnessP = roughness;
    roughness *= roughness; roughness *= roughness;
    
    vec3 halfVec = normalize(lightVec - viewPos);

    float dotLH = clamp(dot(halfVec, lightVec), 0.0, 1.0);
    float dotNL = clamp(dot(normal,  lightVec), 0.0, 1.0);
    float dotNV = dot(normal, -viewPos);
    float dotNH = GetNoHSquared(sunSize, dotNL, dotNV, dot(-viewPos, lightVec));
    
    float denom = dotNH * roughness - dotNH + 1.0;
    float D = roughness / (3.141592653589793 * denom * denom);
    float F = exp2((-5.55473 * dotLH - 6.98316) * dotLH) * (1.0 - f0) + f0;
    float k2 = roughness * 0.5;

    float specular = max(dotNL * dotNL * D * F / (dotLH * dotLH * (1.0 - k2) + k2), 0.0);
    specular = max(specular, 0.0);
    specular = specular / (0.125 * specular + 1.0);

    float schlick = SchlickGGX(dotNL, dotNV, roughness);
    schlick = pow(schlick * 0.5, roughnessP);
    specular *= clamp(schlick, 0.0, 1.25);

    if (sunVisibility == 0.0) specular *= float(moonPhase == 0) * 0.35 + 0.65 - float(moonPhase == 4) * 0.65;
    else specular *= 1.5;

    return specular * (1.0 - isEyeInWater*0.75);
}

float stylisedGGX(vec3 normal, vec3 oldNormal, vec3 nViewPos, vec3 lightVec, float f0) {

    vec3 halfVec = normalize(lightVec - nViewPos);

    float dotLH = clamp(dot(halfVec, lightVec), 0.0, 1.0);
    float dotOldL = clamp(dot(oldNormal,  lightVec), 0.0, 1.0);
    float dotNmOL = clamp(dot(normal - oldNormal,  lightVec), 0.0, 1.0);

    float sunSize = 0.037;
    
    float dotNH = GetNoHSquared(sunSize, dotOldL, dot(oldNormal, -nViewPos), dot(-nViewPos, lightVec));

    dotOldL *= dotOldL;
    
    float roughness = 0.05;
    
    float denom = dotNH * roughness - dotNH + 1.0;
    float D = roughness / (3.141592653589793 * denom * denom);
    float F = exp2((-5.55473 * dotLH - 6.98316) * dotLH) * (1.0 - f0) + f0;
    float k2 = roughness * 0.25;

    float specular = max(dotOldL * D * F / (dotLH * dotLH * (1.0 - k2) + k2), 0.0);
    specular = max(specular, 0.0);
    specular = specular / (0.125 * specular + 1.0);

    dotNmOL *= dotNH * dotNH;
    dotNmOL *= dotNmOL * 350.0 * SUN_MOON_WATER_REF;
    dotNmOL *= dotNmOL;
    dotNmOL = max(dotNmOL * 0.25, sunVisibility * pow2(dotNmOL * dotNmOL));
    specular *= 0.075 + 9.0 * min(dotNmOL * 6.0, 50.0);
    specular *= 0.4 + 1.71 * dotOldL;

    if (sunVisibility == 0.0) {
        specular *= 0.25 * MOON_WATER_REF;
        specular *= float(moonPhase == 0) * 0.35 + 0.65 - float(moonPhase == 4) * 0.65;
    }

    return max(specular * (1.0 - isEyeInWater*0.75), 0.0);
}

vec3 GetMetalCol(float f0) {
    int metalidx = int(f0 * 255.0);

    if (metalidx == 230) return vec3(0.24867, 0.22965, 0.21366);
    if (metalidx == 231) return vec3(0.88140, 0.57256, 0.11450);
    if (metalidx == 232) return vec3(0.81715, 0.82021, 0.83177);
    if (metalidx == 233) return vec3(0.27446, 0.27330, 0.27357);
    if (metalidx == 234) return vec3(0.84430, 0.48677, 0.22164);
    if (metalidx == 235) return vec3(0.36501, 0.35675, 0.37653);
    if (metalidx == 236) return vec3(0.42648, 0.37772, 0.31138);
    if (metalidx == 237) return vec3(0.91830, 0.89219, 0.83662);
    return vec3(1.0);
}

vec3 GetSpecularHighlight(float smoothness, float metalness, float f0, vec3 specularColor,
                          vec3 rawAlbedo, float shadow, vec3 normal, vec3 viewPos) {
    #ifndef SHADOWS
        return vec3(0.0);
    #endif
                              
    if (dot(shadow, shadow) < 0.001) return vec3(0.0);

    #ifdef END
        smoothness *= 0.0;
    #endif

    float specular = GGX(normal, normalize(viewPos), lightVec, smoothness, f0,
                         0.01 * sunVisibility + 0.06);
    specular *= sqrt1inv(rainStrengthS);

    #ifdef SHADOWS
        specular *= shadowFade;
    #endif
    
    specularColor = pow(specularColor, vec3(1.0 - 0.5 * metalness));
	
	#ifdef COMPBR
		specularColor *= pow(rawAlbedo, vec3(metalness * 0.8));
	#else
		#if RP_SUPPORT == 3
            if (metalness > 0.5) {
                if (f0 < 1.0) specularColor *= GetMetalCol(f0);
                else specularColor *= rawAlbedo;
            }
		#else
		    specularColor *= pow(rawAlbedo, vec3(metalness));
		#endif
	#endif

    return specular * specularColor * shadow;
}
//Thanks to Jessie for dithering
float Bayer2  (vec2 c) { c = 0.5 * floor(c); return fract(1.5 * fract(c.y) + c.x); }
float Bayer4  (vec2 c) { return 0.25 * Bayer2  (0.5 * c) + Bayer2(c); }
float Bayer8  (vec2 c) { return 0.25 * Bayer4  (0.5 * c) + Bayer2(c); }
float Bayer16 (vec2 c) { return 0.25 * Bayer8  (0.5 * c) + Bayer2(c); }
float Bayer32 (vec2 c) { return 0.25 * Bayer16 (0.5 * c) + Bayer2(c); }
float Bayer64 (vec2 c) { return 0.25 * Bayer32 (0.5 * c) + Bayer2(c); }
float Bayer128(vec2 c) { return 0.25 * Bayer64 (0.5 * c) + Bayer2(c); }
float Bayer256(vec2 c) { return 0.25 * Bayer128(0.5 * c) + Bayer2(c); }
vec3 nvec3(vec4 pos) {
    return pos.xyz/pos.w;
}

vec4 nvec4(vec3 pos) {
    return vec4(pos.xyz, 1.0);
}

float cdist(vec2 coord) {
	return max(abs(coord.s-0.5) * 1.82, abs(coord.t-0.5) * 2.0);
}

vec4 Raytrace(sampler2D depthtex, vec3 viewPos, vec3 normal, float dither, float fresnelRT) {
	vec3 pos = vec3(0.0);
	float dist = 0.0;

	#if AA > 1
		dither = fract(dither + frameTimeCounter);
	#endif

	vec3 start = viewPos;
	vec3 nViewPos = normalize(viewPos);
    vec3 vector = 0.5 * reflect(nViewPos, normalize(normal));
    viewPos += vector;
	vec3 tvector = vector;

	float difFactor = fresnelRT;

    int sr = 0;

    for(int i = 0; i < 30; i++) {
        pos = nvec3(gbufferProjection * nvec4(viewPos)) * 0.5 + 0.5;
		if (pos.x < -0.05 || pos.x > 1.05 || pos.y < -0.05 || pos.y > 1.05) break;

		vec3 rfragpos = vec3(pos.xy, texture2D(depthtex,pos.xy).r);
        rfragpos = nvec3(gbufferProjectionInverse * nvec4(rfragpos * 2.0 - 1.0));
		dist = length(start - rfragpos);

        float err = length(viewPos - rfragpos);
		float lVector = length(vector);
		float dif = length(start - rfragpos);
		if (err < pow(lVector, 1.14) || (dif < difFactor && err > difFactor)) {
                sr++;
                if(sr >= 6) break;
				tvector -= vector;
                vector *= 0.1;
		}
        vector *= 2.0;
        tvector += vector * (dither * 0.05 + 0.75);
		viewPos = start + tvector;
    }

	return vec4(pos, dist);
}
#define diagonal3(m) vec3((m)[0].x, (m)[1].y, m[2].z)
#define projMAD(m, v) (diagonal3(m) * (v) + (m)[3].xyz)

vec3 ToNDC(vec3 pos) {
	vec4 iProjDiag = vec4(gbufferProjectionInverse[0].x,
						  gbufferProjectionInverse[1].y,
						  gbufferProjectionInverse[2].zw);
    vec3 p3 = pos * 2.0 - 1.0;
    vec4 viewPos = iProjDiag * p3.xyzz + gbufferProjectionInverse[3];
    return viewPos.xyz / viewPos.w;
}

vec3 ToWorld(vec3 pos) {
	return mat3(gbufferModelViewInverse) * pos + gbufferModelViewInverse[3].xyz;
}

vec3 ToShadow(vec3 pos) {
	vec3 shadowpos = mat3(shadowModelView) * pos + shadowModelView[3].xyz;
	return projMAD(shadowProjection, shadowpos);
}
#if (defined OVERWORLD || defined END || defined SEVEN) && defined SHADOWS
uniform sampler2DShadow shadowtex0;

vec2 shadowoffsets[8] = vec2[8](    vec2( 0.0   , 1.0   ),
                                    vec2( 0.7071, 0.7071),
                                    vec2( 1.0   , 0.0   ),
                                    vec2( 0.7071,-0.7071),
                                    vec2( 0.0   ,-1.0   ),
                                    vec2(-0.7071,-0.7071),
                                    vec2(-1.0   , 0.0   ),
                                    vec2(-0.7071, 0.7071));

vec2 offsetDist(float x, float s) {
	float n = fract(x * 1.414) * 3.1415;
    return vec2(cos(n), sin(n)) * 1.4 * x / s;
}

float SampleBasicShadow(vec3 shadowPos) {
    float shadow0 = shadow2D(shadowtex0, vec3(shadowPos.st, shadowPos.z)).x;

    return shadow0;
}

float SampleFilteredShadow(vec3 shadowPos, float offset) {
    float shadow = SampleBasicShadow(vec3(shadowPos.st, shadowPos.z)) * 2.0;

    for(int i = 0; i < 8; i++) {
        shadow+= SampleBasicShadow(vec3(offset * 1.2 * shadowoffsets[i] + shadowPos.st, shadowPos.z));
    }

    return shadow * 0.1;
}

float SampleTAAFilteredShadow(vec3 shadowPos, float offset) {
    float noise = InterleavedGradientNoise();
    float shadow = 0.0;
    offset = offset * (2.0 - 0.5 * (0.85 + 0.25 * (3072.0 / shadowMapResolution)));
    if (shadowMapResolution < 400.0) offset *= 30.0;

    for(int i = 0; i < 2; i++) {
        vec2 offset = offsetDist(noise + i, 2.0) * offset;
        shadow += SampleBasicShadow(vec3(shadowPos.st + offset, shadowPos.z));
        shadow += SampleBasicShadow(vec3(shadowPos.st - offset, shadowPos.z));
    }
    
    return shadow * 0.25;
}

float GetShadow(vec3 shadowPos, float offset) {

    #ifdef SHADOW_FILTER
        #if AA > 1
            float shadow = SampleTAAFilteredShadow(shadowPos, offset);
        #else
            float shadow = SampleFilteredShadow(shadowPos, offset);
        #endif
    #else
       float shadow = SampleBasicShadow(shadowPos);
    #endif

    return shadow;
}

	vec3 DistortShadow(inout vec3 worldPos, float distortFactor) {
		worldPos.xy /= distortFactor;
		worldPos.z *= 0.2;
		return worldPos * 0.5 + 0.5;
	}
#endif

#if defined WATER_CAUSTICS && defined OVERWORLD && !defined GBUFFERS_WATER
	#ifdef PROJECTED_CAUSTICS
		uniform sampler2DShadow shadowtex1;
		uniform sampler2D shadowcolor0;
	#endif

float waterH(vec3 pos) {
	float noise = 0;
	vec2 wind = vec2(frametime) * 0.35 * WATER_SPEED;
	noise+= texture2D(noisetex,(pos.xz + wind - pos.y * 0.7) / 1024.0 * 1.1).r * 1.0;
	noise+= texture2D(noisetex,(pos.xz - wind - pos.y * 0.7) / 1024.0 * 1.5).r * 0.8;
	noise-= texture2D(noisetex,(pos.xz + wind + pos.y * 0.7) / 1024.0 * 2.5).r * 0.6;
	noise+= texture2D(noisetex,(pos.xz - wind - pos.y * 0.7) / 1024.0 * 5.0).r * 0.4;
	noise-= texture2D(noisetex,(pos.xz + wind + pos.y * 0.7) / 1024.0 * 8.0).r * 0.2;

	return noise;
	}

float getCausticWaves(vec3 pos) {
	float deltaPos = 0.1;
	float caustic_h0 = waterH(pos);
	float caustic_h1 = waterH(pos + vec3( deltaPos, 0.0,  0.0));
	float caustic_h2 = waterH(pos + vec3(-deltaPos, 0.0,  0.0));
	float caustic_h3 = waterH(pos + vec3( 0.0,      0.0,  deltaPos));
	float caustic_h4 = waterH(pos + vec3( 0.0,      0.0, -deltaPos));

	float caustic = max((1.0-abs(0.5-caustic_h0))*(1.0-(abs(caustic_h1-caustic_h2)+abs(caustic_h3-caustic_h4))),0.0);
		  caustic = max(pow(caustic,3.5),0.0)*2.0;
		  
	return caustic;
}
#endif

float GetFakeShadow(float skyLight) {
	float fakeShadow = 0.0;

	#ifndef END
		if (isEyeInWater == 0) skyLight = pow(skyLight, 30.0);
		fakeShadow = skyLight;
	#else
		#ifdef SHADOWS
			fakeShadow = 1.0;
		#else
			fakeShadow = 0.0;
		#endif
	#endif

	return fakeShadow;
}

void GetLighting(inout vec3 albedo, inout float shadow, inout vec3 lightAlbedo, vec3 viewPos, float lViewPos, vec3 worldPos,
                 vec2 lightmap, float smoothLighting, float NdotL, float quarterNdotU,
                 float parallaxShadow, float emissive, float subsurface, float leaves, float materialAO) {
	float fullShadow = 0.0;
	float fakeShadow = 0.0;
	float shadowMult = 1.0;
	float shadowTime = 1.0;

	#if defined WATER_CAUSTICS && defined OVERWORLD && !defined GBUFFERS_WATER && defined PROJECTED_CAUSTICS
		float water = 0.0;
	#endif

    #if defined OVERWORLD || defined END || defined SEVEN
		#ifdef SHADOWS
			if ((NdotL > 0.0 || subsurface > 0.001)) {
				float shadowLengthX = length(worldPos.xy);
				float shadowLengthZ = length(worldPos.yz);
				float shadowLength = shadowDistance - max(shadowLengthX, shadowLengthZ) - shadowDistance / 12.0;

				#if (defined OVERWORLD || defined SEVEN) && defined LIGHT_LEAK_FIX
					if (isEyeInWater == 0) shadowLength *= float(lightmap.y > 0.001);
				#endif

				if (shadowLength > 0.000001) {
					vec3 shadowPos = ToShadow(worldPos);
					float distb = sqrt(shadowPos.x * shadowPos.x + shadowPos.y * shadowPos.y);
					float distortFactor = distb * shadowMapBias + (1.0 - shadowMapBias);
					shadowPos = DistortShadow(shadowPos, distortFactor);

					#ifdef NORMAL_MAPPING
						float NdotLm = clamp(dot(normal, lightVec) * 1.01 - 0.01, 0.0, 1.0) * 0.99 + 0.01;
						NdotL = min(NdotL, NdotLm);
					#else
						float NdotLm = NdotL * 0.99 + 0.01;
					#endif

					float dotWorldPos = dot(worldPos.xyz, worldPos.xyz);
					
					float biasFactor = sqrt(1.0 - NdotLm * NdotLm) / NdotLm;
					float distortBias = distortFactor * shadowDistance / 256.0;
					distortBias *= 8.0 * distortBias;
					
					float bias = (distortBias * biasFactor + dotWorldPos * 0.000005 + 0.05) / shadowMapResolution;
					float offset = 1.0 / shadowMapResolution;

					if (subsurface > 0.001) {
						bias = 0.0002;
						offset = 0.002;
					}
					if (isEyeInWater == 1) offset *= 5.0;

					shadowPos.z -= bias;
					shadow = GetShadow(shadowPos, offset);

					#if defined WATER_CAUSTICS && defined OVERWORLD && !defined GBUFFERS_WATER && defined PROJECTED_CAUSTICS
						if (isEyeInWater == 0) {
							if (shadow < 0.999) {
								water = texture2D(shadowcolor0, shadowPos.st).r
									* shadow2D(shadowtex1, vec3(shadowPos.st, shadowPos.z)).x;
								#ifdef SHADOW_FILTER
									shadowPos.z -= bias * shadowMapResolution / 2048.0;
									for(int i = 0; i < 8; i++) {
										vec2 shadowOffset = 0.002 * shadowoffsets[i];
										water += texture2D(shadowcolor0, shadowOffset + shadowPos.st).r
											* shadow2D(shadowtex1, vec3(shadowOffset + shadowPos.st, shadowPos.z)).x;
									}
									water *= 0.1;
									water *= water;
								#endif
								water *= NdotL;
							}
						}
					#endif
				} else {
					//albedo.rgb *= 0.0;
				}
				float shadowLength2 = shadowLength;
				float shadowSmooth = 16.0;
				if (shadowLength2 < shadowSmooth) {
					float shadowLengthDecider = max(shadowLength2 / shadowSmooth, 0.0);
					float skyLightShadow = GetFakeShadow(lightmap.y);
					shadow = mix(skyLightShadow, shadow, shadowLengthDecider);
					subsurface *= mix(subsurface * 0.5, subsurface, shadowLengthDecider);
					fakeShadow = mix(1.0, fakeShadow, shadowLengthDecider);
					fakeShadow = 1.0 - fakeShadow;
					fakeShadow *= fakeShadow;
					fakeShadow = 1.0 - fakeShadow;
				}
			}
		#else
			shadow = GetFakeShadow(lightmap.y);
		#endif
		
		#if defined CLOUD_SHADOW && defined OVERWORLD
			float cloudSize = 0.000025;
			vec2 wind = vec2(frametime, 0.0) * CLOUD_SPEED * 6.0;
			float cloudShadow = texture2D(noisetex, cloudSize * (wind + (worldPos.xz + cameraPosition.xz))).r;
			cloudShadow += texture2D(noisetex, cloudSize * (vec2(1000.0) + wind + (worldPos.xz + cameraPosition.xz))).r;
			cloudShadow = clamp(cloudShadow, 0.0, 1.0);
			cloudShadow *= cloudShadow;
			cloudShadow *= cloudShadow;
			shadow *= cloudShadow;
		#endif

		#ifdef ADV_MAT
			#ifdef SELF_SHADOW
				shadow *= mix(1.0, parallaxShadow, NdotL);
			#endif
		#endif
		
		fullShadow = shadow * max(NdotL, subsurface * (1.0 - max(rainStrengthS, (1.0 - sunVisibility)) * 0.40));
		
		#if defined OVERWORLD && !defined TWO
			shadowMult = 1.0 * (1.0 - 0.9 * rainStrengthS);
			
			shadowTime = abs(sunVisibility - 0.5) * 2.0;
			shadowTime *= shadowTime;
			shadowMult *= shadowTime * shadowTime;
			
			#ifndef LIGHT_LEAK_FIX
				ambientCol *= pow(lightmap.y, 2.5);
			#else
				if (isEyeInWater == 1) ambientCol *= pow(lightmap.y, 2.5);
			#endif
			
			vec3 lightingCol = pow(lightCol, vec3(1.0 + sunVisibility));
			#ifdef SHADOWS
				lightingCol *= (1.0 + 0.5 * leaves);
			#else
				lightingCol *= (1.0 + 0.4 * leaves);
			#endif
			float shadowDecider = fullShadow * shadowMult;
			if (isEyeInWater == 1) shadowDecider *= pow(min(lightmap.y * 1.03, 1.0), 200.0);
			vec3 sceneLighting = mix(ambientCol * AMBIENT_GROUND, lightingCol * LIGHT_GROUND, shadowDecider);
			
			#ifdef LIGHT_LEAK_FIX
				if (isEyeInWater == 0) sceneLighting *= pow(lightmap.y, 2.5);
			#endif
		#endif

		#ifdef END
			vec3 ambientEnd = endCol * 0.07;
			vec3 lightEnd   = endCol * 0.17;
			float shadowDecider = fullShadow;
			vec3 sceneLighting = mix(ambientEnd, lightEnd, shadowDecider);
			sceneLighting *= END_I * (0.7 + 0.4 * vsBrightness);
		#endif

		#ifdef TWO
			#ifndef ABYSS
				vec3 sceneLighting = vec3(0.0003, 0.0004, 0.002) * 10.0;
			#else
				vec3 sceneLighting = pow(fogColor, vec3(0.2)) * 0.125;
			#endif
		#endif
		
		#if defined SEVEN && !defined SEVEN_2
			sceneLighting = vec3(0.005, 0.006, 0.018) * 133 * (0.3 * fullShadow + 0.025);
		#endif
		#ifdef SEVEN_2
			vec3 sceneLighting = vec3(0.005, 0.006, 0.018) * 33 * (1.0 * fullShadow + 0.025);
		#endif
		#if defined SEVEN || defined SEVEN_2
			sceneLighting *= lightmap.y * lightmap.y;
		#endif
		
		#ifdef SHADOWS
			if (subsurface > 0.001) {
				float VdotL = clamp(dot(normalize(viewPos.xyz), lightVec), 0.0, 1.0);
				sceneLighting *= 5.0 * (1.0 - fakeShadow) * shadowTime * fullShadow * (1.0 + leaves) * pow(VdotL, 10.0) + 1.0;
			}
		#endif
    #else
		#ifdef NETHER
			#if MC_VERSION <= 11600
			#else
				if (quarterNdotU < 0.5625) quarterNdotU = 0.5625 + (0.4 - quarterNdotU * 0.7111111111111111);
			#endif
		
			vec3 sceneLighting = netherCol * (1 - pow(length(fogColor / 3), 0.25)) * NETHER_I * (vsBrightness*0.5 + 0.5);
		#else
			vec3 sceneLighting = vec3(0.0);
		#endif
    #endif

	#ifdef DYNAMIC_SHADER_LIGHT
		float handLight = min(float(heldBlockLightValue2 + heldBlockLightValue), 15.0) / 15.0;

		if (heldItemId == 12001 || heldItemId2 == 12001) // Lava Bucket
			#if defined GBUFFERS_HAND && defined COMPBR
				handLight = 0.87, emissive = max(albedo.r * 2.0 - albedo.g - albedo.b, 0.0) * 0.5;
			#else
				handLight = 1.0;
			#endif
		if (heldItemId == 12002 || heldItemId2 == 12002) // Optifine Item Emissives
			handLight = min(handLight + 0.5, 1.0);

		float handLightFactor = 1.0 - min(DYNAMIC_LIGHT_DISTANCE * handLight, lViewPos) / (DYNAMIC_LIGHT_DISTANCE * handLight);
		#ifdef GBUFFERS_WATER
			if (mat > 0.05) handLight *= 0.9;
		#endif
		#ifdef GBUFFERS_HAND
			handLight = min(handLight, 0.95);
		#endif
		float finalHandLight = handLight * handLightFactor;
		lightmap.x = max(finalHandLight * 0.95, lightmap.x);
	#endif

	float newLightmap  = pow(lightmap.x, 10.0) * 5 + max((lightmap.x - 0.05) * 0.925, 0.0) * (vsBrightness*0.25 + 0.9);
	
	#ifdef BLOCKLIGHT_FLICKER
		float frametimeM = frametime * 0.5;
		float lightFlicker = min(((1 - clamp(sin(fract(frametimeM*2.7) + frametimeM*3.7) - 0.75, 0.0, 0.25) * BLOCKLIGHT_FLICKER_STRENGTH)
					* max(fract(frametimeM*1.4), (1 - BLOCKLIGHT_FLICKER_STRENGTH * 0.25))) / (1.0 - BLOCKLIGHT_FLICKER_STRENGTH * 0.2)
					, 0.8) * 1.25
					* 0.8 + 0.2 * clamp((cos(fract(frametimeM*0.47) * fract(frametimeM*1.17) + fract(frametimeM*2.17))) * 1.5, 1.0 - BLOCKLIGHT_FLICKER_STRENGTH * 0.25, 1.0);
		newLightmap *= lightFlicker;
	#endif

	#ifdef RANDOM_BLOCKLIGHT
		float CLr = texture2D(noisetex, 0.00006 * (worldPos.xz + cameraPosition.xz)).r;
		float CLg = texture2D(noisetex, 0.00009 * (worldPos.xz + cameraPosition.xz)).r;
		float CLb = texture2D(noisetex, 0.00014 * (worldPos.xz + cameraPosition.xz)).r;
		blocklightCol = vec3(CLr, CLg, CLb);
		blocklightCol *= blocklightCol * BLOCKLIGHT_I * 2.22;
	#endif

	#ifdef COLORED_LIGHT
		#ifdef GBUFFERS_TERRAIN
			if (lightVarying > 0.5) {
				if (lightVarying < 1.5) {
					lightAlbedo = albedo;
				}
				else if (lightVarying < 2.5) {
					#ifdef COMPBR
					lightAlbedo = float(eyeBrightness.x < 144) * emissive * albedo;
					#else
					lightAlbedo = float(eyeBrightness.x < 144) * albedo;
					#endif
				}
				else if (lightVarying < 3.5) {
					lightAlbedo = vec3(0.7, 0.5, 0.2);
				}
				else if (lightVarying < 4.5) { // Sea Lantern, Beacon, End Rod
					lightAlbedo = albedo * vec3(0.6, 0.85, 1.0);
				}
			}
			//if (lViewPos > 16.0) lightAlbedo = vec3(0.0);
		#endif

		vec3 blocklightComplex = texture2D(colortex9, texCoord).rgb;
		blocklightComplex *= 0.75 + 2.0 * blocklightComplex.b;
		
		//float colorDistance = 24.0;
		//colorDistance = max(colorDistance- lViewPos, 0.0) / colorDistance;
		//colorDistance = 0.7 * colorDistance;

		blocklightCol = mix(blocklightCol, blocklightComplex, 0.7);

		#ifdef DYNAMIC_SHADER_LIGHT
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
vec3 glowstoneColor     = vec3(0.9, 0.5, 0.2);
vec3 sealanternColor    = vec3(0.5, 0.57, 0.78);
vec3 shroomlightColor   = vec3(1.0, 0.3, 0.125);
vec3 jackolanternColor  = vec3(0.9, 0.5, 0.2);
vec3 beaconColor        = vec3(0.33, 0.51, 0.6);
vec3 endrodColor        = vec3(0.53, 0.5, 0.47);
vec3 redstonetorchColor = vec3(1.0, 0.0, 0.0);
vec3 lanternColor       = vec3(0.9, 0.5, 0.2);
vec3 soullanternColor   = vec3(0.0, 0.7, 1.0);
vec3 torchColor         = vec3(0.9, 0.5, 0.2);
vec3 soultorchColor     = vec3(0.0, 0.7, 1.0);
vec3 respawnanchorColor = vec3(0.3, 0.0, 1.0);
vec3 campfireColor      = vec3(0.94, 0.5, 0.2);
vec3 soulcampfireColor  = vec3(0.0, 0.7, 1.0);
vec3 lavabucketColor    = vec3(0.94, 0.5, 0.2);
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
vec3 heldLightAlbedo1 = vec3(0.0);
vec3 heldLightAlbedo2 = vec3(0.0);
if (heldItemId < 11012.5) {
    if (heldItemId < 11005.5) {
        if (heldItemId == 11001) // Glowstone
            heldLightAlbedo1 = glowstoneColor;
        else if (heldItemId == 11002) // Sea Lantern
            heldLightAlbedo1 = sealanternColor;
        else if (heldItemId == 11004) // Shroomlight
            heldLightAlbedo1 = shroomlightColor;
    } else {
        if (heldItemId == 11007) // Jack o'Lantern
            heldLightAlbedo1 = jackolanternColor;
        else if (heldItemId == 11008) // Beacon
            heldLightAlbedo1 = beaconColor;
        else if (heldItemId == 11009) // End Rod
            heldLightAlbedo1 = endrodColor;
        else if (heldItemId == 11012) // Redstone Torch
            heldLightAlbedo1 = redstonetorchColor;
    }
} else {
    if (heldItemId < 11022.5) {
        if (heldItemId == 11017) // Lantern
            heldLightAlbedo1 = lanternColor;
        else if (heldItemId == 11018) // Soul Lantern
            heldLightAlbedo1 = soullanternColor;
        else if (heldItemId == 11021) // Torch
            heldLightAlbedo1 = torchColor;
        else if (heldItemId == 11022) // Soul Torch
            heldLightAlbedo1 = soultorchColor;
    } else {
        if (heldItemId == 11023) // Crying Obsidian, Respawn Anchor
            heldLightAlbedo1 = respawnanchorColor;
        else if (heldItemId == 11024) // Campfire
            heldLightAlbedo1 = campfireColor;
        else if (heldItemId == 11025) // Soul Campfire
            heldLightAlbedo1 = soulcampfireColor;
        else if (heldItemId == 12001) // Lava Bucket
            heldLightAlbedo1 = lavabucketColor;
    }
}
if (heldItemId2 < 11012.5) {
    if (heldItemId2 < 11005.5) {
        if (heldItemId2 == 11001) // Glowstone
            heldLightAlbedo2 = glowstoneColor;
        else if (heldItemId2 == 11002) // Sea Lantern
            heldLightAlbedo2 = sealanternColor;
        else if (heldItemId2 == 11004) // Shroomlight
            heldLightAlbedo2 = shroomlightColor;
    } else {
        if (heldItemId2 == 11007) // Jack o'Lantern
            heldLightAlbedo2 = jackolanternColor;
        else if (heldItemId2 == 11008) // Beacon
            heldLightAlbedo2 = beaconColor;
        else if (heldItemId2 == 11009) // End Rod
            heldLightAlbedo2 = endrodColor;
        else if (heldItemId2 == 11012) // Redstone Torch
            heldLightAlbedo2 = redstonetorchColor;
    }
} else {
    if (heldItemId2 < 11022.5) {
        if (heldItemId2 == 11017) // Lantern
            heldLightAlbedo2 = lanternColor;
        else if (heldItemId2 == 11018) // Soul Lantern
            heldLightAlbedo2 = soullanternColor;
        else if (heldItemId2 == 11021) // Torch
            heldLightAlbedo2 = torchColor;
        else if (heldItemId2 == 11022) // Soul Torch
            heldLightAlbedo2 = soultorchColor;
    } else {
        if (heldItemId2 == 11023) // Crying Obsidian, Respawn Anchor
            heldLightAlbedo2 = respawnanchorColor;
        else if (heldItemId2 == 11024) // Campfire
            heldLightAlbedo2 = campfireColor;
        else if (heldItemId2 == 11025) // Soul Campfire
            heldLightAlbedo2 = soulcampfireColor;
        else if (heldItemId2 == 12001) // Lava Bucket
            heldLightAlbedo2 = lavabucketColor;
    }
}
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
vec3 heldLightAlbedo = heldLightAlbedo1 + heldLightAlbedo2;

if (dot(heldLightAlbedo, heldLightAlbedo) > 0.001) {
    heldLightAlbedo /= length(heldLightAlbedo);
    heldLightAlbedo *= BLOCKLIGHT_I * 0.4;
    float mixFactor = finalHandLight * finalHandLight;
    blocklightCol = mix(blocklightCol, heldLightAlbedo, max(mixFactor, 0.0));
}
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
		#endif
	#endif

    vec3 blockLighting = blocklightCol * newLightmap * newLightmap;

	#ifndef MIN_LIGHT_EVERYWHERE
		float minLighting = 0.000000000001 + (MIN_LIGHT * 0.0035 * (vsBrightness*0.08 + 0.01)) * (1.0 - eBS);
	#else
		float minLighting = 0.000000000001 + (MIN_LIGHT * 0.0035 * (vsBrightness*0.08 + 0.01));
	#endif
	#ifdef GBUFFERS_WATER
		if (mat > 0.05) minLighting += MIN_LIGHT * 0.0035 * (vsBrightness*0.08 + 0.01);
	#endif
	
	float shade = pow(quarterNdotU, SHADING_STRENGTH);

	vec3 emissiveLighting = albedo.rgb * emissive * 20.0 / shade;

    float nightVisionLighting = nightVision * 0.25;

	smoothLighting = clamp(smoothLighting, 0.0, 1.0);
	smoothLighting = pow(smoothLighting, 
						(2.0 - min(length(fullShadow * shadowMult), 1.5)) * VAO_STRENGTH
						);

	if (materialAO < 1.0) {
		smoothLighting *= pow(materialAO, max(1.0 - shadowTime * length(shadow) * NdotL - lmCoord.x, 0.0));
	}

    albedo *= sceneLighting + blockLighting + emissiveLighting + nightVisionLighting + minLighting;
	albedo *= shade;
	if (smoothLighting > 0.01) albedo *= smoothLighting;

	#if defined WATER_CAUSTICS && defined OVERWORLD && !defined GBUFFERS_WATER
		#ifdef PROJECTED_CAUSTICS
		if (water > 0.0 || isEyeInWater == 1) {
		#else
		if (isEyeInWater == 1) {
		#endif
			vec3 albedoCaustic = albedo;

			float skyLightMap = lightmap.y * lightmap.y * (3.0 - 2.0 * lightmap.y);
			
			float causticfactor = 1.0 - lightmap.x * 0.8;

			vec3 causticpos = worldPos.xyz + cameraPosition.xyz;
			float caustic = getCausticWaves(causticpos * 0.75);
			vec3 causticcol = underwaterColor.rgb / UNDERWATER_I;
			
			#ifdef PROJECTED_CAUSTICS
				if (isEyeInWater == 0) {
					//causticfactor *= (1.0 - skyLightMap * skyLightMap);
					causticfactor *= 1.0 - pow2(pow2((1.0 - skyLightMap)));
					causticfactor *= 10.0;

					causticcol *= causticcol;
					causticcol *= causticcol;
					albedoCaustic = albedo.rgb * mix(underwaterColor.rgb * 20.0, causticcol * 1000.0, sunVisibility);
					causticcol *= 120.0;
				} else {
			#endif
					causticfactor *= (1.0 - skyLightMap * skyLightMap) * shadow * NdotL * (1.0 - rainStrengthS);
					causticfactor *= 0.1 + 0.9 * (1.0 - pow2(1.0 - skyLightMap));

					albedoCaustic = (albedo.rgb + albedo.rgb * underwaterColor.rgb * 16.0) * 0.225;
					causticcol = sqrt(causticcol) * 30.0;
			#ifdef PROJECTED_CAUSTICS
				}
			#endif

			vec3 lightcaustic = caustic * causticfactor * causticcol * UNDERWATER_I;
			albedoCaustic *= 1.0 + lightcaustic;

			#ifdef PROJECTED_CAUSTICS
				if (isEyeInWater == 0) albedo = mix(albedo, albedoCaustic, max(water - rainStrengthS, 0.0));
				else albedo = albedoCaustic;
			#else
				albedo = albedoCaustic;
			#endif
		}
	#endif

	#if defined GBUFFERS_HAND && defined HAND_BLOOM_REDUCTION
		float albedoStrength = (albedo.r + albedo.g + albedo.b) / 10.0;
		if (albedoStrength > 1.0) albedo.rgb = albedo.rgb * max(2.0 - pow(albedoStrength, 1.0), 0.34);
	#endif

	//if (water > 0.0) albedo = vec3(1.0, 0.0, 1.0);
}
vec4 SimpleReflection(vec3 viewPos, vec3 normal, float dither, float fresnelRT) {
	vec4 reflection = vec4(0.0);

    vec4 pos = Raytrace(depthtex1, viewPos, normal, dither, fresnelRT);

	float border = clamp(1.0 - pow(cdist(pos.st), 50.0), 0.0, 1.0);
	
	if (pos.z < 1.0 - 1e-5) {
		reflection.a = float(0.999999 > texture2D(depthtex1, pos.st).r);
		if (reflection.a > 0.001) reflection.rgb = texture2D(gaux2, pos.st).rgb;
		
		reflection.a *= border;
	}

	reflection.rgb = pow(reflection.rgb * 2.0, vec3(8.0));

	return reflection;
}

#ifdef OVERWORLD
	#ifdef AURORA
vec3 auroraUColSqrt = vec3(AURORA_UP_R, AURORA_UP_G, AURORA_UP_B) * AURORA_UP_I / 255.0;
vec3 auroraUCol = auroraUColSqrt * auroraUColSqrt;

vec3 auroraDColSqrt = vec3(AURORA_DOWN_R, AURORA_DOWN_G, AURORA_DOWN_B) * AURORA_DOWN_I / 255.0;
vec3 auroraDCol = auroraDColSqrt * auroraDColSqrt;
	#endif

	#if defined CLOUDS || defined AURORA
#if !defined END && !defined SEVEN && !defined NETHER

	float CloudNoise(vec2 coord, vec2 wind) {
		float noise = texture2D(noisetex, coord*0.125    + wind * 0.25).x * 7.0;
			  noise+= texture2D(noisetex, coord*0.0625   + wind * 0.15).x * 12.0;
			  noise+= texture2D(noisetex, coord*0.03125  + wind * 0.05).x * 12.0;
			  noise+= texture2D(noisetex, coord*0.015625 + wind * 0.05).x * 24.0;
		return noise*0.34;
	}

	float CloudCoverage(float noise, float coverage, float NdotU, float cosS) {
		float noiseCoverageCosS = abs(cosS);
		noiseCoverageCosS *= noiseCoverageCosS;
		noiseCoverageCosS *= noiseCoverageCosS;
		float NdotUmult = 0.365;
		#ifdef AURORA
			float auroraMult = max(1.0 - sunVisibility - rainStrengthS, 0.0);
			#ifdef AURORA_BIOME_CHECK
				auroraMult *= isSnowy;
			#endif
			#ifdef AURORA_FULL_MOON_CHECK
				auroraMult *= float(moonPhase == 0);
			#endif
			NdotUmult *= 1.0 + 2.5 * auroraMult;
		#endif
		float noiseCoverage = coverage * coverage + CLOUD_AMOUNT
								* (1.0 + noiseCoverageCosS * 0.175) 
								* (1.0 + NdotU * NdotUmult * (1.0-rainStrengthS*3.0))
								- 2.5;

		return max(noise - noiseCoverage, 0.0);
	}

	vec4 DrawCloud(vec3 viewPos, float dither, vec3 lightCol, vec3 ambientCol, float NdotU, int sampleCount) {
		float cosS = dot(normalize(viewPos), sunVec);
		
		#if AA > 1
			dither = fract(16.0 * frameTimeCounter + dither);
		#endif

		float timeBrightnessS = sqrt1(timeBrightness);
		
		float cloud = 0.0;
		float cloudGradient = 0.0;
		float gradientMix = dither * 0.1667;
		float colorMultiplier = CLOUD_BRIGHTNESS * (0.23 + 0.07 * timeBrightnessS);
		float noiseMultiplier = CLOUD_THICKNESS * 0.125;
		float scattering = 0.5 * pow(cosS * 0.5 * (2.0 * sunVisibility - 1.0) + 0.5, 6.0);

		float cloudHeightFactor = max(1.07 - 0.001 * eyeAltitude, 0.0);
		cloudHeightFactor *= cloudHeightFactor;
		float cloudHeight = CLOUD_HEIGHT * cloudHeightFactor * 0.5;

		#if !defined GBUFFERS_WATER && !defined DEFERRED
			float cloudframetime = frametime;
		#else
			float cloudframetime = cloudtime;
		#endif
		float cloudSpeedFactor = 0.003;
		vec2 wind = vec2(cloudframetime * CLOUD_SPEED * cloudSpeedFactor, 0.0);
		#ifdef SEVEN
			wind *= 8;
		#endif

		vec3 cloudcolor = vec3(0.0);

		float stretchFactor = 2.5;
		float coordFactor = 0.009375;

		if (NdotU > 0.025) {
			vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos, 1.0)).xyz);
			for(int i = 0; i < sampleCount; i++) {
				if (cloud > 0.99) break;
				vec2 planeCoord = wpos.xz * ((cloudHeight + (i + dither) * stretchFactor * 6.0 / sampleCount) / wpos.y) * 0.0085;
				vec2 coord = cameraPosition.xz * 0.00025 + planeCoord;
				
				float ang1 = (i + frametime * 0.025) * 2.391;
				float ang2 = ang1 + 2.391;
				coord += mix(vec2(cos(ang1), sin(ang1)), vec2(cos(ang2), sin(ang2)), dither * 0.25 + 0.75) * coordFactor;
				
				float coverage = float(i - 3.0 + dither) * 0.725;
				
				float noise = CloudNoise(coord, wind);
					  noise = CloudCoverage(noise, coverage, NdotU, cosS) * noiseMultiplier;
					  noise = noise / pow(pow(noise, 2.5) + 1.0, 0.4);
				
				cloudGradient = mix(cloudGradient,
									mix(gradientMix * gradientMix, 1.0 - noise, 0.25),
									noise * (1.0 - cloud));
				
				cloud += max(noise - cloud * 0.95, 0.0);
				gradientMix += 0.2 * (6.0 / sampleCount);
			}

			float meFactorP = min((1.0 - min(moonBrightness, 0.6) / 0.6) * 0.115, 0.075);
			vec3 meColor = vec3(0.0);
			if (cosS > 0.0) {
				float meNdotU = 1.0 - NdotU;
				float meFactor = meFactorP * meNdotU * meNdotU * 12.0 * (1.0 - rainStrengthS);
				meColor = mix(lightMorning, lightEvening, mefade);
				meColor *= meColor * meColor;
				meColor *= meFactor * meFactor * cosS;
			}

			float sunVisibility2 = sunVisibility * sunVisibility;
			float sunVisibility4 = sunVisibility2 * sunVisibility2;

			sunVisibility4 = pow(sunVisibility4, 1.0 - meFactorP * 6.0);

			vec3 cloudNightColor = ambientCol * 10.0;
			vec3 cloudDayColor = pow(lightCol, vec3(1.5 + rainStrengthS)) * 1.5;

			vec3 cloudUpColor = mix(cloudNightColor, cloudDayColor, sunVisibility4);
			cloudUpColor *= 1.0 + scattering * (1.0 + pow2(rainStrengthS) * 4.0);
			cloudUpColor += max(meColor, vec3(0.0));

			vec3 cloudDownColor = skyColCustom * 0.175 * sunVisibility4;
			cloudcolor = mix(cloudDownColor, cloudUpColor, cloudGradient);

			cloud *= pow2(pow2(1.0 - exp(- (10.0 - 8.2 * rainStrengthS) * NdotU)));
		}

		return vec4(cloudcolor * colorMultiplier, cloud * CLOUD_OPACITY);
	}

	#ifdef AURORA

		float AuroraNoise(vec2 coord, vec2 wind) {
			float noise = texture2D(noisetex, coord * 0.175   + wind * 0.25).x;
				  noise+= texture2D(noisetex, coord * 0.04375 + wind * 0.15).x * 5.0;

			return noise;
		}

		vec3 DrawAurora(vec3 viewPos, float dither, int sampleCount, float NdotU) {
			#if AA > 1
				dither = fract(16.0 * frameTimeCounter + dither);
			#endif
			
			float gradientMix = dither / sampleCount;
			float visibility = (1.0 - sunVisibility) * (1.0 - rainStrengthS);
			visibility *= visibility;

			#ifdef AURORA_BIOME_CHECK
				visibility *= isSnowy;
			#endif
			#ifdef AURORA_FULL_MOON_CHECK
				visibility *= float(moonPhase == 0);
			#endif

			#if !defined GBUFFERS_WATER && !defined DEFERRED
				float cloudframetime = frametime;
			#else
				float cloudframetime = cloudtime;
			#endif

			vec2 wind = vec2(cloudframetime * 0.00005);

			vec3 aurora = vec3(0.0);

			float NdotUM = min(1.08 - NdotU, 1.0);
			NdotUM *= NdotUM;
			NdotUM = 1.0 - NdotUM * NdotUM;		

			if (NdotU > 0.0 && visibility > 0.0) {
				vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos, 1.0)).xyz);
				for(int i = 0; i < sampleCount; i++) {
					vec2 planeCoord = wpos.xz * ((8.0 * AURORA_HEIGHT + (i + dither) * 7.0 / sampleCount) / wpos.y) * 0.004;
					vec2 coord = cameraPosition.xz * 0.00001 + planeCoord;

					float noise = AuroraNoise(coord, wind);
						noise = max(1.0 - 1.5 / (1.0 - NdotU * 0.8) * abs(noise - 3.0), 0.0);

					if (noise > 0.0) {
						noise *= texture2D(noisetex, coord * 0.25 + wind * 0.25).x;
						noise *= 0.5 * texture2D(noisetex, coord + wind * 16.0).x + 0.75;
						noise = noise * noise * 3.0 / sampleCount;
						noise *= NdotUM;

						vec3 auroracolor = mix(
										auroraDCol,
										auroraUCol,
										pow(gradientMix, 0.4));

						aurora += noise * auroracolor * exp2(-6.0 * i / sampleCount);
					}
					gradientMix += 1.0 / sampleCount;
				}
			}

			aurora = aurora * visibility * 1.5;

			return aurora;
		}
	#endif
#endif

#ifdef SEVEN

	float GetNoise(vec2 pos) {
		return fract(sin(dot(pos, vec2(12.9898, 4.1414))) * 43758.54953);
	}

	vec3 DrawStars(inout vec3 color, vec3 viewPos, float NdotU) {
		vec3 wpos = vec3(gbufferModelViewInverse * vec4(viewPos, 1.0));
		vec3 planeCoord = 0.75 * wpos / (wpos.y + length(wpos.xz));
		vec2 wind = 0.75 * vec2(frametime, 0.0);
		#ifdef SEVEN
			wind = vec2(0.0);
		#endif
		vec2 coord = planeCoord.xz * 0.5 + wind * 0.00125;
		coord = floor(coord*1024.0) / 1024.0;
		
		float multiplier = 5.0 * (1.0 - rainStrengthS) * (1 - (sunVisibility*0.9 + pow(timeBrightness, 0.05)*0.1)) * pow(NdotU, 2.0);
		
		#ifdef SEVEN
			multiplier = sqrt2(NdotU) * 5.0 * (1.0 - rainStrengthS);	
		#endif
		
		float star = 1.0;
		if (NdotU > 0.0) {
			star *= GetNoise(coord.xy);
			star *= GetNoise(coord.xy+0.1);
			star *= GetNoise(coord.xy+0.23);
		}
		star = max(star - 0.825, 0.0) * multiplier;
		
		vec3 stars = star * lightNight * lightNight * 160;

		return vec3(stars);
	}
#endif

#if defined END && defined ENDER_NEBULA

	float CloudCoverageEnd(float noise, float cosT, float coverage) {
		float noiseMix = mix(noise, 21.0, 0.33 * rainStrengthS);
		float noiseFade = clamp(sqrt(cosT * 10.0), 0.0, 1.0);
		float noiseCoverage = ((coverage) + CLOUD_AMOUNT - 2);
		float multiplier = 1.0 - 0.5 * rainStrengthS;

		return max(noiseMix * noiseFade - noiseCoverage, 0.0) * multiplier;
	}

	float CloudNoiseEnd(vec2 coord, vec2 wind) {
		float noise = texture2D(noisetex, coord          + wind * 0.55).x;
			  noise+= texture2D(noisetex, coord*0.5      + wind * 0.45).x * -2.0;
			  noise+= texture2D(noisetex, coord*0.25     + wind * 0.35).x * 2.0;
			  noise+= texture2D(noisetex, coord*0.125    + wind * 0.25).x * -5.0;
			  noise+= texture2D(noisetex, coord*0.0625   + wind * 0.15).x * 20.0;
			  noise+= texture2D(noisetex, coord*0.03125  + wind * 0.05).x * 20.0;
			  noise+= texture2D(noisetex, coord*0.015625 + wind * 0.05).x * -15.0;
		return noise;
	}

	float GetNebulaStarNoise(vec2 pos) {
		return fract(sin(dot(pos, vec2(12.9898, 4.1414))) * 43758.54953);
	}

	float NebulaNoise(vec2 coord, vec2 wind) {
		float noise = texture2D(noisetex, coord * 0.175   + wind * 0.25).x;
			  noise+= texture2D(noisetex, coord * 0.04375 + wind * 0.15).x * 5.0;

		return noise;
	}

	vec3 DrawEnderNebula(vec3 viewPos, float dither, vec3 lightCol, bool stars) {
		float NdotU = dot(normalize(viewPos), upVec);
		float cosS = dot(normalize(viewPos), sunVec);
		cosS *= cosS;
		cosS *= cosS;
		cosS *= cosS;

		#if AA > 1
			dither = fract(16.0 * frameTimeCounter + dither);
		#endif

		int sampleCount = 20;
		
		float gradientMix = dither / sampleCount;

		#if !defined GBUFFERS_WATER && !defined DEFERRED
			float cloudframetime = frametime;
		#else
			float cloudframetime = cloudtime;
		#endif

		vec2 wind = vec2(cloudframetime * 0.000035);

		vec3 nebula = vec3(0.0);

		float NdotUM = abs(NdotU);
		NdotUM = 1.0 - NdotUM;
		NdotUM = pow(NdotUM, (2.0 - NdotUM) * (NEBULA_DISTRIBUTION - 0.8)) * 0.85;
		NdotUM = max(NdotUM, 0.0);
		float compression = pow(NdotUM, NEBULA_COMPRESSION);
		dither *= NEBULA_SMOOTHING;

		vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos * 1000.0, 1.0)).xyz);
		for(int i = 0; i < sampleCount; i++) {
			vec2 planeCoord = wpos.xz * (1.0 + (i + dither) * compression * 6.0 / sampleCount) * NEBULA_SIZE;
			vec2 coord = planeCoord + cameraPosition.xz * 0.00004;

			float noise = NebulaNoise(coord, wind);
					noise = max(0.75 - 1.0 / abs(noise - (4.0 + NdotUM * 2.0)), 0.0) * 3.0;

			if (noise > 0.0) {
				noise *= texture2D(noisetex, abs(coord * 0.25) + wind * 4.0).x;
				float fireNoise = texture2D(noisetex, abs(coord * 0.2) + wind * 8.0).x;
				noise *= 0.5 * fireNoise + 0.75;
				noise = noise * noise * 3.0 / sampleCount;
				noise *= NdotUM;

				vec3 nebulaColor = 12.0 * lightCol * NEBULA_PURPLE_BRIGHTNESS;
				nebulaColor += vec3(1.0, 0.25, 0.0) * NEBULA_ORANGE_BRIGHTNESS * 4.0 * pow(fireNoise, 5.0);
				nebulaColor *= gradientMix;

				nebula += noise * nebulaColor * exp2(-6.0 * i / sampleCount);
			}
			gradientMix += 1.0 / sampleCount;
		}

		if (stars) {
			vec3 starCoord = 0.75 * wpos / (abs(wpos.y) + length(wpos.xz));
			vec2 starCoord2 = starCoord.xz * 0.7;
			if (NdotU < 0.0) starCoord2 += 100.0;
			float starFactor = 1024.0;
			starCoord2 = floor(starCoord2 * starFactor) / starFactor;
			float star = 1.0;
			star *= GetNebulaStarNoise(starCoord2.xy);
			star *= GetNebulaStarNoise(starCoord2.xy+0.1);
			star *= GetNebulaStarNoise(starCoord2.xy+0.23);
			star = max(star - 0.825, 0.0);
			nebula += star * lightCol * 80.0 * (1.0 - NdotUM) * NEBULA_STAR_BRIGHTNESS;
		}

		return nebula * 2.0;
	}
#endif

#if defined NETHER && defined NETHER_SMOKE
		float SmokeNoise(vec2 coord, vec2 wind) {
			float noise = texture2D(noisetex, coord * 0.175   + wind * 0.25).x;
				  noise+= texture2D(noisetex, coord * 0.04375 + wind * 0.15).x * 5.0;

			return noise;
		}

		vec3 DrawNetherSmoke(vec3 viewPos, float dither, vec3 lightCol) {
			float NdotU = dot(normalize(viewPos), upVec);
			float cosS = dot(normalize(viewPos), sunVec);
			cosS *= cosS;
			cosS *= cosS;
			cosS *= cosS;

			#if AA > 1
				dither = fract(16.0 * frameTimeCounter + dither);
			#endif

			int sampleCount = 20;
			
			float gradientMix = dither / sampleCount;

			#if !defined GBUFFERS_WATER && !defined DEFERRED
				float cloudframetime = frametime;
			#else
				float cloudframetime = cloudtime;
			#endif

			vec2 wind = vec2(cloudframetime * 0.00005);

			vec3 smoke = vec3(0.0);

			float NdotUM = abs(NdotU);
			NdotUM = 1.0 - NdotUM;

			vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos, 1.0)).xyz);
			for(int i = 0; i < sampleCount; i++) {
				vec2 planeCoord = wpos.xz * (1.0 + (i + dither) * 6.0 / sampleCount) * 0.03;
				vec2 coord = planeCoord + cameraPosition.xz * 0.0017;

				float noise = SmokeNoise(coord, wind);
					  noise = max(0.75 - 1.0 / abs(noise - 6.0), 0.0) * 3.0;

				if (noise > 0.0) {
					noise *= texture2D(noisetex, abs(coord * 0.25) + wind * 8.0).x;
					float heightNoise = wpos.y;
					float fireNoise = texture2D(noisetex, abs(coord * 0.2) + (heightNoise + cameraPosition.y * 0.01) * 0.01 + wind * -4.0).x;
					noise = noise * noise * 3.0 / sampleCount;
					noise *= NdotUM;

					vec3 smokeColor = pow(lightCol, vec3(0.6, 0.5, 0.6)) * 12.0 * pow(fireNoise, 5.0);
					smokeColor *= gradientMix;

					smoke += noise * smokeColor * exp2(-6.0 * i / sampleCount);
				}
				gradientMix += 1.0 / sampleCount;
			}

			return smoke * 2.0;
		}
#endif
	#endif
vec3 GetSkyColor(vec3 lightCol, float NdotU, vec3 nViewPos, bool isReflection) {
    float timeBrightnessInv = 1.0 - timeBrightness;
    float timeBrightnessInv2 = timeBrightnessInv * timeBrightnessInv;
    float timeBrightnessInv4 = timeBrightnessInv2 * timeBrightnessInv2;
    float timeBrightnessInv8 = timeBrightnessInv4 * timeBrightnessInv4;

    float NdotSp = clamp(dot(nViewPos, sunVec) * 0.5 + 0.5, 0.001, 1.0);
    float NdotS = NdotSp * NdotSp;
    NdotS *= NdotS;

    float absNdotU = abs(NdotU);

    vec3 skyColor2 = skyColor * skyColor;
    vec3 sky = mix(skyColor * 0.6, skyColor2, absNdotU) * (0.5 + 0.5 * sunVisibility);

    #ifdef ONESEVEN
        sky = vec3(0.812, 0.741, 0.674) * 0.5;
    #endif

    float horizon = 1.0 - max(NdotU + 0.1, 0.0) * (1.0 - 0.25 * NdotS * sunVisibility);
    horizon = min(horizon, 0.9);
    horizon *= horizon;
    
    float lightmix = NdotS * max(1.0 - absNdotU * 2.0, 0.0) * 0.5 + horizon + 0.05;
    lightmix *= sunVisibility * (1.0 - rainStrengthS) * timeBrightnessInv8;

    sky *= 2.0 - 0.5 * timeBrightnessInv4;
    sky *= mix(SKY_NOON, SKY_DAY, timeBrightnessInv4);
    
    float mult = 0.1 * (1.0 + rainStrengthS) + horizon * (0.3 + 0.1 * sunVisibility);
	
	float meFactorP = min((1.0 - min(moonBrightness, 0.6) / 0.6) * 0.115, 0.075);
    float meNdotU = 1.0 - absNdotU;
    float meFactor = meFactorP * meNdotU * meNdotU * 15.0 * (1.0 - rainStrengthS);
    vec3 meColor = mix(lightMorning, lightEvening, mefade);
    meColor *= meColor * meColor;
    meColor *= meFactor * meFactor * NdotS;

    vec3 finalSky = mix(sky * (1.0 - lightmix), lightCol * sqrt(lightCol), lightmix);
    
    vec3 nightSky = ambientNight * ambientNight * (3.5 + 4.5 * max(NdotU, 0.0));
    nightSky *= mix(SKY_NIGHT, 1.0, sunVisibility);
    finalSky += nightSky;

    finalSky *= max(1.0 - length(meColor) * 0.5, 0.0);
    finalSky += meColor * 0.8;
    
	if (isReflection) {
        float invNdotU = max(-NdotU, 0.0);
        float groundFactor = 0.5 * (11.0 * rainStrengthS + 1.0) * (-5.0 * sunVisibility + 6.0);
        float ground = exp(-groundFactor / (invNdotU * 6.0));
        ground = smoothstep(0.0, 1.0, ground);
        mult *= (1.0 - ground);
    }

    vec3 weatherSky = weatherCol * weatherCol;
    weatherSky *= GetLuminance(ambientCol / (weatherSky)) * 1.4;
    weatherSky *= mix(SKY_RAIN_NIGHT, SKY_RAIN_DAY, sunVisibility);
    weatherSky = max(weatherSky, skyColor2 * 0.75);
    finalSky = mix(finalSky, weatherSky, rainStrengthS) * mult;

    return pow(finalSky, vec3(1.125));
}

/*
vec3 GetTestSkyColor(vec3 lightCol, float NdotU, vec3 nViewPos, bool isReflection) {
    float timeBrightnessInv = 1.0 - timeBrightness;
    float timeBrightnessInv2 = timeBrightnessInv * timeBrightnessInv;
    float timeBrightnessInv4 = timeBrightnessInv2 * timeBrightnessInv2;
    float SdotU = dot( sunVec,upVec);
    float SdotUabs = abs(SdotU);
    float invSdotUabs = 1.0 - SdotUabs;
    float invSdotUabs2 = invSdotUabs * invSdotUabs;
    float invSdotUabs4 = invSdotUabs2 * invSdotUabs2;
    float invSdotUabs8 = invSdotUabs4 * invSdotUabs4;
    float invSdotUabsF = smoothstep(0.0, 1.0, invSdotUabs2);
    float invSdotUabsFN = SdotU > 0.0 ? 1.0 : invSdotUabsF;
    float NdotUabs = abs(NdotU);
    float invNdotUabs = 1.0 - NdotUabs;
    float invNdotUabs2 = invNdotUabs * invNdotUabs;
    float invNdotUabs4 = invNdotUabs2 * invNdotUabs2;
    float invNdotUabs8 = invNdotUabs4 * invNdotUabs4;
    float invNdotUabs16 = invNdotUabs8 * invNdotUabs8;
    float invNdotUabsF = smoothstep(0.0, 1.0, invNdotUabs4);
    float NdotS = dot(nViewPos, sunVec);
    float NdotSM = (1.0 + NdotS) * 0.5;
    vec3 sqrtLight = sqrt(lightCol);
    vec3 lightSunset = lightEvening * lightEvening;
         lightSunset *= (1.0 + sunVisibility) * NdotSM * NdotSM * invSdotUabsFN * (timeBrightnessInv4);
    vec3 skyNight = ambientNight * ambientNight * 5.0 + 0.2 * skyColCustom * invSdotUabsFN;

    vec3 topSky = skyColor * skyColor + skyNight;
    topSky *= 0.5 + 2.0 * invNdotUabs2;

    vec3 middleSky = mix(lightCol, lightSunset, length(lightSunset) * 0.8) * 3.0 + skyNight;

    vec3 downSky = skyColor * (1.25 + 1.0 * invNdotUabs2) * lightCol * 1.5 + skyNight * 2.0;

    float NdotUM = 1.0 - invNdotUabs8;
    NdotUM = NdotUM * (1.0 - 2.0 * float(NdotU < 0.0));
    NdotUM = (NdotUM + 1.0) * 0.5;
    vec3 topDownSky = mix(downSky, topSky, NdotUM);

    vec3 finalSky = mix(topDownSky, middleSky, invNdotUabs8 * 0.4);
    

    return finalSky * 0.1;
    //return vec3(1.0, 0.0, 1.0);
}
*/
#endif

#if defined END && defined ENDER_NEBULA
vec3 lightMorning    = vec3(LIGHT_MR, LIGHT_MG, LIGHT_MB) * LIGHT_MI / 255.0;
vec3 lightDay        = vec3(LIGHT_DR, LIGHT_DG, LIGHT_DB) * LIGHT_DI / 255.0;
vec3 lightEvening    = vec3(LIGHT_ER, LIGHT_EG, LIGHT_EB) * LIGHT_EI / 255.0;
#ifndef ONESEVEN
vec3 lightNight      = vec3(LIGHT_NR, LIGHT_NG, LIGHT_NB) * LIGHT_NI * (vsBrightness*0.125 + 0.80) * 0.4 / 255.0;
#else
vec3 lightNight      = (vec3(LIGHT_NR, LIGHT_NG, LIGHT_NB) * LIGHT_NI * 0.195 / 255.0) + vec3(0.37, 0.31, 0.25) * 0.35 ;
#endif

vec3 ambientMorning  = vec3(AMBIENT_MR, AMBIENT_MG, AMBIENT_MB) * AMBIENT_MI * 1.1 / 255.0;
vec3 ambientDay      = vec3(AMBIENT_DR, AMBIENT_DG, AMBIENT_DB) * AMBIENT_DI * 1.1 / 255.0;
vec3 ambientEvening  = vec3(AMBIENT_ER, AMBIENT_EG, AMBIENT_EB) * AMBIENT_EI * 1.1 / 255.0;
vec3 ambientNight    = vec3(AMBIENT_NR, AMBIENT_NG, AMBIENT_NB) * AMBIENT_NI * (vsBrightness*0.20 + 0.70) * 0.495 / 255.0;

vec3 weatherCol = vec3(WEATHER_RR, WEATHER_RG, WEATHER_RB) * WEATHER_RI / 255.0;
vec3 weatherIntensity = vec3(WEATHER_RI);

float mefade = 1.0 - clamp(abs(timeAngle - 0.5) * 8.0 - 1.5, 0.0, 1.0);
float dfade = 1.0 - timeBrightness;

vec3 CalcLightColor(vec3 morning, vec3 day, vec3 afternoon, vec3 night, vec3 weatherCol) {
	vec3 me = mix(morning, afternoon, mefade);
	float dfadeModified = dfade * dfade;
	vec3 dayAll = mix(me, day, 1.0 - dfadeModified * dfadeModified);
	vec3 c = mix(night, dayAll, sunVisibility);
	c = mix(c, dot(c, vec3(0.299, 0.587, 0.114)) * weatherCol, rainStrengthS*0.6);
	return c * c;
}

vec3 lightCol   = CalcLightColor(lightMorning,   lightDay,   lightEvening,   lightNight,
								 weatherCol * (vsBrightness*0.1 + 0.9));
vec3 ambientCol = CalcLightColor(ambientMorning, ambientDay, ambientEvening, ambientNight,
								 weatherCol * (vsBrightness*0.1 + 0.9));
#if !defined END && !defined SEVEN && !defined NETHER

	float CloudNoise(vec2 coord, vec2 wind) {
		float noise = texture2D(noisetex, coord*0.125    + wind * 0.25).x * 7.0;
			  noise+= texture2D(noisetex, coord*0.0625   + wind * 0.15).x * 12.0;
			  noise+= texture2D(noisetex, coord*0.03125  + wind * 0.05).x * 12.0;
			  noise+= texture2D(noisetex, coord*0.015625 + wind * 0.05).x * 24.0;
		return noise*0.34;
	}

	float CloudCoverage(float noise, float coverage, float NdotU, float cosS) {
		float noiseCoverageCosS = abs(cosS);
		noiseCoverageCosS *= noiseCoverageCosS;
		noiseCoverageCosS *= noiseCoverageCosS;
		float NdotUmult = 0.365;
		#ifdef AURORA
			float auroraMult = max(1.0 - sunVisibility - rainStrengthS, 0.0);
			#ifdef AURORA_BIOME_CHECK
				auroraMult *= isSnowy;
			#endif
			#ifdef AURORA_FULL_MOON_CHECK
				auroraMult *= float(moonPhase == 0);
			#endif
			NdotUmult *= 1.0 + 2.5 * auroraMult;
		#endif
		float noiseCoverage = coverage * coverage + CLOUD_AMOUNT
								* (1.0 + noiseCoverageCosS * 0.175) 
								* (1.0 + NdotU * NdotUmult * (1.0-rainStrengthS*3.0))
								- 2.5;

		return max(noise - noiseCoverage, 0.0);
	}

	vec4 DrawCloud(vec3 viewPos, float dither, vec3 lightCol, vec3 ambientCol, float NdotU, int sampleCount) {
		float cosS = dot(normalize(viewPos), sunVec);
		
		#if AA > 1
			dither = fract(16.0 * frameTimeCounter + dither);
		#endif

		float timeBrightnessS = sqrt1(timeBrightness);
		
		float cloud = 0.0;
		float cloudGradient = 0.0;
		float gradientMix = dither * 0.1667;
		float colorMultiplier = CLOUD_BRIGHTNESS * (0.23 + 0.07 * timeBrightnessS);
		float noiseMultiplier = CLOUD_THICKNESS * 0.125;
		float scattering = 0.5 * pow(cosS * 0.5 * (2.0 * sunVisibility - 1.0) + 0.5, 6.0);

		float cloudHeightFactor = max(1.07 - 0.001 * eyeAltitude, 0.0);
		cloudHeightFactor *= cloudHeightFactor;
		float cloudHeight = CLOUD_HEIGHT * cloudHeightFactor * 0.5;

		#if !defined GBUFFERS_WATER && !defined DEFERRED
			float cloudframetime = frametime;
		#else
			float cloudframetime = cloudtime;
		#endif
		float cloudSpeedFactor = 0.003;
		vec2 wind = vec2(cloudframetime * CLOUD_SPEED * cloudSpeedFactor, 0.0);
		#ifdef SEVEN
			wind *= 8;
		#endif

		vec3 cloudcolor = vec3(0.0);

		float stretchFactor = 2.5;
		float coordFactor = 0.009375;

		if (NdotU > 0.025) {
			vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos, 1.0)).xyz);
			for(int i = 0; i < sampleCount; i++) {
				if (cloud > 0.99) break;
				vec2 planeCoord = wpos.xz * ((cloudHeight + (i + dither) * stretchFactor * 6.0 / sampleCount) / wpos.y) * 0.0085;
				vec2 coord = cameraPosition.xz * 0.00025 + planeCoord;
				
				float ang1 = (i + frametime * 0.025) * 2.391;
				float ang2 = ang1 + 2.391;
				coord += mix(vec2(cos(ang1), sin(ang1)), vec2(cos(ang2), sin(ang2)), dither * 0.25 + 0.75) * coordFactor;
				
				float coverage = float(i - 3.0 + dither) * 0.725;
				
				float noise = CloudNoise(coord, wind);
					  noise = CloudCoverage(noise, coverage, NdotU, cosS) * noiseMultiplier;
					  noise = noise / pow(pow(noise, 2.5) + 1.0, 0.4);
				
				cloudGradient = mix(cloudGradient,
									mix(gradientMix * gradientMix, 1.0 - noise, 0.25),
									noise * (1.0 - cloud));
				
				cloud += max(noise - cloud * 0.95, 0.0);
				gradientMix += 0.2 * (6.0 / sampleCount);
			}

			float meFactorP = min((1.0 - min(moonBrightness, 0.6) / 0.6) * 0.115, 0.075);
			vec3 meColor = vec3(0.0);
			if (cosS > 0.0) {
				float meNdotU = 1.0 - NdotU;
				float meFactor = meFactorP * meNdotU * meNdotU * 12.0 * (1.0 - rainStrengthS);
				meColor = mix(lightMorning, lightEvening, mefade);
				meColor *= meColor * meColor;
				meColor *= meFactor * meFactor * cosS;
			}

			float sunVisibility2 = sunVisibility * sunVisibility;
			float sunVisibility4 = sunVisibility2 * sunVisibility2;

			sunVisibility4 = pow(sunVisibility4, 1.0 - meFactorP * 6.0);

			vec3 cloudNightColor = ambientCol * 10.0;
			vec3 cloudDayColor = pow(lightCol, vec3(1.5 + rainStrengthS)) * 1.5;

			vec3 cloudUpColor = mix(cloudNightColor, cloudDayColor, sunVisibility4);
			cloudUpColor *= 1.0 + scattering * (1.0 + pow2(rainStrengthS) * 4.0);
			cloudUpColor += max(meColor, vec3(0.0));

			vec3 cloudDownColor = skyColCustom * 0.175 * sunVisibility4;
			cloudcolor = mix(cloudDownColor, cloudUpColor, cloudGradient);

			cloud *= pow2(pow2(1.0 - exp(- (10.0 - 8.2 * rainStrengthS) * NdotU)));
		}

		return vec4(cloudcolor * colorMultiplier, cloud * CLOUD_OPACITY);
	}

	#ifdef AURORA

		float AuroraNoise(vec2 coord, vec2 wind) {
			float noise = texture2D(noisetex, coord * 0.175   + wind * 0.25).x;
				  noise+= texture2D(noisetex, coord * 0.04375 + wind * 0.15).x * 5.0;

			return noise;
		}

		vec3 DrawAurora(vec3 viewPos, float dither, int sampleCount, float NdotU) {
			#if AA > 1
				dither = fract(16.0 * frameTimeCounter + dither);
			#endif
			
			float gradientMix = dither / sampleCount;
			float visibility = (1.0 - sunVisibility) * (1.0 - rainStrengthS);
			visibility *= visibility;

			#ifdef AURORA_BIOME_CHECK
				visibility *= isSnowy;
			#endif
			#ifdef AURORA_FULL_MOON_CHECK
				visibility *= float(moonPhase == 0);
			#endif

			#if !defined GBUFFERS_WATER && !defined DEFERRED
				float cloudframetime = frametime;
			#else
				float cloudframetime = cloudtime;
			#endif

			vec2 wind = vec2(cloudframetime * 0.00005);

			vec3 aurora = vec3(0.0);

			float NdotUM = min(1.08 - NdotU, 1.0);
			NdotUM *= NdotUM;
			NdotUM = 1.0 - NdotUM * NdotUM;		

			if (NdotU > 0.0 && visibility > 0.0) {
				vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos, 1.0)).xyz);
				for(int i = 0; i < sampleCount; i++) {
					vec2 planeCoord = wpos.xz * ((8.0 * AURORA_HEIGHT + (i + dither) * 7.0 / sampleCount) / wpos.y) * 0.004;
					vec2 coord = cameraPosition.xz * 0.00001 + planeCoord;

					float noise = AuroraNoise(coord, wind);
						noise = max(1.0 - 1.5 / (1.0 - NdotU * 0.8) * abs(noise - 3.0), 0.0);

					if (noise > 0.0) {
						noise *= texture2D(noisetex, coord * 0.25 + wind * 0.25).x;
						noise *= 0.5 * texture2D(noisetex, coord + wind * 16.0).x + 0.75;
						noise = noise * noise * 3.0 / sampleCount;
						noise *= NdotUM;

						vec3 auroracolor = mix(
										auroraDCol,
										auroraUCol,
										pow(gradientMix, 0.4));

						aurora += noise * auroracolor * exp2(-6.0 * i / sampleCount);
					}
					gradientMix += 1.0 / sampleCount;
				}
			}

			aurora = aurora * visibility * 1.5;

			return aurora;
		}
	#endif
#endif

#ifdef SEVEN

	float GetNoise(vec2 pos) {
		return fract(sin(dot(pos, vec2(12.9898, 4.1414))) * 43758.54953);
	}

	vec3 DrawStars(inout vec3 color, vec3 viewPos, float NdotU) {
		vec3 wpos = vec3(gbufferModelViewInverse * vec4(viewPos, 1.0));
		vec3 planeCoord = 0.75 * wpos / (wpos.y + length(wpos.xz));
		vec2 wind = 0.75 * vec2(frametime, 0.0);
		#ifdef SEVEN
			wind = vec2(0.0);
		#endif
		vec2 coord = planeCoord.xz * 0.5 + wind * 0.00125;
		coord = floor(coord*1024.0) / 1024.0;
		
		float multiplier = 5.0 * (1.0 - rainStrengthS) * (1 - (sunVisibility*0.9 + pow(timeBrightness, 0.05)*0.1)) * pow(NdotU, 2.0);
		
		#ifdef SEVEN
			multiplier = sqrt2(NdotU) * 5.0 * (1.0 - rainStrengthS);	
		#endif
		
		float star = 1.0;
		if (NdotU > 0.0) {
			star *= GetNoise(coord.xy);
			star *= GetNoise(coord.xy+0.1);
			star *= GetNoise(coord.xy+0.23);
		}
		star = max(star - 0.825, 0.0) * multiplier;
		
		vec3 stars = star * lightNight * lightNight * 160;

		return vec3(stars);
	}
#endif

#if defined END && defined ENDER_NEBULA

	float CloudCoverageEnd(float noise, float cosT, float coverage) {
		float noiseMix = mix(noise, 21.0, 0.33 * rainStrengthS);
		float noiseFade = clamp(sqrt(cosT * 10.0), 0.0, 1.0);
		float noiseCoverage = ((coverage) + CLOUD_AMOUNT - 2);
		float multiplier = 1.0 - 0.5 * rainStrengthS;

		return max(noiseMix * noiseFade - noiseCoverage, 0.0) * multiplier;
	}

	float CloudNoiseEnd(vec2 coord, vec2 wind) {
		float noise = texture2D(noisetex, coord          + wind * 0.55).x;
			  noise+= texture2D(noisetex, coord*0.5      + wind * 0.45).x * -2.0;
			  noise+= texture2D(noisetex, coord*0.25     + wind * 0.35).x * 2.0;
			  noise+= texture2D(noisetex, coord*0.125    + wind * 0.25).x * -5.0;
			  noise+= texture2D(noisetex, coord*0.0625   + wind * 0.15).x * 20.0;
			  noise+= texture2D(noisetex, coord*0.03125  + wind * 0.05).x * 20.0;
			  noise+= texture2D(noisetex, coord*0.015625 + wind * 0.05).x * -15.0;
		return noise;
	}

	float GetNebulaStarNoise(vec2 pos) {
		return fract(sin(dot(pos, vec2(12.9898, 4.1414))) * 43758.54953);
	}

	float NebulaNoise(vec2 coord, vec2 wind) {
		float noise = texture2D(noisetex, coord * 0.175   + wind * 0.25).x;
			  noise+= texture2D(noisetex, coord * 0.04375 + wind * 0.15).x * 5.0;

		return noise;
	}

	vec3 DrawEnderNebula(vec3 viewPos, float dither, vec3 lightCol, bool stars) {
		float NdotU = dot(normalize(viewPos), upVec);
		float cosS = dot(normalize(viewPos), sunVec);
		cosS *= cosS;
		cosS *= cosS;
		cosS *= cosS;

		#if AA > 1
			dither = fract(16.0 * frameTimeCounter + dither);
		#endif

		int sampleCount = 20;
		
		float gradientMix = dither / sampleCount;

		#if !defined GBUFFERS_WATER && !defined DEFERRED
			float cloudframetime = frametime;
		#else
			float cloudframetime = cloudtime;
		#endif

		vec2 wind = vec2(cloudframetime * 0.000035);

		vec3 nebula = vec3(0.0);

		float NdotUM = abs(NdotU);
		NdotUM = 1.0 - NdotUM;
		NdotUM = pow(NdotUM, (2.0 - NdotUM) * (NEBULA_DISTRIBUTION - 0.8)) * 0.85;
		NdotUM = max(NdotUM, 0.0);
		float compression = pow(NdotUM, NEBULA_COMPRESSION);
		dither *= NEBULA_SMOOTHING;

		vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos * 1000.0, 1.0)).xyz);
		for(int i = 0; i < sampleCount; i++) {
			vec2 planeCoord = wpos.xz * (1.0 + (i + dither) * compression * 6.0 / sampleCount) * NEBULA_SIZE;
			vec2 coord = planeCoord + cameraPosition.xz * 0.00004;

			float noise = NebulaNoise(coord, wind);
					noise = max(0.75 - 1.0 / abs(noise - (4.0 + NdotUM * 2.0)), 0.0) * 3.0;

			if (noise > 0.0) {
				noise *= texture2D(noisetex, abs(coord * 0.25) + wind * 4.0).x;
				float fireNoise = texture2D(noisetex, abs(coord * 0.2) + wind * 8.0).x;
				noise *= 0.5 * fireNoise + 0.75;
				noise = noise * noise * 3.0 / sampleCount;
				noise *= NdotUM;

				vec3 nebulaColor = 12.0 * lightCol * NEBULA_PURPLE_BRIGHTNESS;
				nebulaColor += vec3(1.0, 0.25, 0.0) * NEBULA_ORANGE_BRIGHTNESS * 4.0 * pow(fireNoise, 5.0);
				nebulaColor *= gradientMix;

				nebula += noise * nebulaColor * exp2(-6.0 * i / sampleCount);
			}
			gradientMix += 1.0 / sampleCount;
		}

		if (stars) {
			vec3 starCoord = 0.75 * wpos / (abs(wpos.y) + length(wpos.xz));
			vec2 starCoord2 = starCoord.xz * 0.7;
			if (NdotU < 0.0) starCoord2 += 100.0;
			float starFactor = 1024.0;
			starCoord2 = floor(starCoord2 * starFactor) / starFactor;
			float star = 1.0;
			star *= GetNebulaStarNoise(starCoord2.xy);
			star *= GetNebulaStarNoise(starCoord2.xy+0.1);
			star *= GetNebulaStarNoise(starCoord2.xy+0.23);
			star = max(star - 0.825, 0.0);
			nebula += star * lightCol * 80.0 * (1.0 - NdotUM) * NEBULA_STAR_BRIGHTNESS;
		}

		return nebula * 2.0;
	}
#endif

#if defined NETHER && defined NETHER_SMOKE
		float SmokeNoise(vec2 coord, vec2 wind) {
			float noise = texture2D(noisetex, coord * 0.175   + wind * 0.25).x;
				  noise+= texture2D(noisetex, coord * 0.04375 + wind * 0.15).x * 5.0;

			return noise;
		}

		vec3 DrawNetherSmoke(vec3 viewPos, float dither, vec3 lightCol) {
			float NdotU = dot(normalize(viewPos), upVec);
			float cosS = dot(normalize(viewPos), sunVec);
			cosS *= cosS;
			cosS *= cosS;
			cosS *= cosS;

			#if AA > 1
				dither = fract(16.0 * frameTimeCounter + dither);
			#endif

			int sampleCount = 20;
			
			float gradientMix = dither / sampleCount;

			#if !defined GBUFFERS_WATER && !defined DEFERRED
				float cloudframetime = frametime;
			#else
				float cloudframetime = cloudtime;
			#endif

			vec2 wind = vec2(cloudframetime * 0.00005);

			vec3 smoke = vec3(0.0);

			float NdotUM = abs(NdotU);
			NdotUM = 1.0 - NdotUM;

			vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos, 1.0)).xyz);
			for(int i = 0; i < sampleCount; i++) {
				vec2 planeCoord = wpos.xz * (1.0 + (i + dither) * 6.0 / sampleCount) * 0.03;
				vec2 coord = planeCoord + cameraPosition.xz * 0.0017;

				float noise = SmokeNoise(coord, wind);
					  noise = max(0.75 - 1.0 / abs(noise - 6.0), 0.0) * 3.0;

				if (noise > 0.0) {
					noise *= texture2D(noisetex, abs(coord * 0.25) + wind * 8.0).x;
					float heightNoise = wpos.y;
					float fireNoise = texture2D(noisetex, abs(coord * 0.2) + (heightNoise + cameraPosition.y * 0.01) * 0.01 + wind * -4.0).x;
					noise = noise * noise * 3.0 / sampleCount;
					noise *= NdotUM;

					vec3 smokeColor = pow(lightCol, vec3(0.6, 0.5, 0.6)) * 12.0 * pow(fireNoise, 5.0);
					smokeColor *= gradientMix;

					smoke += noise * smokeColor * exp2(-6.0 * i / sampleCount);
				}
				gradientMix += 1.0 / sampleCount;
			}

			return smoke * 2.0;
		}
#endif
vec3 GetSkyColor(vec3 lightCol, float NdotU, vec3 nViewPos, bool isReflection) {
    float timeBrightnessInv = 1.0 - timeBrightness;
    float timeBrightnessInv2 = timeBrightnessInv * timeBrightnessInv;
    float timeBrightnessInv4 = timeBrightnessInv2 * timeBrightnessInv2;
    float timeBrightnessInv8 = timeBrightnessInv4 * timeBrightnessInv4;

    float NdotSp = clamp(dot(nViewPos, sunVec) * 0.5 + 0.5, 0.001, 1.0);
    float NdotS = NdotSp * NdotSp;
    NdotS *= NdotS;

    float absNdotU = abs(NdotU);

    vec3 skyColor2 = skyColor * skyColor;
    vec3 sky = mix(skyColor * 0.6, skyColor2, absNdotU) * (0.5 + 0.5 * sunVisibility);

    #ifdef ONESEVEN
        sky = vec3(0.812, 0.741, 0.674) * 0.5;
    #endif

    float horizon = 1.0 - max(NdotU + 0.1, 0.0) * (1.0 - 0.25 * NdotS * sunVisibility);
    horizon = min(horizon, 0.9);
    horizon *= horizon;
    
    float lightmix = NdotS * max(1.0 - absNdotU * 2.0, 0.0) * 0.5 + horizon + 0.05;
    lightmix *= sunVisibility * (1.0 - rainStrengthS) * timeBrightnessInv8;

    sky *= 2.0 - 0.5 * timeBrightnessInv4;
    sky *= mix(SKY_NOON, SKY_DAY, timeBrightnessInv4);
    
    float mult = 0.1 * (1.0 + rainStrengthS) + horizon * (0.3 + 0.1 * sunVisibility);
	
	float meFactorP = min((1.0 - min(moonBrightness, 0.6) / 0.6) * 0.115, 0.075);
    float meNdotU = 1.0 - absNdotU;
    float meFactor = meFactorP * meNdotU * meNdotU * 15.0 * (1.0 - rainStrengthS);
    vec3 meColor = mix(lightMorning, lightEvening, mefade);
    meColor *= meColor * meColor;
    meColor *= meFactor * meFactor * NdotS;

    vec3 finalSky = mix(sky * (1.0 - lightmix), lightCol * sqrt(lightCol), lightmix);
    
    vec3 nightSky = ambientNight * ambientNight * (3.5 + 4.5 * max(NdotU, 0.0));
    nightSky *= mix(SKY_NIGHT, 1.0, sunVisibility);
    finalSky += nightSky;

    finalSky *= max(1.0 - length(meColor) * 0.5, 0.0);
    finalSky += meColor * 0.8;
    
	if (isReflection) {
        float invNdotU = max(-NdotU, 0.0);
        float groundFactor = 0.5 * (11.0 * rainStrengthS + 1.0) * (-5.0 * sunVisibility + 6.0);
        float ground = exp(-groundFactor / (invNdotU * 6.0));
        ground = smoothstep(0.0, 1.0, ground);
        mult *= (1.0 - ground);
    }

    vec3 weatherSky = weatherCol * weatherCol;
    weatherSky *= GetLuminance(ambientCol / (weatherSky)) * 1.4;
    weatherSky *= mix(SKY_RAIN_NIGHT, SKY_RAIN_DAY, sunVisibility);
    weatherSky = max(weatherSky, skyColor2 * 0.75);
    finalSky = mix(finalSky, weatherSky, rainStrengthS) * mult;

    return pow(finalSky, vec3(1.125));
}

/*
vec3 GetTestSkyColor(vec3 lightCol, float NdotU, vec3 nViewPos, bool isReflection) {
    float timeBrightnessInv = 1.0 - timeBrightness;
    float timeBrightnessInv2 = timeBrightnessInv * timeBrightnessInv;
    float timeBrightnessInv4 = timeBrightnessInv2 * timeBrightnessInv2;
    float SdotU = dot( sunVec,upVec);
    float SdotUabs = abs(SdotU);
    float invSdotUabs = 1.0 - SdotUabs;
    float invSdotUabs2 = invSdotUabs * invSdotUabs;
    float invSdotUabs4 = invSdotUabs2 * invSdotUabs2;
    float invSdotUabs8 = invSdotUabs4 * invSdotUabs4;
    float invSdotUabsF = smoothstep(0.0, 1.0, invSdotUabs2);
    float invSdotUabsFN = SdotU > 0.0 ? 1.0 : invSdotUabsF;
    float NdotUabs = abs(NdotU);
    float invNdotUabs = 1.0 - NdotUabs;
    float invNdotUabs2 = invNdotUabs * invNdotUabs;
    float invNdotUabs4 = invNdotUabs2 * invNdotUabs2;
    float invNdotUabs8 = invNdotUabs4 * invNdotUabs4;
    float invNdotUabs16 = invNdotUabs8 * invNdotUabs8;
    float invNdotUabsF = smoothstep(0.0, 1.0, invNdotUabs4);
    float NdotS = dot(nViewPos, sunVec);
    float NdotSM = (1.0 + NdotS) * 0.5;
    vec3 sqrtLight = sqrt(lightCol);
    vec3 lightSunset = lightEvening * lightEvening;
         lightSunset *= (1.0 + sunVisibility) * NdotSM * NdotSM * invSdotUabsFN * (timeBrightnessInv4);
    vec3 skyNight = ambientNight * ambientNight * 5.0 + 0.2 * skyColCustom * invSdotUabsFN;

    vec3 topSky = skyColor * skyColor + skyNight;
    topSky *= 0.5 + 2.0 * invNdotUabs2;

    vec3 middleSky = mix(lightCol, lightSunset, length(lightSunset) * 0.8) * 3.0 + skyNight;

    vec3 downSky = skyColor * (1.25 + 1.0 * invNdotUabs2) * lightCol * 1.5 + skyNight * 2.0;

    float NdotUM = 1.0 - invNdotUabs8;
    NdotUM = NdotUM * (1.0 - 2.0 * float(NdotU < 0.0));
    NdotUM = (NdotUM + 1.0) * 0.5;
    vec3 topDownSky = mix(downSky, topSky, NdotUM);

    vec3 finalSky = mix(topDownSky, middleSky, invNdotUabs8 * 0.4);
    

    return finalSky * 0.1;
    //return vec3(1.0, 0.0, 1.0);
}
*/
#endif

#if defined NETHER && defined NETHER_SMOKE
#if !defined END && !defined SEVEN && !defined NETHER

	float CloudNoise(vec2 coord, vec2 wind) {
		float noise = texture2D(noisetex, coord*0.125    + wind * 0.25).x * 7.0;
			  noise+= texture2D(noisetex, coord*0.0625   + wind * 0.15).x * 12.0;
			  noise+= texture2D(noisetex, coord*0.03125  + wind * 0.05).x * 12.0;
			  noise+= texture2D(noisetex, coord*0.015625 + wind * 0.05).x * 24.0;
		return noise*0.34;
	}

	float CloudCoverage(float noise, float coverage, float NdotU, float cosS) {
		float noiseCoverageCosS = abs(cosS);
		noiseCoverageCosS *= noiseCoverageCosS;
		noiseCoverageCosS *= noiseCoverageCosS;
		float NdotUmult = 0.365;
		#ifdef AURORA
			float auroraMult = max(1.0 - sunVisibility - rainStrengthS, 0.0);
			#ifdef AURORA_BIOME_CHECK
				auroraMult *= isSnowy;
			#endif
			#ifdef AURORA_FULL_MOON_CHECK
				auroraMult *= float(moonPhase == 0);
			#endif
			NdotUmult *= 1.0 + 2.5 * auroraMult;
		#endif
		float noiseCoverage = coverage * coverage + CLOUD_AMOUNT
								* (1.0 + noiseCoverageCosS * 0.175) 
								* (1.0 + NdotU * NdotUmult * (1.0-rainStrengthS*3.0))
								- 2.5;

		return max(noise - noiseCoverage, 0.0);
	}

	vec4 DrawCloud(vec3 viewPos, float dither, vec3 lightCol, vec3 ambientCol, float NdotU, int sampleCount) {
		float cosS = dot(normalize(viewPos), sunVec);
		
		#if AA > 1
			dither = fract(16.0 * frameTimeCounter + dither);
		#endif

		float timeBrightnessS = sqrt1(timeBrightness);
		
		float cloud = 0.0;
		float cloudGradient = 0.0;
		float gradientMix = dither * 0.1667;
		float colorMultiplier = CLOUD_BRIGHTNESS * (0.23 + 0.07 * timeBrightnessS);
		float noiseMultiplier = CLOUD_THICKNESS * 0.125;
		float scattering = 0.5 * pow(cosS * 0.5 * (2.0 * sunVisibility - 1.0) + 0.5, 6.0);

		float cloudHeightFactor = max(1.07 - 0.001 * eyeAltitude, 0.0);
		cloudHeightFactor *= cloudHeightFactor;
		float cloudHeight = CLOUD_HEIGHT * cloudHeightFactor * 0.5;

		#if !defined GBUFFERS_WATER && !defined DEFERRED
			float cloudframetime = frametime;
		#else
			float cloudframetime = cloudtime;
		#endif
		float cloudSpeedFactor = 0.003;
		vec2 wind = vec2(cloudframetime * CLOUD_SPEED * cloudSpeedFactor, 0.0);
		#ifdef SEVEN
			wind *= 8;
		#endif

		vec3 cloudcolor = vec3(0.0);

		float stretchFactor = 2.5;
		float coordFactor = 0.009375;

		if (NdotU > 0.025) {
			vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos, 1.0)).xyz);
			for(int i = 0; i < sampleCount; i++) {
				if (cloud > 0.99) break;
				vec2 planeCoord = wpos.xz * ((cloudHeight + (i + dither) * stretchFactor * 6.0 / sampleCount) / wpos.y) * 0.0085;
				vec2 coord = cameraPosition.xz * 0.00025 + planeCoord;
				
				float ang1 = (i + frametime * 0.025) * 2.391;
				float ang2 = ang1 + 2.391;
				coord += mix(vec2(cos(ang1), sin(ang1)), vec2(cos(ang2), sin(ang2)), dither * 0.25 + 0.75) * coordFactor;
				
				float coverage = float(i - 3.0 + dither) * 0.725;
				
				float noise = CloudNoise(coord, wind);
					  noise = CloudCoverage(noise, coverage, NdotU, cosS) * noiseMultiplier;
					  noise = noise / pow(pow(noise, 2.5) + 1.0, 0.4);
				
				cloudGradient = mix(cloudGradient,
									mix(gradientMix * gradientMix, 1.0 - noise, 0.25),
									noise * (1.0 - cloud));
				
				cloud += max(noise - cloud * 0.95, 0.0);
				gradientMix += 0.2 * (6.0 / sampleCount);
			}

			float meFactorP = min((1.0 - min(moonBrightness, 0.6) / 0.6) * 0.115, 0.075);
			vec3 meColor = vec3(0.0);
			if (cosS > 0.0) {
				float meNdotU = 1.0 - NdotU;
				float meFactor = meFactorP * meNdotU * meNdotU * 12.0 * (1.0 - rainStrengthS);
				meColor = mix(lightMorning, lightEvening, mefade);
				meColor *= meColor * meColor;
				meColor *= meFactor * meFactor * cosS;
			}

			float sunVisibility2 = sunVisibility * sunVisibility;
			float sunVisibility4 = sunVisibility2 * sunVisibility2;

			sunVisibility4 = pow(sunVisibility4, 1.0 - meFactorP * 6.0);

			vec3 cloudNightColor = ambientCol * 10.0;
			vec3 cloudDayColor = pow(lightCol, vec3(1.5 + rainStrengthS)) * 1.5;

			vec3 cloudUpColor = mix(cloudNightColor, cloudDayColor, sunVisibility4);
			cloudUpColor *= 1.0 + scattering * (1.0 + pow2(rainStrengthS) * 4.0);
			cloudUpColor += max(meColor, vec3(0.0));

			vec3 cloudDownColor = skyColCustom * 0.175 * sunVisibility4;
			cloudcolor = mix(cloudDownColor, cloudUpColor, cloudGradient);

			cloud *= pow2(pow2(1.0 - exp(- (10.0 - 8.2 * rainStrengthS) * NdotU)));
		}

		return vec4(cloudcolor * colorMultiplier, cloud * CLOUD_OPACITY);
	}

	#ifdef AURORA

		float AuroraNoise(vec2 coord, vec2 wind) {
			float noise = texture2D(noisetex, coord * 0.175   + wind * 0.25).x;
				  noise+= texture2D(noisetex, coord * 0.04375 + wind * 0.15).x * 5.0;

			return noise;
		}

		vec3 DrawAurora(vec3 viewPos, float dither, int sampleCount, float NdotU) {
			#if AA > 1
				dither = fract(16.0 * frameTimeCounter + dither);
			#endif
			
			float gradientMix = dither / sampleCount;
			float visibility = (1.0 - sunVisibility) * (1.0 - rainStrengthS);
			visibility *= visibility;

			#ifdef AURORA_BIOME_CHECK
				visibility *= isSnowy;
			#endif
			#ifdef AURORA_FULL_MOON_CHECK
				visibility *= float(moonPhase == 0);
			#endif

			#if !defined GBUFFERS_WATER && !defined DEFERRED
				float cloudframetime = frametime;
			#else
				float cloudframetime = cloudtime;
			#endif

			vec2 wind = vec2(cloudframetime * 0.00005);

			vec3 aurora = vec3(0.0);

			float NdotUM = min(1.08 - NdotU, 1.0);
			NdotUM *= NdotUM;
			NdotUM = 1.0 - NdotUM * NdotUM;		

			if (NdotU > 0.0 && visibility > 0.0) {
				vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos, 1.0)).xyz);
				for(int i = 0; i < sampleCount; i++) {
					vec2 planeCoord = wpos.xz * ((8.0 * AURORA_HEIGHT + (i + dither) * 7.0 / sampleCount) / wpos.y) * 0.004;
					vec2 coord = cameraPosition.xz * 0.00001 + planeCoord;

					float noise = AuroraNoise(coord, wind);
						noise = max(1.0 - 1.5 / (1.0 - NdotU * 0.8) * abs(noise - 3.0), 0.0);

					if (noise > 0.0) {
						noise *= texture2D(noisetex, coord * 0.25 + wind * 0.25).x;
						noise *= 0.5 * texture2D(noisetex, coord + wind * 16.0).x + 0.75;
						noise = noise * noise * 3.0 / sampleCount;
						noise *= NdotUM;

						vec3 auroracolor = mix(
										auroraDCol,
										auroraUCol,
										pow(gradientMix, 0.4));

						aurora += noise * auroracolor * exp2(-6.0 * i / sampleCount);
					}
					gradientMix += 1.0 / sampleCount;
				}
			}

			aurora = aurora * visibility * 1.5;

			return aurora;
		}
	#endif
#endif

#ifdef SEVEN

	float GetNoise(vec2 pos) {
		return fract(sin(dot(pos, vec2(12.9898, 4.1414))) * 43758.54953);
	}

	vec3 DrawStars(inout vec3 color, vec3 viewPos, float NdotU) {
		vec3 wpos = vec3(gbufferModelViewInverse * vec4(viewPos, 1.0));
		vec3 planeCoord = 0.75 * wpos / (wpos.y + length(wpos.xz));
		vec2 wind = 0.75 * vec2(frametime, 0.0);
		#ifdef SEVEN
			wind = vec2(0.0);
		#endif
		vec2 coord = planeCoord.xz * 0.5 + wind * 0.00125;
		coord = floor(coord*1024.0) / 1024.0;
		
		float multiplier = 5.0 * (1.0 - rainStrengthS) * (1 - (sunVisibility*0.9 + pow(timeBrightness, 0.05)*0.1)) * pow(NdotU, 2.0);
		
		#ifdef SEVEN
			multiplier = sqrt2(NdotU) * 5.0 * (1.0 - rainStrengthS);	
		#endif
		
		float star = 1.0;
		if (NdotU > 0.0) {
			star *= GetNoise(coord.xy);
			star *= GetNoise(coord.xy+0.1);
			star *= GetNoise(coord.xy+0.23);
		}
		star = max(star - 0.825, 0.0) * multiplier;
		
		vec3 stars = star * lightNight * lightNight * 160;

		return vec3(stars);
	}
#endif

#if defined END && defined ENDER_NEBULA

	float CloudCoverageEnd(float noise, float cosT, float coverage) {
		float noiseMix = mix(noise, 21.0, 0.33 * rainStrengthS);
		float noiseFade = clamp(sqrt(cosT * 10.0), 0.0, 1.0);
		float noiseCoverage = ((coverage) + CLOUD_AMOUNT - 2);
		float multiplier = 1.0 - 0.5 * rainStrengthS;

		return max(noiseMix * noiseFade - noiseCoverage, 0.0) * multiplier;
	}

	float CloudNoiseEnd(vec2 coord, vec2 wind) {
		float noise = texture2D(noisetex, coord          + wind * 0.55).x;
			  noise+= texture2D(noisetex, coord*0.5      + wind * 0.45).x * -2.0;
			  noise+= texture2D(noisetex, coord*0.25     + wind * 0.35).x * 2.0;
			  noise+= texture2D(noisetex, coord*0.125    + wind * 0.25).x * -5.0;
			  noise+= texture2D(noisetex, coord*0.0625   + wind * 0.15).x * 20.0;
			  noise+= texture2D(noisetex, coord*0.03125  + wind * 0.05).x * 20.0;
			  noise+= texture2D(noisetex, coord*0.015625 + wind * 0.05).x * -15.0;
		return noise;
	}

	float GetNebulaStarNoise(vec2 pos) {
		return fract(sin(dot(pos, vec2(12.9898, 4.1414))) * 43758.54953);
	}

	float NebulaNoise(vec2 coord, vec2 wind) {
		float noise = texture2D(noisetex, coord * 0.175   + wind * 0.25).x;
			  noise+= texture2D(noisetex, coord * 0.04375 + wind * 0.15).x * 5.0;

		return noise;
	}

	vec3 DrawEnderNebula(vec3 viewPos, float dither, vec3 lightCol, bool stars) {
		float NdotU = dot(normalize(viewPos), upVec);
		float cosS = dot(normalize(viewPos), sunVec);
		cosS *= cosS;
		cosS *= cosS;
		cosS *= cosS;

		#if AA > 1
			dither = fract(16.0 * frameTimeCounter + dither);
		#endif

		int sampleCount = 20;
		
		float gradientMix = dither / sampleCount;

		#if !defined GBUFFERS_WATER && !defined DEFERRED
			float cloudframetime = frametime;
		#else
			float cloudframetime = cloudtime;
		#endif

		vec2 wind = vec2(cloudframetime * 0.000035);

		vec3 nebula = vec3(0.0);

		float NdotUM = abs(NdotU);
		NdotUM = 1.0 - NdotUM;
		NdotUM = pow(NdotUM, (2.0 - NdotUM) * (NEBULA_DISTRIBUTION - 0.8)) * 0.85;
		NdotUM = max(NdotUM, 0.0);
		float compression = pow(NdotUM, NEBULA_COMPRESSION);
		dither *= NEBULA_SMOOTHING;

		vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos * 1000.0, 1.0)).xyz);
		for(int i = 0; i < sampleCount; i++) {
			vec2 planeCoord = wpos.xz * (1.0 + (i + dither) * compression * 6.0 / sampleCount) * NEBULA_SIZE;
			vec2 coord = planeCoord + cameraPosition.xz * 0.00004;

			float noise = NebulaNoise(coord, wind);
					noise = max(0.75 - 1.0 / abs(noise - (4.0 + NdotUM * 2.0)), 0.0) * 3.0;

			if (noise > 0.0) {
				noise *= texture2D(noisetex, abs(coord * 0.25) + wind * 4.0).x;
				float fireNoise = texture2D(noisetex, abs(coord * 0.2) + wind * 8.0).x;
				noise *= 0.5 * fireNoise + 0.75;
				noise = noise * noise * 3.0 / sampleCount;
				noise *= NdotUM;

				vec3 nebulaColor = 12.0 * lightCol * NEBULA_PURPLE_BRIGHTNESS;
				nebulaColor += vec3(1.0, 0.25, 0.0) * NEBULA_ORANGE_BRIGHTNESS * 4.0 * pow(fireNoise, 5.0);
				nebulaColor *= gradientMix;

				nebula += noise * nebulaColor * exp2(-6.0 * i / sampleCount);
			}
			gradientMix += 1.0 / sampleCount;
		}

		if (stars) {
			vec3 starCoord = 0.75 * wpos / (abs(wpos.y) + length(wpos.xz));
			vec2 starCoord2 = starCoord.xz * 0.7;
			if (NdotU < 0.0) starCoord2 += 100.0;
			float starFactor = 1024.0;
			starCoord2 = floor(starCoord2 * starFactor) / starFactor;
			float star = 1.0;
			star *= GetNebulaStarNoise(starCoord2.xy);
			star *= GetNebulaStarNoise(starCoord2.xy+0.1);
			star *= GetNebulaStarNoise(starCoord2.xy+0.23);
			star = max(star - 0.825, 0.0);
			nebula += star * lightCol * 80.0 * (1.0 - NdotUM) * NEBULA_STAR_BRIGHTNESS;
		}

		return nebula * 2.0;
	}
#endif

#if defined NETHER && defined NETHER_SMOKE
		float SmokeNoise(vec2 coord, vec2 wind) {
			float noise = texture2D(noisetex, coord * 0.175   + wind * 0.25).x;
				  noise+= texture2D(noisetex, coord * 0.04375 + wind * 0.15).x * 5.0;

			return noise;
		}

		vec3 DrawNetherSmoke(vec3 viewPos, float dither, vec3 lightCol) {
			float NdotU = dot(normalize(viewPos), upVec);
			float cosS = dot(normalize(viewPos), sunVec);
			cosS *= cosS;
			cosS *= cosS;
			cosS *= cosS;

			#if AA > 1
				dither = fract(16.0 * frameTimeCounter + dither);
			#endif

			int sampleCount = 20;
			
			float gradientMix = dither / sampleCount;

			#if !defined GBUFFERS_WATER && !defined DEFERRED
				float cloudframetime = frametime;
			#else
				float cloudframetime = cloudtime;
			#endif

			vec2 wind = vec2(cloudframetime * 0.00005);

			vec3 smoke = vec3(0.0);

			float NdotUM = abs(NdotU);
			NdotUM = 1.0 - NdotUM;

			vec3 wpos = normalize((gbufferModelViewInverse * vec4(viewPos, 1.0)).xyz);
			for(int i = 0; i < sampleCount; i++) {
				vec2 planeCoord = wpos.xz * (1.0 + (i + dither) * 6.0 / sampleCount) * 0.03;
				vec2 coord = planeCoord + cameraPosition.xz * 0.0017;

				float noise = SmokeNoise(coord, wind);
					  noise = max(0.75 - 1.0 / abs(noise - 6.0), 0.0) * 3.0;

				if (noise > 0.0) {
					noise *= texture2D(noisetex, abs(coord * 0.25) + wind * 8.0).x;
					float heightNoise = wpos.y;
					float fireNoise = texture2D(noisetex, abs(coord * 0.2) + (heightNoise + cameraPosition.y * 0.01) * 0.01 + wind * -4.0).x;
					noise = noise * noise * 3.0 / sampleCount;
					noise *= NdotUM;

					vec3 smokeColor = pow(lightCol, vec3(0.6, 0.5, 0.6)) * 12.0 * pow(fireNoise, 5.0);
					smokeColor *= gradientMix;

					smoke += noise * smokeColor * exp2(-6.0 * i / sampleCount);
				}
				gradientMix += 1.0 / sampleCount;
			}

			return smoke * 2.0;
		}
#endif
#endif

#ifdef OVERWORLD

vec3 SunGlare(vec3 color, vec3 nViewPos, vec3 lightCol) {
	float cosSp = dot(nViewPos, lightVec);
	if (cosSp > 0.0) {
		float cosS = cosSp;
		cosS *= cosS;
		cosS *= cosS;
		cosS *= cosS;
		float visfactor = 0.075;

		float sunGlare = cosS;
		sunGlare = visfactor / (1.0 - (1.0 - visfactor) * sunGlare) - visfactor;
		sunGlare *= cosSp;

		sunGlare *= 0.25 * SUN_GLARE_STRENGTH * (1.0 - rainStrengthS);

		float shadowTime = abs(sunVisibility - 0.5) * 2.0;
		shadowTime *= shadowTime;
		sunGlare *= shadowTime * shadowTime;

		vec3 finalSunGlare = lightCol * sunGlare;

		if (isEyeInWater == 1) finalSunGlare *= underwaterColor.rgb * underwaterColor.rgb * 200.0;

		color += finalSunGlare;
	}
	
	return color;
}

#endif

vec3 Fog1(vec3 color, float lWorldPos, float lViewPos, vec3 nViewPos, vec3 extra, float NdotU) {
    #if defined OVERWORLD && !defined ONESEVEN && !defined TWO
		#if FOG1_TYPE < 2
		float fog = lWorldPos / far * 1.5 * (10/FOG1_DISTANCE);
		#else
		float fog = lViewPos / far * 1.5 * (10/FOG1_DISTANCE);
		#endif

		fog = 1.0 - exp(-0.1 * pow(fog, 10.0));

		if (fog > 0.0) {
			vec3 artificialFogColor = GetSkyColor(lightCol, NdotU, nViewPos, false);
			artificialFogColor = SunGlare(artificialFogColor, nViewPos, lightCol);
			if (eyeAltitude < 2.0) artificialFogColor.rgb *= clamp((eyeAltitude-1.0), 0.0, 1.0);
			color.rgb = mix(color.rgb, artificialFogColor, fog);
		}
	#endif

    #if defined NETHER && defined NETHER_FOG // extra = nether smoke (if enabled)
		#if FOG1_TYPE > 0
		float fog = lViewPos / far * 1.5;
		#else
		float fog = lWorldPos / far * 1.5;
		#endif

		fog = 1.0 - exp(-6.0 * pow(fog, 5.0));
		vec3 artificialFogColor = pow((netherCol * 2.5) / NETHER_I, vec3(2.2)) * 4;
		#ifdef NETHER_SMOKE
			artificialFogColor += extra * fog;
		#endif
		color.rgb = mix(color.rgb, artificialFogColor, fog);
    #endif

    #ifdef END // extra = viewPos
		float fog = lWorldPos / far * 1.5 * (10/FOG1_DISTANCE);
		fog = 1.0 - exp(-0.1 * pow(fog, 10.0));
		if (fog > 0.0) {
			vec3 artificialFogColor = endCol * 0.0584;
			#if defined ENDER_NEBULA && !defined COMPATIBILITY_MODE
				float dither = Bayer64(gl_FragCoord.xy);
				vec3 nebula = DrawEnderNebula(extra.xyz, dither, endCol, false);
				nebula = pow(nebula, vec3(1.0 / 2.2));
				nebula *= pow(nebula.rgb, vec3(2.2));
				artificialFogColor.rgb += nebula.rgb * fog;
			#endif
			color.rgb = mix(color.rgb, artificialFogColor, fog);
		}
    #endif

    #ifdef TWO
		float fog = lWorldPos / far * 4.0 * (10/FOG1_DISTANCE);
		fog = 1.0 - exp(-0.1 * pow(fog, 3.0));

		//float NdotU = 1.0 - max(dot(nViewPos, upVec), 0.0);
		NdotU = 1.0 - max(NdotU, 0.0);
		NdotU = NdotU * NdotU;
		#ifndef ABYSS
			vec3 midnightPurple = vec3(0.0003, 0.0004, 0.002) * 1.25;
			vec3 midnightFogColor = fogColor * fogColor * 0.3;
		#else
			vec3 midnightPurple = skyColor * skyColor * 0.00075;
			vec3 midnightFogColor = fogColor * fogColor * 0.09;
		#endif
		vec3 artificialFogColor = mix(midnightPurple, midnightFogColor, NdotU);

		color.rgb = mix(color.rgb, artificialFogColor, fog);
    #endif
	
    #ifdef SEVEN
		float fog = lWorldPos / far * 1.5 * (10/FOG1_DISTANCE);
		fog = 1.0 - exp(-0.1 * pow(fog, 10.0));
		float cosT = dot(nViewPos, upVec);
		vec3 twilightPurple  = vec3(0.005, 0.006, 0.018);
		vec3 twilightGreen = vec3(0.015, 0.03, 0.02);
		#ifdef TWENTY
		twilightPurple = twilightGreen * 0.1;
		#endif
		vec3 artificialFogColor = 2 * (twilightPurple * 2 * clamp(pow(cosT, 0.7), 0.0, 1.0) + twilightGreen * (1-clamp(pow(cosT, 0.7), 0.0, 1.0)));
		color.rgb = mix(color.rgb, artificialFogColor, fog);
    #endif
	
    #ifdef ONESEVEN
		float fogoneseven = lWorldPos / 16 * (1.35-sunVisibility*0.35);
		fogoneseven = 1.0 - exp(-0.1 * pow(fogoneseven, 3.0));

		if (fogoneseven > 0.0) {
			vec3 artificialFogColor = GetSkyColor(lightCol, NdotU, nViewPos, false);
			artificialFogColor = SunGlare(artificialFogColor, nViewPos, lightCol);
			if (eyeAltitude < 2.0) artificialFogColor.rgb *= clamp((eyeAltitude-1.0), 0.0, 1.0);
			color.rgb = mix(color.rgb, artificialFogColor, fogoneseven);
		}
    #endif
	
	return vec3(color.rgb);
}

vec3 Fog2(vec3 color, float lViewPos, vec3 worldPos) {

    #ifdef OVERWORLD
		#ifdef FOG2_ALTITUDE_MODE
			float altitudeFactor = (worldPos.y + eyeAltitude + 1000 - FOG2_ALTITUDE) * 0.001;
			if (altitudeFactor > 0.965 && altitudeFactor < 1.0) altitudeFactor = pow(altitudeFactor, 1.0 - (altitudeFactor - 0.965) * 28.57);
			altitudeFactor = clamp(pow(altitudeFactor, 20.0), 0.0, 1.0);
		#endif
		
		float fog2 = lViewPos / pow(far, 0.25) * 0.035 * (1.0 + rainStrengthS * FOG2_RAIN_DISTANCE_M) * (1.0 - sunVisibility*0.25*(1.0 - rainStrengthS)) * (32.0/(FOG2_DISTANCE + 0.01));
		fog2 = (1.0 - (exp(-50.0 * pow(fog2*0.125, 3.25) * eBS)));
		fog2 *= min(FOG2_OPACITY * (3.0 + rainStrengthS * FOG2_RAIN_OPACITY_M - sunVisibility * 2.0), 1.0);
		#ifdef FOG2_ALTITUDE_MODE
			fog2 *= pow(clamp((eyeAltitude - FOG2_ALTITUDE*0.2) / FOG2_ALTITUDE, 0.0, 1.0), 2.5 - FOG2_RAIN_ALTITUDE_M * rainStrengthS * 2.5);
			fog2 *= 1.0 - altitudeFactor * (1.0 - FOG2_RAIN_ALTITUDE_M * rainStrengthS);
		#endif
		
		float sunVisibility2 = sunVisibility * sunVisibility;
		float sunVisibility4 = sunVisibility2 * sunVisibility2;
		float sunVisibility8 = sunVisibility4 * sunVisibility4;
		float timeBrightness2 = sqrt1(timeBrightness);
		vec3 fogColor2 = mix(lightCol*0.5, pow(skyColCustom, vec3(0.7))*1.15, timeBrightness2);
		fogColor2 = mix(ambientNight*ambientNight*ambientNight*7.5, fogColor2, sunVisibility8);
		if (rainStrengthS > 0.0) {
			float rainStrengthS2 = 1.0 - (1.0 - rainStrengthS) * (1.0 - rainStrengthS);
			fogColor2 = mix(fogColor2, FOG2_RAIN_BRIGHTNESS_M * skyColCustom * (0.01 + 0.05 * sunVisibility8 + 0.1 * timeBrightness2), rainStrengthS2);
		}
		fogColor2 *= FOG2_BRIGHTNESS;
		if (eyeAltitude < 2.0) fogColor2.rgb *= clamp((eyeAltitude-1.0), 0.0, 1.0);

		color.rgb = mix(color.rgb, fogColor2, fog2);
    #endif

    #ifdef END
		float fog2 = lViewPos / pow(far, 0.25) * 0.035 * (32.0/FOG2_END_DISTANCE);
		fog2 = 1.0 - (exp(-50.0 * pow(fog2*0.125, 4.0)));
		#ifdef FOG2_ALTITUDE_MODE
			float altitudeFactor = clamp((worldPos.y + eyeAltitude + 100 - FOG2_END_ALTITUDE) * 0.01, 0.0, 1.0);
			if (altitudeFactor > 0.75 && altitudeFactor < 1.0) altitudeFactor = pow(altitudeFactor, 1.0 - (altitudeFactor - 0.75) * 4.0);
			fog2 *= 1.0 - altitudeFactor;
		#endif
		fog2 = clamp(fog2, 0.0, 0.125) * (7.0 + fog2);
		fog2 = 1 - pow(1 - fog2, 2.0 - fog2);
		vec3 fogColor2 = endCol * 0.051 * pow(2.5 / 2.25, 1.3);
		color.rgb = mix(color.rgb, fogColor2 * FOG2_END_BRIGHTNESS, fog2 * FOG2_END_OPACITY);
    #endif
	
    #if defined SEVEN && !defined TWENTY
		float fog2 = lViewPos / pow(far, 0.25) * 0.035 * (1 + rainStrengthS) * (32.0/(FOG2_DISTANCE + 0.01));
		fog2 = 1.0 - (exp(-50.0 * pow(fog2*0.125, 4.0) * eBS));
		float altitudeFactor = (worldPos.y + eyeAltitude + 1000 - 90 * (1 + rainStrengthS*0.5)) * 0.001;
		if (altitudeFactor > 0.965 && altitudeFactor < 1.0) altitudeFactor = pow(altitudeFactor, 1.0 - (altitudeFactor - 0.965) * 28.57);
		fog2 *= 1.0 - altitudeFactor;
		fog2 = clamp(fog2, 0.0, 0.125) * (7.0 + fog2);
		vec3 fogColor2 = vec3(0.015, 0.03, 0.02);
		if (eyeAltitude < 2.0) fogColor2.rgb *= clamp((eyeAltitude-1.0), 0.0, 1.0);
		color.rgb = mix(color.rgb, fogColor2, fog2 * 0.80);
    #endif
	
	return vec3(color.rgb);
}

vec3 WaterFog(vec3 color, float lViewPos, float fogrange) {
    float fog = lViewPos / fogrange;
    fog = 1.0 - exp(-3.0 * fog * fog);
	color *= pow(max(underwaterColor.rgb, vec3(0.1)), vec3(0.5)) * 3.0;
    color = mix(color, 0.8 * pow(underwaterColor.rgb * (1.0 - blindFactor), vec3(2.0)), fog);

	return vec3(color.rgb);
}

vec3 BlindFog(vec3 color, float lViewPos) {
	float fog = lViewPos *0.04* (5.0 / blindFactor);
	fog = (1.0 - exp(-6.0 * fog * fog * fog)) * blindFactor;
	color.rgb = mix(color.rgb, vec3(0.0), fog);
	
	return vec3(color.rgb);
}

vec3 LavaFog(vec3 color, float lViewPos) {
	#ifndef LAVA_VISIBILITY
		float fog = lViewPos * 0.3;
		fog = (1.0 - exp(-4.0 * fog * fog * fog));
		color.rgb = mix(color.rgb, vec3(0.5), fog);
	#else
		float fog = lViewPos * 0.02;
		fog = 1.0 - exp(-3.0 * fog);
		color.rgb = mix(color.rgb, vec3(0.5), fog);
	#endif

	return vec3(color.rgb);
}

vec3 startFog(vec3 color, vec3 nViewPos, float lViewPos, vec3 worldPos, vec3 extra, float NdotU) {
	#if defined FOG2 && !defined GBUFFER_CODING
		if (isEyeInWater == 0) color.rgb = Fog2(color.rgb, lViewPos, worldPos);
	#endif
	
	#if defined FOG1 && !defined GBUFFER_CODING
		if (isEyeInWater == 0) color.rgb = Fog1(color.rgb, length(worldPos.xz) * 1.025, lViewPos, nViewPos, extra, NdotU);
	#endif
	
	if (isEyeInWater == 1 && blindFactor == 0) color.rgb = WaterFog(color.rgb, lViewPos, waterFog * (1.0 + eBS));
	if (isEyeInWater == 2 && blindFactor == 0) color.rgb = LavaFog(color.rgb, lViewPos);
	if (blindFactor > 0.0) color.rgb = BlindFog(color.rgb, lViewPos);
	
	return vec3(color.rgb);
}

#if AA == 2 || AA == 3
//Jitter offset from Chocapic13
uniform float framemod8;

vec2 jitterOffsets[8] = vec2[8]( // LiteTAA Jitter
							vec2( 0.125,-0.375),
							vec2(-0.125, 0.375),
							vec2( 0.625, 0.125),
							vec2( 0.375,-0.625),
							vec2(-0.625, 0.625),
							vec2(-0.875,-0.125),
							vec2( 0.375,-0.875),
							vec2( 0.875, 0.875)
						);
							   
vec2 TAAJitter(vec2 coord, float w) {
	vec2 offset = jitterOffsets[int(framemod8)] *0.125* (w / vec2(viewWidth, viewHeight));
	return coord + offset;
}
#endif
#if AA == 4
//Jitter offset from Chocapic13
uniform float framemod8;

vec2 jitterOffsets[8] = vec2[8](
							vec2( 0.125,-0.375),
							vec2(-0.125, 0.375),
							vec2( 0.625, 0.125),
							vec2( 0.375,-0.625),
							vec2(-0.625, 0.625),
							vec2(-0.875,-0.125),
							vec2( 0.375,-0.875),
							vec2( 0.875, 0.875)
						);
							   
vec2 TAAJitter(vec2 coord, float w) {
	vec2 offset = jitterOffsets[int(framemod8)] * (w / vec2(viewWidth, viewHeight));
	return coord + offset;
}
#endif

//Program//
void main() {
	vec4 albedoP = texture2D(texture, texCoord);
	if (albedoP.a == 0.0) discard; //needed for "Create" mod support
    vec4 albedo = albedoP * vec4(color.rgb, 1.0);
	
	float emissive = 0.0;
	vec3 newNormal = normal;
	vec3 vlAlbedo = vec3(1.0);
	vec3 worldPos = vec3(0.0);
	#ifdef WATER_REFRACT
		float waterMask = 0.0;
	#endif
	
	#ifndef COMPATIBILITY_MODE
		float albedocheck = albedo.a;
	#else
		float albedocheck = albedo.a * 100000.0;
	#endif

	if (albedocheck > 0.00001) {
		vec2 lightmap = lmCoord;
		
		float water            = float(mat > 0.98 && mat < 1.02);
		float translucent      = float(mat > 1.98 && mat < 2.52);
		float tintedGlass      = float(mat > 2.23 && mat < 2.27);
		float ice      		   = float(mat > 2.48 && mat < 2.52);
		float netherportal 	   = float(mat > 2.98 && mat < 3.02);
		float moddedfluid  	   = float(mat > 3.98 && mat < 5.02);
		float moddedfluidX     = float(mat > 4.98 && mat < 5.02);
		
		#ifndef REFLECTION_TRANSLUCENT
			translucent = 0.0;
		#endif

		vec3 screenPos = vec3(gl_FragCoord.xy / vec2(viewWidth, viewHeight), gl_FragCoord.z);
		#if AA > 1
			vec3 viewPos = ToNDC(vec3(TAAJitter(screenPos.xy, -0.5), screenPos.z));
		#else
			vec3 viewPos = ToNDC(screenPos);
		#endif
		worldPos = ToWorld(viewPos);
		float lViewPos = length(viewPos);

		vec3 nViewPos = normalize(viewPos.xyz);
		float NdotU = dot(nViewPos, upVec);

		vec3 normalMap = vec3(0.0, 0.0, 1.0);
		
		mat3 tbnMatrix = mat3(tangent.x, binormal.x, normal.x,
							  tangent.y, binormal.y, normal.y,
							  tangent.z, binormal.z, normal.z);

		if (water + moddedfluidX > 0.5) {
			#ifdef WATER_REFRACT
				waterMask = 1.0;
			#endif

			float halfNdotUish = abs(dot(newNormal, upVec));
			waterBump *= 0.25 + 0.75 * halfNdotUish;

			normalMap = GetWaterNormal(worldPos, nViewPos, viewVector, lViewPos);
			newNormal = clamp(normalize(normalMap * tbnMatrix), vec3(-1.0), vec3(1.0));
		}

		#ifdef ADV_MAT
			#if defined NORMAL_MAPPING && !defined COMPBR
				if (water < 0.5) {
					vec2 newCoord = vTexCoord.st * vTexCoordAM.pq + vTexCoordAM.st;
					normalMap = texture2DGradARB(normals, newCoord, dcdx, dcdy).xyz;
					normalMap += vec3(0.5, 0.5, 0.0);
					normalMap = pow(normalMap, vec3(NORMAL_MULTIPLIER));
					normalMap -= vec3(0.5, 0.5, 0.0);
					#if RP_SUPPORT == 4
						normalMap = normalMap * 2.0 - 1.0;
					#else
						normalMap = normalMap * 2.0 - 1.0;
						float normalCheck = normalMap.x + normalMap.y;
						if (normalCheck > -1.999) {
							if (length(normalMap.xy) > 1.0) normalMap.xy = normalize(normalMap.xy);
							normalMap.z = sqrt(1.0 - dot(normalMap.xy, normalMap.xy));
							normalMap = normalize(clamp(normalMap, vec3(-1.0), vec3(1.0)));
						} else {
							normalMap = vec3(0.0, 0.0, 1.0);
						}
					#endif

					if (normalMap.x > -0.999 && normalMap.y > -0.999)
						newNormal = clamp(normalize(normalMap * tbnMatrix), vec3(-1.0), vec3(1.0));
				}
			#endif
			#if defined COMPBR && defined EMISSIVE_NETHER_PORTAL
					if (netherportal > 0.5) emissive = 0.25, albedo.r *= 1.5, albedo.a *= max(pow(albedo.r, 8.0), 0.025), lightmap = vec2(0.0);
			#endif
		#endif
		
		if (moddedfluidX > 0.5) albedo = texture2DLod(texture, texCoord, 100.0) * vec4(color.rgb, 1.0);

    	if (water < 0.5) albedo.rgb = pow(albedo.rgb, vec3(2.2));

		float fresnel = clamp(1.0 + dot(newNormal, nViewPos), 0.0, 1.0);
		float fresnel2 = fresnel * fresnel;
		float fresnel4 = fresnel2 * fresnel2;

		#if SKY_REF_FIX_1 == 1
			float skyRefFactor = lightmap.y * lightmap.y * 1.0;
		#elif SKY_REF_FIX_1 == 2
			float skyRefFactor = max(lightmap.y - 0.80, 0.0) * 5.0;
		#else
			float skyRefFactor = max(lightmap.y - 0.99, 0.0) * 100.0;
		#endif

		float difT = 0.0;
		if (water > 0.5) {	
			#if WATER_TYPE == 0
				vec3 customWaterColor = vec3(waterColor.rgb * waterColor.rgb * 3.0 * waterColor.a);

				#if MC_VERSION >= 11300
					vec3 vanillaWaterColor = pow(color.rgb, vec3(2.2)) * waterColor.a;
					vec3 combinedWaterColor = customWaterColor * (1 - WATER_V) + vanillaWaterColor * WATER_V;
					albedo.a = waterAlpha;
					if (isEyeInWater == 1) albedo.a = 1.0 - pow2(pow2(1.0 - albedo.a * min(fresnel2, 1.0)));
				#else
					vec3 combinedWaterColor = customWaterColor;
					albedo.a = 0.5;
				#endif

				albedo.rgb = combinedWaterColor;
			#endif
			
			#if WATER_TYPE == 1
				albedo.rgb = pow(albedo.rgb, vec3(2.2)) * 0.7;
				albedo.a *= 1.0 - pow2(1.0 - WATER_OPACITY);
			#endif
			
			#if WATER_TYPE == 2
				albedo.a *= length(albedo.rgb) * WATER_OPACITY * 1.5;
				float albedoPRTX = pow2(albedoP.r * albedoP.r);
				albedo.rgb = waterColor.rgb * albedoPRTX + 0.5 * waterColor.rgb * albedoPRTX;
				albedo.rgb = mix(albedo.rgb, albedo.rgb * color.rgb, 0.5);
				if (WATER_OPACITY > 0.82) albedo.rgb = min(albedo.rgb * (1.0 + length(albedo.rgb) * pow(WATER_OPACITY, 32.0) * 50.0), vec3(2.0));
				if (isEyeInWater == 1) albedo.a = 0.5;
			#endif

			if (isEyeInWater == 0) {
				vec2 texCoordT = gl_FragCoord.xy / vec2(viewWidth, viewHeight);
				float depthT = texture2D(depthtex1, texCoordT).r;
				vec3 screenPosT = vec3(texCoordT, depthT);
				#if AA > 1
					vec3 viewPosT = ToNDC(vec3(TAAJitter(screenPosT.xy, -0.5), screenPosT.z));
				#else
					vec3 viewPosT = ToNDC(screenPosT);
				#endif
				difT = (length(viewPosT) - lViewPos);
				albedo.a = GetWaterOpacity(albedo.a, difT, fresnel, lViewPos);
			}
		}

		#ifdef WHITE_WORLD
			albedo.rgb = vec3(0.5);
		#endif

		if (water < 0.5 || isEyeInWater == 0) vlAlbedo = mix(vec3(1.0), albedo.rgb, sqrt1(albedo.a)) * (1.0 - pow(albedo.a, 64.0));

		float NdotL = clamp(dot(newNormal, lightVec) * 1.01 - 0.01, 0.0, 1.0);

		float quarterNdotU = clamp(0.25 * dot(newNormal, upVec) + 0.75, 0.5, 1.0);
			  quarterNdotU*= quarterNdotU;

		float parallaxShadow = 1.0;
		float materialAO = 1.0;

		float subsurface = 0.0;
		#if SHADOW_SUBSURFACE == 2
			if (translucent > 0.5 && ice < 0.5) {
				subsurface = 1.0 - albedo.a;
			}
		#endif
		
		float shadow = 0.0;
		vec3 lightAlbedo = vec3(0.0);
		GetLighting(albedo.rgb, shadow, lightAlbedo, viewPos, lViewPos, worldPos, lightmap, color.a, NdotL, quarterNdotU,
				    parallaxShadow, emissive, subsurface, 0.0, materialAO);
		
		float dither = Bayer64(gl_FragCoord.xy);

		#ifdef OVERWORLD
			//offset because consistency
					vec3 lightME = mix(lightMorning, lightEvening, mefade);
					vec3 lightDayTint = lightDay * lightME * LIGHT_DI;
					vec3 lightDaySpec = mix(lightME, sqrt(lightDayTint), timeBrightness);
					vec3 specularColor = mix(sqrt(lightNight*0.3),
												lightDaySpec,
												sunVisibility);
					#ifdef WATER_CAUSTICS
						if (isEyeInWater == 1) specularColor *= underwaterColor.rgb * 8.0;
					#endif
					specularColor *= specularColor;
		#endif
		#if defined SEVEN || defined SEVEN_2
			vec3 specularColor = vec3(0.005, 0.006, 0.018);
		#endif
	
		float fresnelRT = fresnel;

		if (water > 0.5 || moddedfluid > 0.5 || (translucent > 0.5 && albedo.a < 0.95)) {
			vec4 reflection = vec4(0.0);
			vec3 skyReflection = vec3(0.0);

			fresnel = fresnel4 * 0.95 + 0.05;
			fresnel *= max(1.0 - isEyeInWater * 0.5 * water, 0.5);
			fresnel *= 1.0 - translucent * (1.0 - albedo.a);

			#ifdef REFLECTION
				vec3 refNormal = mix(newNormal, normal, pow2(pow2(fresnel4)));
				reflection = SimpleReflection(viewPos, refNormal, dither, fresnelRT);
			#endif
			
			#ifdef WATER_TRANSLUCENT_SKY_REF
				if (reflection.a < 1.0) {
					vec3 skyReflectionPos = reflect(nViewPos, newNormal);
					float refNdotU = dot(skyReflectionPos, upVec);

					#ifdef OVERWORLD
						vec3 gotTheSkyColor = vec3(0.0);
						if (isEyeInWater == 0) gotTheSkyColor = GetSkyColor(lightCol, refNdotU, skyReflectionPos, true);
						if (isEyeInWater == 1) gotTheSkyColor = 0.6 * pow(underwaterColor.rgb * (1.0 - blindFactor), vec3(2.0));
						skyReflection = gotTheSkyColor;
					#endif
					skyReflectionPos *= 1000000.0;
					#ifdef OVERWORLD
						float specular = 0.0;
						if (water > 0.5) {
							#if WATER_TYPE == 2
								float smoothnessRTX = albedoP.r * 0.8;
								smoothnessRTX *= smoothnessRTX;
								specular = (0.15 + 0.85 * sunVisibility) * GGX(newNormal, nViewPos, lightVec, smoothnessRTX, 0.02, 0.025 * sunVisibility + 0.05);
								if (waterBump >= 0.275) specular += stylisedGGX(newNormal, normal, nViewPos, lightVec, 0.0);
							#else
								if (waterBump >= 0.275) specular = stylisedGGX(newNormal, normal, nViewPos, lightVec, 0.0);
							#endif
						}
						#ifdef COMPBR
							if (ice > 0.5) {
								float smoothnessIce = length(albedoP.rgb);
								smoothnessIce = pow2(pow2(smoothnessIce)) * 0.12;
								specular = GGX(newNormal, nViewPos, lightVec, smoothnessIce, 0.02, 0.025 * sunVisibility + 0.05);
							}
						#endif
						specular *= sqrt1inv(rainStrengthS);
						#ifdef SHADOWS
							specular *= shadowFade;
						#endif

						skyReflection *= skyRefFactor;
						#if defined CLOUDS || defined AURORA
							float cosT = dot(normalize(skyReflectionPos), upVec);
							#ifdef AURORA
								skyReflection += skyRefFactor * DrawAurora(skyReflectionPos, dither, 4, cosT);
							#endif
							float cloudFactor = 1.0;
							#ifdef CLOUDS
								if (isEyeInWater == 0) {
									vec4 cloud = DrawCloud(skyReflectionPos, dither, lightCol, ambientCol, cosT, 3);
									skyReflection = mix(skyReflection, cloud.rgb*skyRefFactor, cloud.a);
								}
							#endif
						#endif
						skyReflection += (specular / fresnel) * specularColor * shadow * lightmap.y * lightmap.y * lightmap.y;
					#endif

					#ifdef NETHER
						skyReflection = netherCol * 0.005;
					#endif

					#if defined END || defined SEVEN || defined SEVEN_2
						#if defined END
							skyReflection = endCol * 0.125;
							#if defined ENDER_NEBULA && !defined COMPATIBILITY_MODE
								vec3 enderNebula = DrawEnderNebula(skyReflectionPos * 100.0, dither, endCol, true);
								skyReflection = enderNebula * shadow * 0.5;
							#endif
						#endif
						#if (defined SEVEN || defined SEVEN_2) && !defined TWENTY
							vec3 twilightPurple = vec3(0.005, 0.006, 0.018);
							vec3 twilightGreen = vec3(0.015, 0.03, 0.02);
							skyReflection = 2 * (twilightPurple * 2 * clamp(pow(refNdotU, 0.7), 0.0, 1.0) + twilightGreen * (1-clamp(pow(refNdotU, 0.7), 0.0, 1.0)));
							skyReflection *= lmCoord.y * float(isEyeInWater == 0);
						#endif
						
						float specular = GGX(newNormal, nViewPos, lightVec, 0.4, 0.02, 0.025 * sunVisibility + 0.05);
					#endif

					#ifdef TWENTY
						vec3 twilightGreen = vec3(0.015, 0.03, 0.02);
						vec3 twilightPurple = twilightGreen * 0.1;
						skyReflection = 2 * (twilightPurple * 2 * clamp(pow(refNdotU, 0.7), 0.0, 1.0) + twilightGreen * (1-clamp(pow(refNdotU, 0.7), 0.0, 1.0)));
						if (isEyeInWater > 0.5) skyReflection = pow(underwaterColor.rgb * (1.0 - blindFactor), vec3(2.0)) * fresnel;
						skyReflection *= pow2(lightmap.y * lightmap.y);
					#endif
				}
			#endif

			reflection.rgb = max(mix(skyReflection, reflection.rgb, reflection.a), vec3(0.0));
			
			albedo.rgb = mix(albedo.rgb, reflection.rgb, fresnel);
		}

		if (tintedGlass > 0.5) {
			albedo.a = sqrt2(albedo.a);
		}

		vec3 extra = viewPos.xyz;
		#if defined NETHER && defined NETHER_SMOKE
			extra = DrawNetherSmoke(viewPos.xyz, dither, pow((netherCol * 2.5) / NETHER_I, vec3(2.2)) * 4);
		#endif

		albedo.rgb = startFog(albedo.rgb, nViewPos, lViewPos, worldPos, extra, NdotU);

		#ifdef SHOW_LIGHT_LEVELS
			if (lmCoord.x < 0.5 && quarterNdotU > 0.99 && (mat < 0.95 || mat > 1.05) && translucent < 0.5) {
				float showLightLevelFactor = fract(frameTimeCounter);
				if (showLightLevelFactor > 0.5) showLightLevelFactor = 1 - showLightLevelFactor;
				albedo.rgb += vec3(0.5, 0.0, 0.0) * showLightLevelFactor;
			}
		#endif
	} else albedo.a = 0.0;

	//albedo.rgb = newNormal + 0.1;

	#ifdef GBUFFER_CODING
		albedo.rgb = vec3(85.0, 255.0, 255.0) / 255.0;
		albedo.rgb = pow(albedo.rgb, vec3(2.2)) * 0.5;
	#endif

    /* DRAWBUFFERS:01 */
    gl_FragData[0] = albedo;
	gl_FragData[1] = vec4(vlAlbedo, 1.0);

	#ifdef WATER_REFRACT
	/* DRAWBUFFERS:014 */
	gl_FragData[2] = vec4(0.0, waterMask, 0.0, 1.0);
	#endif
}

#endif

//////////Vertex Shader//////////Vertex Shader//////////Vertex Shader//////////
#ifdef VSH

//Uniforms//
uniform int worldTime;

uniform float frameTimeCounter;
uniform float timeAngle;

uniform vec3 cameraPosition;

uniform mat4 gbufferModelView, gbufferModelViewInverse;

#if AA > 1
uniform int frameCounter;

uniform float viewWidth, viewHeight;
#endif

#if defined FOG1 && defined FOG1_CHECK
uniform float far;
#endif

//Attributes//
attribute vec4 mc_Entity;
attribute vec4 mc_midTexCoord;
attribute vec4 at_tangent;

//Common Variables//
#if WORLD_TIME_ANIMATION >= 2
float frametime = float(worldTime) * 0.05 * ANIMATION_SPEED;
#else
float frametime = frameTimeCounter * ANIMATION_SPEED;
#endif

//Common Functions//
#ifdef OVERWORLD
	float timeAngleM = timeAngle;
#else
	#if !defined SEVEN && !defined SEVEN_2
		float timeAngleM = 0.25;
	#else
		float timeAngleM = 0.5;
	#endif
#endif

//Includes//
float wavingTime = frametime * WAVING_SPEED;

const float PI = 3.1415927;
float pi2wt = 6.2831854 * (wavingTime * 24.0);

vec3 calcWave(vec3 pos, float fm, float mm, float ma, float f0, float f1, float f2, float f3, float f4, float f5) {
    vec3 ret;
    float magnitude, d0, d1, d2, d3;
    magnitude = sin(pi2wt * fm + pos.x*0.5 + pos.z*0.5 + pos.y*0.5) * mm + ma;
    d0 = sin(pi2wt * f0);
    d1 = sin(pi2wt * f1);
    d2 = sin(pi2wt * f2);
    ret.x = sin(pi2wt*f3 + d0 + d1 - pos.x + pos.z + pos.y) * magnitude;
    ret.z = sin(pi2wt*f4 + d1 + d2 + pos.x - pos.z + pos.y) * magnitude;
    ret.y = sin(pi2wt*f5 + d2 + d0 + pos.z + pos.y - pos.y) * magnitude;
    return ret;
}

vec3 calcMove(in vec3 pos, float f0, float f1, float f2, float f3, float f4, float f5, vec3 amp1, vec3 amp2) {
    vec3 move1 = calcWave(pos      , 0.0027, 0.0400, 0.0400, 0.0127, 0.0089, 0.0114, 0.0063, 0.0224, 0.0015) * amp1;
    vec3 move2 = calcWave(pos+move1, 0.0348, 0.0400, 0.0400, f0, f1, f2, f3, f4, f5) * amp2;
    vec3 returner = move1 + move2;
    #ifndef DO_WAVING_UNDERGROUND
        returner *= float(lmCoord.y > 0.9);
    #endif
    return returner;
}

float calcLilypadMove(vec3 worldpos) {
    float wave = sin(2 * PI * (wavingTime*0.7 + worldpos.x * 0.14 + worldpos.z * 0.07))
                + sin(2 * PI * (wavingTime*0.5 + worldpos.x * 0.10 + worldpos.z * 0.20));
    #ifndef DO_WAVING_UNDERGROUND
        wave *= lmCoord.y;
    #endif
    return wave * 0.0125;
}

vec3 WavingBlocks(vec3 position, float istopv) {
    vec3 wave = vec3(0.0);
    vec3 worldpos = position + cameraPosition;

    #ifdef WAVING_CROPS
    if (mc_Entity.x == 59 && (istopv > 0.9 || fract(worldpos.y + 0.0675) > 0.01)) { // Crops
        if (length(position) < 2.0) wave.xz += position.xz*max(5.0/pow(max(length(position*vec3(8.0,2.0,8.0)-vec3(0.0,2.0,0.0)),2.0),1.0)-0.625,0.0);
        wave += calcMove(worldpos, 0.0041, 0.0070, 0.0044, 0.0038, 0.0240, 0.0000, vec3(0.4,0.0,0.4), vec3(0.2,0.0,0.2));
    }
    if (mc_Entity.x == 104 && (istopv > 0.9 || fract(worldpos.y + 0.0675) > 0.01)) { // Stems
        wave += calcMove(worldpos, 0.0041, 0.0070, 0.0044, 0.0038, 0.0240, 0.0000, vec3(0.1,0.4,0.1), vec3(0.05,0.2,0.05));
	}
    #endif
    #ifdef WAVING_FOLIAGE
    if (mc_Entity.x == 31 && istopv > 0.9) { // Foliage
        if (length(position) < 2.0) wave.xz += position.xz*max(5.0/pow(max(length(position*vec3(8.0,2.0,8.0)-vec3(0.0,2.0,0.0)),2.0),1.0)-0.625,0.0);
        wave += calcMove(worldpos, 0.0041, 0.0070, 0.0044, 0.0038, 0.0063, 0.0000, vec3(0.8,0.0,0.8), vec3(0.4,0.0,0.4));
    }
    if (mc_Entity.x == 175 || (mc_Entity.x == 176.0 && (istopv > 0.9 || fract(worldpos.y+0.005)>0.01))) { // Double Plants
        wave += calcMove(worldpos, 0.0041, 0.005, 0.0044, 0.0038, 0.0240, 0.0000, vec3(0.8,0.1,0.8), vec3(0.4,0.0,0.4));
	}
    if (mc_Entity.x == 6 && (istopv > 0.9 || fract(worldpos.y + 0.005) > 0.01)) { // Plants
        wave += calcMove(worldpos, 0.0041, 0.005, 0.0044, 0.0038, 0.0240, 0.0000, vec3(0.6,0.0,0.6), vec3(0.3,0.0,0.3));
	}
    #endif
    #ifdef WAVING_LEAVES
    if (mc_Entity.x == 18) // Leaves
        wave += calcMove(worldpos, 0.0040, 0.0064, 0.0043, 0.0035, 0.0037, 0.0041, vec3(0.5,0.5,0.5), vec3(0.25,0.25,0.25));
    #endif
    #ifdef WAVING_VINES
    if (mc_Entity.x == 9600) // Vines
        wave += calcMove(worldpos, 0.0040, 0.0064, 0.0043, 0.0035, 0.0037, 0.0041, vec3(0.25,0.5,0.25), vec3(0.125,0.25,0.125));
    #endif
    #ifdef WAVING_LILY_PADS
    if (mc_Entity.x == 9100) // Lily Pads
        wave.y += calcLilypadMove(worldpos);
    #endif

    #ifdef WAVING_EVERYTHING
        wave += calcWave(worldpos, 0.0027, 0.0400, 0.0400, 0.0127, 0.0089, 0.0114, 0.0063, 0.0224, 0.0015);
    #endif

    return wave;
}

float WavingWater(vec3 worldPos) {
	float fractY = fract(worldPos.y + cameraPosition.y + 0.005);
	worldPos += cameraPosition.xyz;

    float waterWaveTime = frametime * WATER_SPEED * 0.8;
	
	float wave = sin(6.28 * (waterWaveTime * 0.7 + worldPos.x * 0.14 + worldPos.z * 0.07)) +
				sin(6.28 * (waterWaveTime * 0.5 + worldPos.x * 0.10 + worldPos.z * 0.20));
	if (fractY > 0.01) return wave * 0.0125;
	else return 0.0;
}

#if AA == 2 || AA == 3
//Jitter offset from Chocapic13
uniform float framemod8;

vec2 jitterOffsets[8] = vec2[8]( // LiteTAA Jitter
							vec2( 0.125,-0.375),
							vec2(-0.125, 0.375),
							vec2( 0.625, 0.125),
							vec2( 0.375,-0.625),
							vec2(-0.625, 0.625),
							vec2(-0.875,-0.125),
							vec2( 0.375,-0.875),
							vec2( 0.875, 0.875)
						);
							   
vec2 TAAJitter(vec2 coord, float w) {
	vec2 offset = jitterOffsets[int(framemod8)] *0.125* (w / vec2(viewWidth, viewHeight));
	return coord + offset;
}
#endif
#if AA == 4
//Jitter offset from Chocapic13
uniform float framemod8;

vec2 jitterOffsets[8] = vec2[8](
							vec2( 0.125,-0.375),
							vec2(-0.125, 0.375),
							vec2( 0.625, 0.125),
							vec2( 0.375,-0.625),
							vec2(-0.625, 0.625),
							vec2(-0.875,-0.125),
							vec2( 0.375,-0.875),
							vec2( 0.875, 0.875)
						);
							   
vec2 TAAJitter(vec2 coord, float w) {
	vec2 offset = jitterOffsets[int(framemod8)] * (w / vec2(viewWidth, viewHeight));
	return coord + offset;
}
#endif

#ifdef WORLD_CURVATURE
float WorldCurvature(vec2 pos) {
    #if defined END
        float curvature = dot(pos, pos) / END_CURVATURE_SIZE;
        #if END_CURVATURE_SIZE == 999999
            curvature *= 0.0;
        #endif
    #elif defined NETHER
        float curvature = dot(pos, pos) / NETHER_CURVATURE_SIZE;
        #if NETHER_CURVATURE_SIZE == 999999
            curvature *= 0.0;
        #endif
    #else
        float curvature = dot(pos, pos) / OVERWORLD_CURVATURE_SIZE;
        #if OVERWORLD_CURVATURE_SIZE == 999999
            curvature *= 0.0;
        #endif
    #endif

    return curvature;
}
#endif

//Program//
void main() {
	vec4 position = gbufferModelViewInverse * gl_ModelViewMatrix * gl_Vertex;

	#if defined FOG1 && defined FOG1_CHECK
		float lWorldPos = length(position.xz) * 1;
		float fog = lWorldPos / far * 1.5 * (10/FOG1_DISTANCE);
		fog = 1.0 - exp(-0.1 * pow(fog, 10.0));
		if (fog > 0.9) {
			gl_Position = vec4(0.0, 0.0, 1000.0, 0.0);
			return;
		}
	#endif

	texCoord = (iris_TextureMat * gl_MultiTexCoord0).xy;
    
	lmCoord = (iris_LightmapTextureMatrix * gl_MultiTexCoord1).xy;

	normal   = normalize(gl_NormalMatrix * gl_Normal);
	binormal = normalize(gl_NormalMatrix * cross(at_tangent.xyz, gl_Normal.xyz) * at_tangent.w);
	tangent  = normalize(gl_NormalMatrix * at_tangent.xyz);
	
	mat3 tbnMatrix = mat3(tangent.x, binormal.x, normal.x,
						  tangent.y, binormal.y, normal.y,
						  tangent.z, binormal.z, normal.z);
								  
	viewVector = tbnMatrix * (gl_ModelViewMatrix * gl_Vertex).xyz;

	#if defined ADV_MAT && defined NORMAL_MAPPING && !defined COMPBR
		vec2 midCoord = (iris_TextureMat *  mc_midTexCoord).st;
		vec2 texMinMidCoord = texCoord - midCoord;

		vTexCoordAM.pq  = abs(texMinMidCoord) * 2;
		vTexCoordAM.st  = min(texCoord, midCoord - texMinMidCoord);
		
		vTexCoord.xy    = sign(texMinMidCoord) * 0.5 + 0.5;
	#endif
    
	color = gl_Color;
	
	mat = 0.0;
	
	if (mc_Entity.x == 79) mat = 2.0;   // Translucent
	if (mc_Entity.x == 7978) mat = 2.25;   // Tinted Glass
	if (mc_Entity.x == 7979) mat = 2.5; // Ice
	#if defined COMPBR && defined EMISSIVE_NETHER_PORTAL
		if (mc_Entity.x == 80) mat = 3.0;
	#endif

	const vec2 sunRotationData = vec2(cos(sunPathRotation * 0.01745329251994), -sin(sunPathRotation * 0.01745329251994));
	float ang = fract(timeAngleM - 0.25);
	ang = (ang + (cos(ang * 3.14159265358979) * -0.5 + 0.5 - ang) / 3.0) * 6.28318530717959;
	sunVec = normalize((gbufferModelView * vec4(vec3(-sin(ang), cos(ang) * sunRotationData) * 2000.0, 1.0)).xyz);

	upVec = normalize(gbufferModelView[1].xyz);
	
	float istopv = gl_MultiTexCoord0.t < mc_midTexCoord.t ? 1.0 : 0.0;
	if (mc_Entity.x == 8) {   // Water
		#ifndef COMPATIBILITY_MODE
			lmCoord.x *= 0.6;
		#endif
		#ifdef WATER_DISPLACEMENT
			position.y += WavingWater(position.xyz);
		#endif
		mat = 1.0;
	}
	if (mc_Entity.x == 888) { // Modded Fluid With Vanilla Texture
		mat = 4.0;
	}
	if (mc_Entity.x == 889) { // Modded Fluid With Water Waves And No Texture
		#ifdef WATER_DISPLACEMENT
			position.y += WavingWater(position.xyz);
		#endif
		mat = 5.0;
	}

    #ifdef WORLD_CURVATURE
		position.y -= WorldCurvature(position.xz);
    #endif

	gl_Position = gl_ProjectionMatrix * gbufferModelView * position;
	if (mat == 0.0) {
		gl_Position.z -= 0.00001;
		lmCoord = (lmCoord - 0.03125) * 1.06667;
	} else {
		lmCoord.y = (lmCoord.y - 0.03125) * 1.06667;
		lmCoord.x = smoothstep(0.0, 1.0, pow((lmCoord.x - 0.03125) * 0.55, 0.35));
	}
	lmCoord = clamp(lmCoord, vec2(0.0), vec2(1.0));
	
	#if AA > 1
		gl_Position.xy = TAAJitter(gl_Position.xy, gl_Position.w);
	#endif
}

#endif

