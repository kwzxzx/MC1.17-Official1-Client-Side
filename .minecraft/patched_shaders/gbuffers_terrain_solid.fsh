#version 150 core
#define MC_GL_NV_vertex_buffer_unified_memory

#define MC_GL_EXT_texture_filter_anisotropic

#define MC_GL_KHR_shader_subgroup

#define MC_GL_NV_gpu_program_fp64

#define MC_GL_ARB_timer_query

#define MC_GL_NV_register_combiners

#define MC_GL_NV_half_float

#define MC_GL_ARB_framebuffer_sRGB

#define MC_GL_ARB_texture_gather

#define MC_GL_NV_geometry_shader4

#define MC_GL_EXT_texture_edge_clamp

#define MC_GL_NV_multisample_filter_hint

#define MC_GL_VENDOR_NVIDIA

#define MC_GL_ARB_texture_rgb10_a2ui

#define MC_GL_ARB_transpose_matrix

#define MC_GL_ARB_texture_stencil8

#define MC_GL_NV_framebuffer_multisample_coverage

#define MC_GL_NV_conditional_render

#define MC_GL_NV_copy_image

#define MC_GL_ARB_vertex_buffer_object

#define MC_GL_EXT_direct_state_access

#define MC_GL_EXT_texture_object

#define MC_GL_ARB_window_pos

#define MC_GL_NV_gpu_shader5

#define MC_GL_KHR_parallel_shader_compile

#define MC_GL_ARB_point_parameters

#define MC_GL_ARB_draw_buffers_blend

#define MC_GL_EXT_semaphore

#define MC_GL_EXT_vertex_array_bgra

#define MC_GL_EXT_blend_func_separate

#define MC_GL_EXT_texture_compression_dxt1

#define MC_GL_EXT_compiled_vertex_array

#define MC_GL_EXT_blend_minmax

#define MC_GL_EXT_pixel_buffer_object

#define MC_GL_NV_shader_atomic_float64

#define MC_GL_NV_clip_space_w_scaling

#define MC_GL_NV_conservative_raster_pre_snap_triangles

#define MC_GL_ARB_shader_image_size

#define MC_GL_NV_texgen_reflection

#define MC_GL_ARB_sparse_texture2

#define MC_GL_ARB_bindless_texture

#define MC_GL_ARB_texture_buffer_object_rgb32

#define MC_GL_ARB_get_program_binary

#define MC_GL_NV_shader_subgroup_partitioned

#define MC_GL_EXTX_framebuffer_mixed_formats

#define MC_GL_EXT_shader_image_load_formatted

#define MC_GL_ARB_texture_rectangle

#define MC_GL_ARB_shading_language_100

#define MC_GL_ARB_debug_output

#define MC_GL_NV_shader_atomic_fp16_vector

#define MC_GL_NV_packed_depth_stencil

#define MC_GL_NV_conservative_raster

#define MC_GL_ARB_vertex_program

#define MC_GL_ARB_fragment_coord_conventions

#define MC_GL_ARB_compute_variable_group_size

#define MC_GL_EXT_framebuffer_blit

#define MC_GL_EXT_fog_coord

#define MC_GL_ARB_shading_language_packing

#define MC_GL_ARB_texture_filter_anisotropic

#define MC_GL_NVX_blend_equation_advanced_multi_draw_buffers

#define MC_GL_EXT_packed_float

#define MC_GL_NV_fragment_program_option

#define MC_GL_VERSION 320

#define MC_GL_ARB_texture_barrier

#define MC_VERSION 11700

#define MC_GL_ARB_buffer_storage

#define MC_GL_NVX_linked_gpu_multicast

#define MC_GL_NV_blend_square

#define MC_GL_EXT_shadow_funcs

#define MC_GL_NV_copy_depth_to_color

#define MC_GL_EXT_multiview_texture_multisample

#define MC_GL_ARB_shader_precision

#define MC_GL_ARB_shader_atomic_counter_ops

#define MC_GL_EXT_texture_env_combine

#define MC_GL_EXT_point_parameters

#define MC_OS_WINDOWS

#define MC_GL_EXT_semaphore_win32

#define MC_GL_ARB_texture_border_clamp

#define MC_GL_ARB_sparse_buffer

#define MC_GL_ARB_vertex_attrib_64bit

#define MC_GL_NV_fill_rectangle

#define MC_GL_ARB_cull_distance

#define MC_GL_NV_fragment_shader_interlock

#define MC_GL_ARB_texture_env_add

#define MC_GL_EXT_depth_bounds_test

#define MC_GL_ARB_fragment_layer_viewport

#define MC_GL_ARB_conditional_render_inverted

#define MC_GL_EXT_provoking_vertex

#define MC_GL_NV_vertex_attrib_integer_64bit

#define MC_GL_NV_shader_atomic_float

#define MC_GL_ARB_texture_query_lod

#define MC_GL_NV_stereo_view_rendering

#define MC_GL_ARB_map_buffer_alignment

#define MC_GL_NV_path_rendering

#define MC_GL_ARB_gl_spirv

#define MC_GL_NV_ES1_1_compatibility

#define MC_GL_NV_geometry_shader_passthrough

#define MC_GL_ARB_pipeline_statistics_query

#define MC_GL_EXT_bindable_uniform

#define MC_GL_ARB_shader_image_load_store

#define MC_GL_ARB_separate_shader_objects

#define MC_GL_NV_fog_distance

#define MC_GL_NV_shader_buffer_load

#define MC_GL_NV_vertex_program2

#define MC_GL_NV_texture_barrier

#define MC_GL_ARB_vertex_type_2_10_10_10_rev

#define MC_GL_NV_vertex_program3

#define MC_GL_EXT_texture_sRGB_R8

#define MC_GL_ARB_transform_feedback2

#define MC_GL_EXT_texture3D

#define MC_GL_ARB_transform_feedback3

#define MC_GL_ARB_shader_storage_buffer_object

#define MC_GL_ARB_arrays_of_arrays

#define MC_GL_NV_register_combiners2

#define MC_GL_EXT_texture_shadow_lod

#define MC_GL_EXT_packed_depth_stencil

#define MC_GL_ARB_texture_compression_rgtc

#define MC_GL_EXT_geometry_shader4

#define MC_GLSL_VERSION 150

#define MC_GL_NV_texture_rectangle_compressed

#define MC_GL_EXT_separate_specular_color

#define MC_GL_ARB_shader_bit_encoding

#define MC_GL_EXT_draw_instanced

#define MC_GL_EXT_blend_equation_separate

#define MC_GL_ARB_occlusion_query2

#define MC_GL_ARB_half_float_vertex

#define MC_GL_NV_blend_equation_advanced_coherent

#define MC_GL_NV_texture_rectangle

#define MC_GL_EXT_texture_storage

#define MC_GL_ARB_texture_rg

#define MC_GL_EXT_polygon_offset_clamp

#define MC_GL_NV_shader_atomic_counters

#define MC_GL_NV_alpha_to_coverage_dither_control

#define MC_GL_AMD_vertex_shader_layer

#define MC_GL_ARB_shader_texture_lod

#define MC_GL_NV_draw_texture

#define MC_GL_ARB_copy_image

#define MC_GL_ARB_framebuffer_object

#define MC_GL_EXT_raster_multisample

#define MC_GL_EXT_transform_feedback2

#define MC_GL_ARB_color_buffer_float

#define MC_GL_EXT_draw_range_elements

#define MC_GL_NV_compute_program5

#define MC_GL_ARB_texture_mirror_clamp_to_edge

#define MC_GL_ARB_robust_buffer_access_behavior

#define MC_GL_ARB_explicit_uniform_location

#define MC_GL_ARB_ES3_compatibility

#define MC_GL_ARB_half_float_pixel

#define MC_GL_ATI_draw_buffers

#define MC_GL_ARB_shader_ballot

#define MC_GL_NV_fence

#define MC_GL_EXT_separate_shader_objects

#define MC_GL_NV_primitive_restart

#define MC_GL_NV_feature_query

#define MC_GL_NV_transform_feedback2

#define MC_GL_EXT_texture_env_dot3

#define MC_GL_ARB_draw_buffers

#define MC_GL_EXT_import_sync_object

#define MC_GL_NV_texture_shader2

#define MC_GL_ARB_sparse_texture_clamp

#define MC_GL_ARB_compressed_texture_pixel_storage

#define MC_GL_NV_gpu_multicast

#define MC_GL_NV_blend_minmax_factor

#define MC_GL_ARB_texture_env_dot3

#define MC_GL_NV_texture_shader3

#define MC_GL_NV_path_rendering_shared_edge

#define MC_GL_KHR_no_error

#define MC_GL_NV_multisample_coverage

#define MC_GL_EXT_blend_subtract

#define MC_GL_EXT_sparse_texture2

#define MC_GL_NV_ES3_1_compatibility

#define MC_GL_EXT_secondary_color

#define MC_GL_EXT_memory_object

#define MC_GL_EXT_framebuffer_object

#define MC_GL_NV_texture_multisample

#define MC_GL_ARB_spirv_extensions

#define MC_GL_NV_sample_locations

#define MC_GL_ARB_viewport_array

#define MC_GL_ARB_transform_feedback_overflow_query

#define MC_GL_NV_occlusion_query

#define MC_GL_EXT_framebuffer_multisample

#define MC_GL_ARB_seamless_cubemap_per_texture

#define MC_GL_EXT_texture_compression_latc

#define MC_GL_NV_texture_compression_vtc

#define MC_GL_EXT_multiview_timer_query

#define MC_GL_S3_s3tc

#define MC_GL_ARB_vertex_shader

#define MC_GL_KHR_blend_equation_advanced

#define MC_GL_ARB_depth_texture

#define MC_GL_ARB_framebuffer_no_attachments

#define MC_GL_WIN_swap_hint

#define MC_GL_EXT_window_rectangles

#define MC_GL_ARB_shader_viewport_layer_array

#define MC_GL_EXT_texture_mirror_clamp

#define MC_GL_NV_parameter_buffer_object2

#define MC_GL_NV_vertex_program

#define MC_GL_ARB_sparse_texture

#define MC_GL_ARB_indirect_parameters

#define MC_GL_EXT_framebuffer_multisample_blit_scaled

#define MC_GL_ARB_invalidate_subdata

#define MC_GL_ARB_texture_swizzle

#define MC_GL_NV_viewport_swizzle

#define MC_GL_EXT_packed_pixels

#define MC_GL_AMD_multi_draw_indirect

#define MC_GL_ARB_polygon_offset_clamp

#define MC_GL_NV_conservative_raster_dilate

#define MC_GL_ARB_seamless_cube_map

#define MC_GL_ARB_geometry_shader4

#define MC_GL_EXT_texture_env_add

#define MC_GL_ARB_stencil_texturing

#define MC_GL_NV_shader_storage_buffer_object

#define MC_GL_ARB_compute_shader

#define MC_GL_ARB_shader_objects

#define MC_GL_NV_gpu_program4_1

#define MC_GL_ARB_multi_draw_indirect

#define MC_GL_ARB_parallel_shader_compile

#define MC_GL_EXT_texture_array

#define MC_GL_ARB_get_texture_sub_image

#define MC_GL_SUN_slice_accum

#define MC_GL_NV_vertex_array_range2

#define MC_GL_NV_gpu_program5_mem_extended

#define MC_GL_EXT_Cg_shader

#define MC_GL_NVX_gpu_multicast2

#define MC_GL_ARB_pixel_buffer_object

#define MC_GL_ARB_tessellation_shader

#define MC_GL_ARB_texture_cube_map_array

#define MC_GL_NV_memory_attachment

#define MC_GL_SGIX_shadow

#define MC_GL_EXT_memory_object_win32

#define MC_GL_ARB_vertex_array_bgra

#define MC_GL_NV_fragment_coverage_to_color

#define MC_GL_EXT_vertex_attrib_64bit

#define MC_GL_NVX_conditional_render

#define MC_GL_NVX_progress_fence

#define MC_GL_EXT_texture_lod_bias

#define MC_GL_EXT_rescale_normal

#define MC_GL_NV_uniform_buffer_unified_memory

#define MC_GL_NVX_multigpu_info

#define MC_GL_ARB_clear_buffer_object

#define MC_GL_EXT_win32_keyed_mutex

#define MC_GL_NV_vertex_program1_1

#define MC_GL_NV_query_resource_tag

#define MC_GL_ARB_transform_feedback_instanced

#define MC_GL_ARB_uniform_buffer_object

#define MC_GL_NV_float_buffer

#define MC_GL_KHR_blend_equation_advanced_coherent

#define MC_GL_EXT_texture_cube_map

#define MC_GL_ARB_conservative_depth

#define MC_GL_EXT_texture_shared_exponent

#define MC_GL_KHR_robust_buffer_access_behavior

#define MC_GL_IBM_rasterpos_clip

#define MC_GL_ARB_fragment_shader

#define MC_GL_ARB_ES2_compatibility

#define MC_GL_ARB_direct_state_access

#define MC_GL_ARB_draw_instanced

#define MC_GL_EXT_shader_image_load_store

#define MC_GL_ARB_gpu_shader_fp64

#define MC_GL_ARB_texture_buffer_object

#define MC_GL_NV_sample_mask_override_coverage

#define MC_GL_ARB_instanced_arrays

#define MC_GL_ARB_sync

#define MC_GL_ARB_sample_locations

#define MC_GL_NV_point_sprite

#define MC_GL_ARB_base_instance

#define MC_GL_ARB_texture_compression

#define MC_GL_ARB_gpu_shader5

#define MC_GL_NV_viewport_array2

#define MC_GL_EXT_blend_color

#define MC_GL_EXT_gpu_shader4

#define MC_GL_ARB_texture_query_levels

#define MC_GL_EXT_post_depth_coverage

#define MC_GL_ARB_texture_non_power_of_two

#define MC_GL_EXT_draw_buffers2

#define MC_GL_EXT_multi_draw_arrays

#define MC_GL_EXT_vertex_array

#define MC_GL_ARB_texture_filter_minmax

#define MC_GL_ARB_texture_buffer_range

#define MC_GL_ARB_shadow

#define MC_GL_ARB_clip_control

#define MC_GL_ARB_ES3_2_compatibility

#define MC_GL_ARB_shading_language_include

#define MC_GL_ARB_texture_compression_bptc

#define MC_GL_ARB_multisample

#define MC_GL_ARB_point_sprite

#define MC_GL_ARB_fragment_program

#define MC_GL_ARB_vertex_array_object

#define MC_GL_OVR_multiview2

#define MC_GL_EXT_texture_compression_rgtc

#define MC_WGL_EXT_swap_control

#define MC_GL_ARB_multitexture

#define MC_GL_OVR_multiview

#define MC_GL_ARB_clear_texture

#define MC_GL_NV_shader_thread_group

#define MC_GL_ARB_shader_subroutine

#define MC_GL_ARB_query_buffer_object

#define MC_GL_NV_parameter_buffer_object

#define MC_GL_ARB_ES3_1_compatibility

#define MC_GL_ARB_occlusion_query

#define MC_GL_ARB_draw_indirect

#define MC_GL_ARB_texture_view

#define MC_GL_ARB_internalformat_query

#define MC_GL_NV_draw_vulkan_image

#define MC_GL_NV_query_resource

#define MC_GL_EXT_texture_filter_minmax

#define MC_GL_NV_framebuffer_mixed_samples

#define MC_GL_KHR_robustness

#define MC_GL_EXT_texture_sRGB_decode

#define MC_GL_NVX_gpu_memory_info

#define MC_GL_ARB_shading_language_420pack

#define MC_GL_ATI_texture_mirror_once

#define MC_GL_EXT_texture_lod

#define MC_GL_EXT_framebuffer_sRGB

#define MC_GL_NV_texture_env_combine4

#define MC_GL_ARB_texture_multisample

#define MC_GL_ARB_sample_shading

#define MC_GL_ARB_draw_elements_base_vertex

#define MC_GL_EXT_gpu_program_parameters

#define MC_GL_KHR_context_flush_control

#define MC_GL_AMD_seamless_cubemap_per_texture

#define MC_GL_ARB_depth_buffer_float

#define MC_GL_NV_internalformat_sample_query

#define MC_GL_ARB_texture_storage

#define MC_GL_ARB_provoking_vertex

#define MC_GL_ARB_vertex_attrib_binding

#define MC_GL_ARB_texture_env_crossbar

#define MC_GL_ARB_fragment_program_shadow

#define MC_GL_NV_shader_atomic_int64

#define MC_GL_NV_explicit_multisample

#define MC_GL_NV_light_max_exponent

#define MC_GL_ARB_texture_float

#define MC_GL_ARB_texture_storage_multisample

#define MC_GL_ARB_blend_func_extended

#define MC_GL_KTX_buffer_region

#define MC_GL_ARB_fragment_shader_interlock

#define MC_GL_ARB_derivative_control

#define MC_GL_NV_blend_equation_advanced

#define MC_GL_ARB_depth_clamp

#define MC_GL_ARB_shader_atomic_counters

#define MC_GL_EXT_bgra

#define MC_GL_ARB_texture_cube_map

#define MC_GL_ARB_shader_texture_image_samples

#define MC_GL_NV_vertex_array_range

#define MC_GL_ARB_shader_draw_parameters

#define MC_GL_ARB_imaging

#define MC_GL_ARB_texture_mirrored_repeat

#define MC_GL_NV_fragment_program

#define MC_GL_NV_depth_buffer_float

#define MC_GL_EXT_texture_buffer_object

#define MC_GL_SGIX_depth_texture

#define MC_GL_ARB_vertex_type_10f_11f_11f_rev

#define MC_GL_EXT_texture_integer

#define MC_GL_EXT_texture_compression_s3tc

#define MC_GL_KHR_debug

#define MC_GL_ARB_robustness

#define MC_GL_EXT_shader_integer_mix

#define MC_GL_NV_fragment_program2

#define MC_GL_NV_pixel_data_range

#define MC_GL_EXT_timer_query

#define MC_GL_ARB_shader_group_vote

#define MC_GL_ARB_internalformat_query2

#define MC_GL_IBM_texture_mirrored_repeat

#define MC_GL_NV_bindless_multi_draw_indirect_count

#define MC_GL_NV_vertex_program2_option

#define MC_GL_ARB_sampler_objects

#define MC_GL_EXT_stencil_wrap

#define MC_GL_ARB_map_buffer_range

#define MC_GL_EXT_texture_swizzle

#define MC_GL_ARB_program_interface_query

#define MC_GL_ARB_enhanced_layouts

#define MC_GL_ARB_texture_env_combine

#define MC_GL_ARB_post_depth_coverage

#define MC_GL_ATI_texture_float

#define MC_GL_NV_command_list

#define MC_GL_SGIS_generate_mipmap

#define MC_GL_ARB_copy_buffer

#define MC_GL_NV_shader_thread_shuffle

#define MC_GL_NV_depth_clamp

#define MC_GL_AMD_vertex_shader_viewport_index

#define MC_GL_NVX_nvenc_interop

#define MC_GL_ARB_multi_bind

#define MC_GL_SGIS_texture_lod

#define MC_GL_ARB_shader_clock

#define MC_GL_EXT_abgr

#define MC_GL_NV_bindless_texture

#define MC_GL_NV_transform_feedback

#define MC_GL_EXT_stencil_two_side

#define MC_GL_NV_bindless_multi_draw_indirect

#define MC_GL_NV_texture_shader

#define MC_GL_RENDERER_GEFORCE

#define MC_GL_ARB_explicit_attrib_location

#define MC_GL_ARB_gpu_shader_int64

#define MC_GL_NV_gpu_program4

#define MC_GL_EXT_texture_sRGB

#define MC_GL_NV_gpu_program5

#define gl_FragData iris_FragData
#define varying in
#define gl_ModelViewProjectionMatrix (gl_ProjectionMatrix * gl_ModelViewMatrix)
#define gl_ModelViewMatrix (iris_ModelViewMat * _iris_internal_translate(iris_ChunkOffset))
#define gl_NormalMatrix mat3(transpose(inverse(gl_ModelViewMatrix)))
#define gl_Color (Color * iris_ColorModulator)
#define gl_ProjectionMatrix iris_ProjMat
#define gl_FogFragCoord iris_FogFragCoord

#extension GL_ARB_shader_texture_lod : enable

#define GBUFFERS_TERRAIN
#define OVERWORLD
#define FSH

uniform mat4 iris_LightmapTextureMatrix;
uniform mat4 iris_TextureMat;
uniform float iris_FogDensity;
uniform float iris_FogStart;
uniform float iris_FogEnd;
uniform vec4 iris_FogColor;

struct iris_FogParameters {
    vec4 color;
    float density;
    float start;
    float end;
    float scale;
};

iris_FogParameters iris_Fog = iris_FogParameters(iris_FogColor, iris_FogDensity, iris_FogStart, iris_FogEnd, 1.0 / (iris_FogEnd - iris_FogStart));

#define gl_Fog iris_Fog
in float iris_FogFragCoord;
uniform mat4 iris_ProjMat;
uniform vec4 iris_ColorModulator;
uniform mat4 iris_ModelViewMat;
uniform vec3 iris_ChunkOffset;
mat4 _iris_internal_translate(vec3 offset) {
    // NB: Column-major order
    return mat4(1.0, 0.0, 0.0, 0.0,
                0.0, 1.0, 0.0, 0.0,
                0.0, 0.0, 1.0, 0.0,
                offset.x, offset.y, offset.z, 1.0);
}
out vec4 iris_FragData[8];
vec4 texture2D(sampler2D sampler, vec2 coord) { return texture(sampler, coord); }
vec4 texture2D(sampler2D sampler, vec2 coord, float bias) { return texture(sampler, coord, bias); }
vec4 texture2DLod(sampler2D sampler, vec2 coord, float lod) { return textureLod(sampler, coord, lod); }
vec4 shadow2D(sampler2DShadow sampler, vec3 coord) { return vec4(texture(sampler, coord)); }
vec4 shadow2DLod(sampler2DShadow sampler, vec3 coord, float lod) { return vec4(textureLod(sampler, coord, lod)); }
/*
Complementary Shaders by EminGT, based on BSL Shaders by Capt Tatsu
*/

//Common//
/*
Complementary Shaders by EminGT, based on BSL Shaders by Capt Tatsu
*/

//Shader Options//

  #define SECRET 0 //[0]

//#define COMPATIBILITY_MODE
  #define RP_SUPPORT 1 //[1 2 3 4]
  #define GLOWING_ENTITY_FIX
  #define END_PORTAL_REWORK
  #define LIGHTNING_BOLTS_FIX
//#define NIGHT_TWILIGHT_FOREST
  #define LIGHT_LEAK_FIX
//#define SHOW_LIGHT_LEVELS
  #define ENTITY_NORMAL_FIX
  #define THE_FORBIDDEN_OPTION 0 //[0 1 2 3]
  #define WRONG_MIPMAP_FIX
  #define FLICKERING_FIX
  #define SKY_REF_FIX_1 2 //[1 2 3]
  #define OVERLAY_FIX
//#define SMOKEY_WATER_LIGHTSHAFTS
//#define MIN_LIGHT_EVERYWHERE
//#define FOG1_CHECK
//#define METALLIC_WORLD
//#define WAVING_EVERYTHING
//#define SQUARE_BLUR
//#define GBUFFER_CODING
//#define SHOW_RAY_TRACING
//#define RANDOM_BLOCKLIGHT
//#define OVERDRAW
  #define RAIN_REF_BIOME_CHECK
//#define RAIN_REF_FORCED

  #define AURORA_BIOME_CHECK
  #define AURORA_FULL_MOON_CHECK
  #define AURORA_HEIGHT 0.75 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00]

  #define WAVING_SPEED 1.00 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00]
//#define DO_WAVING_UNDERGROUND
//#define DO_WAVING_ON_COMPATIBILITY
  #define WAVING_FOLIAGE
//#define WAVING_LEAVES
  #define WAVING_CROPS
//#define WAVING_VINES
//#define WAVING_LILY_PADS

  #define NEBULA_COMPRESSION 0.00 //[-1.00 -0.95 -0.90 -0.85 -0.80 -0.75 -0.70 -0.65 -0.60 -0.55 -0.50 -0.45 -0.40 -0.35 -0.30 -0.25 -0.20 -0.15 -0.10 -0.05 0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define NEBULA_SMOOTHING 0.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define NEBULA_DISTRIBUTION 2.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0 8.2 8.4 8.6 8.8 9.0 9.2 9.4 9.6 9.8 10.0 10.2 10.4 10.6 10.8 11.0 11.2 11.4 11.6 11.8 12.0 12.2 12.4 12.6 12.8 13.0 13.2 13.4 13.6 13.8 14.0 14.2 14.4 14.6 14.8 15.0 15.2 15.4 15.6 15.8 16.0]
  #define NEBULA_SIZE 0.03 //[0.01 0.015 0.02 0.025 0.03 0.035 0.04 0.045 0.05 0.055 0.06 0.065 0.07 0.075 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25]
  #define NEBULA_PURPLE_BRIGHTNESS 1.00 //[0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00]
  #define NEBULA_ORANGE_BRIGHTNESS 1.00 //[0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00]
  #define NEBULA_STAR_BRIGHTNESS 1.00 //[0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00]

//#define WATERMARK
  #define WATERMARK_DURATION 1 //[1 999]
//#define GRAY_START
//#define BLURRY_START
//#define PARTICLE_VISIBILITY
  #define HAND_BLOOM_REDUCTION
//#define LAVA_VISIBILITY
//#define GLOWING_DEBRIS
//#define GLOWING_REDSTONE_BLOCK
//#define GLOWING_LAPIS_BLOCK
//#define GREEN_SCREEN
  #define ENTITY_EFFECT
  #define HAND_SWAY 0.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0]
//#define SNOW_MODE
  #define NIGHT_VISION 1 //[1 2]
  #define DYNAMIC_SHADER_LIGHT
  #define DYNAMIC_LIGHT_DISTANCE 14.0 //[4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0 9.5 10.0 11.0 12.0 13.0 14.0 15.0 16.0 17.0 18.0 19.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0 34.0 36.0 38.0 40.0 44.0 48.0 52.0 56.0 60.0 64.0]
  #define GLINT_BRIGHTNESS 1.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0 8.2 8.4 8.6 8.8 9.0 9.2 9.4 9.6 9.8 10.0 10.2 10.4 10.6 10.8 11.0 11.2 11.4 11.6 11.8 12.0 12.2 12.4 12.6 12.8 13.0 13.2 13.4 13.6 13.8 14.0 14.2 14.4 14.6 14.8 15.0 15.2 15.4 15.6 15.8 16.0 18.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0]
  #define AO
  #define AO_STRENGTH 1.6 //[0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 3.0 4.0 5.0 7.0 9.0]
  #define AO_QUALITY 1 //[1 2 3 4]
  #define LIGHT_SHAFTS
  #define LIGHT_SHAFT_STRENGTH 0.50 //[0.01 0.02 0.03 0.04 0.05 0.07 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.60 0.75 1.00 1.25 1.50 1.75 2.00 2.50 3.00 1000.0]
  #define LIGHT_SHAFT_MODE 2 //[1 2 3]
  #define LIGHT_SHAFT_NOON_MULTIPLIER 0.50 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00 25.00 50.00]
  #define LIGHT_SHAFT_NIGHT_MULTIPLIER 2.00 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00 25.00 50.00]
  #define LIGHT_SHAFT_RAIN_MULTIPLIER 2.00 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00 25.00 50.00]
  #define LIGHT_SHAFT_UNDERWATER_MULTIPLIER 1.00 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00 25.00 50.00]
  #define LIGHT_SHAFT_THE_END_MULTIPLIER 0.25 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.10 2.20 2.30 2.40 2.50 2.60 2.70 2.80 2.90 3.00 3.50 4.00 4.50 5.00 7.50 10.00 12.50 15.00 20.00 25.00 50.00]
  #define REFLECTION
  #define REFLECTION_TRANSLUCENT
  #define WATER_TRANSLUCENT_SKY_REF
  #define WATER_CAUSTICS
//#define PROJECTED_CAUSTICS
//#define WATER_REFRACT
  #define REFRACT_STRENGTH 1.00 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]
//#define BLACK_OUTLINE
//#define PROMO_OUTLINE
  #define PROMO_OUTLINE_MODE 3 //[1 2 3]
  #define PROMO_OUTLINE_STRENGTH 4.00 //[1.00 1.50 2.00 2.50 3.00 3.50 4.00 4.50 5.00 5.50 6.00 6.50 7.00 7.50 8.00]
  #define PROMO_OUTLINE_THICKNESS 1 //[1 2 3 4]
//#define OUTLINE_ON_EVERYTHING

  #define REFLECTION_SPECULAR
  #define REFLECTION_ROUGH
//#define SPECULAR_SKY_REF
//#define REFLECTION_RAIN
  #define REFLECTION_RAIN_COVERAGE 50 //[05 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100]
  #define EMISSIVE_MULTIPLIER 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 6.00 7.00 8.00 9.00 10.00 12.50 15.00 17.50 20.00 30.00 40.00 50.00 100.00]
  #define EMISSIVE_ORES
  #define ORE_EMISSION 1.00 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 6.00 7.00 8.00]
//#define EMISSIVE_NETHER_ORES
  #define EMISSIVE_NETHER_STEMS
  #define EMISSIVE_NETHER_PORTAL
  #define LAVA_INTENSITY 1.00 //[0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00]
  #define FIRE_INTENSITY 1.00 //[0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00]
  #define NORMAL_MAPPING
  #define PARALLAX
  #define PARALLAX_DEPTH 0.50 //[0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00]
  #define SELF_SHADOW
  #define SELF_SHADOW_ANGLE 2.0 //[0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0]
  #define PARALLAX_QUALITY 128 //[16 32 64 128 256 512]
  #define PARALLAX_DISTANCE 16 //[0 8 16 24 32 40 48 56 64 72 80 88 96 104 112 120 128]
  #define DIRECTIONAL_LIGHTMAP
  #define DIRECTIONAL_LIGHTMAP_STRENGTH 3.0 //[7.0 6.5 6.0 5.5 5.0 4.5 4.0 3.5 3.0 2.5 2.0 1.5 1.0]
  #define NORMAL_MULTIPLIER 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00]
//#define GENERATED_NORMALS

  #define DOF 2 //[1 2]
//#define DOF_IS_ON
  #define RAIN_BLUR_MULT 3.00 //[0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 5.25 5.50 5.75 6.00 6.25 6.50 6.75 7.00 7.25 7.50 8.00 8.50 9.00 9.50 10.0 11.0 12.0 13.0 14.0 15.0 17.5 20.0 25.0 30.0 35.0 40.0 45.0 50.0 55.0 60.0 65.0 70.0 75.0 80.0 90.0]
  #define UNDERWATER_BLUR_MULT 4.00 //[0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 5.25 5.50 5.75 6.00 6.25 6.50 6.75 7.00 7.25 7.50 8.00 8.50 9.00 9.50 10.0 11.0 12.0 13.0 14.0 15.0 17.5 20.0 25.0 30.0 35.0 40.0 45.0 50.0 55.0 60.0 65.0 70.0 75.0 80.0 90.0]
  #define NETHER_BLUR
//#define ANAMORPHIC_BLUR
  #define DOF_STRENGTH 32.0 //[1.0 2.0 3.0 4.0 6.0 8.0 12.0 16.0 24.0 32.0 64.0 96.0 128.0 192.0 256.0 384.0 512.0 768.0 1024.0 1536.0 2048.0 3072.0 4096.0]
  #define NETHER_BLUR_STRENGTH 64.0 //[1.0 2.0 3.0 4.0 6.0 8.0 12.0 16.0 24.0 32.0 64.0 96.0 128.0 192.0 256.0 384.0 512.0 768.0 1024.0 1536.0 2048.0 3072.0 4096.0]
//#define MOTION_BLUR
  #define MOTION_BLUR_STRENGTH 1.50 //[0.05 0.07 0.10 0.15 0.20 0.25 0.35 0.50 0.75 1.00 1.25 1.50 1.75 2.00 3.00 5.00 10.00]
  #define BLOOM
  #define BLOOM_STRENGTH 0.40 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.75 1.00 100]
  #define NETHER_BLOOM_MULTIPLIER 1.00 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
//#define LENS_FLARE
  #define LENS_FLARE_STRENGTH 1.00 //[0.10 0.15 0.20 0.25 0.30 0.40 0.50 0.75 1.00 1.25 1.50 1.75 2.00]
  #define AA 3 //[0 1 2 3 4]
  #define SHARPEN 0 //[0 1 2 3 4 5 6 7 8 9 10]
  #define AUTO_EXPOSURE 0 //[0 1 2]
  #define VIGNETTE
  #define VIGNETTE_STRENGTH 0.50 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 4.00 5.00 10.00]
  #define SUN_GLARE
  #define SUN_GLARE_STRENGTH 1.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.5 3.0 4.0 5.0]

//#define COLOR_GRADING
  #define TONEMAP_EXPOSURE 5.6 //[1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0 8.2 8.4 8.6 8.8 9.0 9.2 9.4 9.6 9.8 10.0 10.2 10.4 10.6 10.8 11.0 11.2 11.4 11.6 11.8 12.0 12.2 12.4 12.6 12.8 13.0 13.2 13.4 13.6 13.8 14.0 14.2 14.4 14.6 14.8 15.0 15.2 15.4 15.6 15.8 16.0]
  #define TONEMAP_WHITE_CURVE 2.0 //[1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.5 4.0 4.5 5.0 6.0 7.0 8.0 9.0]
  #define TONEMAP_LOWER_CURVE 1.15 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]
  #define TONEMAP_UPPER_CURVE 1.15 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]
  #define SATURATION 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]
  #define VIBRANCE 1.20 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]

  #define CG_RR 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_RG 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_RB 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_RI 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define CG_RM 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_RC 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define CG_GR 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_GG 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_GB 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_GI 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define CG_GM 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_GC 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define CG_BR 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_BG 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_BB 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_BI 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define CG_BM 0 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_BC 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define CG_TR 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_TG 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_TB 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define CG_TI 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define CG_TM 0.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0]

  const float sunPathRotation = -40.0; //[-60.0 -55.0 -50.0 -45.0 -40.0 -35.0 -30.0 -25.0 -20.0 -15.0 -10.0 -5.0 0.0 5.0 10.0 15.0 20.0 25.0 30.0 35.0 40.0 45.0 50.0 55.0 60.0]
  const int shadowMapResolution = 2048; //[256 1024 2048 3072 4096 8192]
  const float shadowDistance = 256.0; //[64.0 96.0 128.0 192.0 256.0 384.0 512.0 768.0 1024.0]
  #define SHADOWS
  #define SHADOW_FILTER
  #define SHADOW_SUBSURFACE 2 //[0 1 2]
  #define SCATTERING_LEAVES 0.50 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define SCATTERING_FOLIAGE 0.80 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  const float shadowMapBias = 1.0 - 25.6 / shadowDistance;
//#define CLOUD_SHADOW
//#define NO_FOLIAGE_SHADOWS
  #define VAO_STRENGTH 1.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.2 2.4 2.6 2.8 3.0 3.5 4.0 4.5 5.0]
  #define SHADING_STRENGTH 0.85 //[0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.12 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00]

  #define LIGHT_MR 236 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_MG 184 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_MB 132 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_MI 1.05 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define AMBIENT_MR 212 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_MG 196 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_MB 228 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_MI 0.25 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define LIGHT_DR 180 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_DG 172 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_DB 164 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_DI 1.40 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define AMBIENT_DR 156 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_DG 188 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_DB 228 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_DI 0.40 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define LIGHT_ER 236 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_EG 180 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_EB 132 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_EI 1.05 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define AMBIENT_ER 212 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_EG 196 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_EB 228 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_EI 0.25 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define LIGHT_NR 152 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_NG 192 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_NB 248 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define LIGHT_NI 0.75 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define AMBIENT_NR 120 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_NG 164 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_NB 228 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AMBIENT_NI 0.40 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define BLOCKLIGHT_R 220 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define BLOCKLIGHT_G 176 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define BLOCKLIGHT_B 140 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define BLOCKLIGHT_I 0.45 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]


//#define COLORED_LIGHT_DEFINE

  #define LIGHT_GROUND 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define AMBIENT_GROUND 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define WATER_R 172 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WATER_G 212 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WATER_B 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WATER_I 0.50 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define WATER_OPACITY 0.50 //[0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define WATER_FOG 64.0 //[4.0 8.0 16.0 32.0 48.0 64.0 96.0 128.0 160.0 192.0 224.0 256.0 512.0]
  #define WATER_V 0.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0]
  #define UNDERWATER_R 0.33 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.30 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44 0.45 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59 0.60 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74 0.75 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89 0.90 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00]
  #define UNDERWATER_G 0.21 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.30 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44 0.45 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59 0.60 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74 0.75 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89 0.90 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00]
  #define UNDERWATER_B 0.26 //[0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.30 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44 0.45 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59 0.60 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74 0.75 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89 0.90 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00]
  #define UNDERWATER_I 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define WEATHER_RR 172 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WEATHER_RG 204 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WEATHER_RB 248 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define WEATHER_RI 1.60 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define NETHER_R 128 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define NETHER_G 64 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define NETHER_B 64 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define NETHER_I 1.75 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00 4.25 4.50 4.75 5.00 5.50 6.00 7.00 8.00 9.00 10.00]

  #define END_R 36 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define END_G 28 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define END_B 52 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define END_I 2.25 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00 4.25 4.50 4.75 5.00 5.50 6.00 7.00 8.00 9.00 10.00]

  #define SELECTION_R 164 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define SELECTION_G 128 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define SELECTION_B 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define SELECTION_I 1.00 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define SELECTION_MODE 0 //[0 1 2 3]

  #define AURORA_UP_R 112 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_UP_G 80 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_UP_B 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_UP_I 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define AURORA_DOWN_R 80 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_DOWN_G 255 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_DOWN_B 180 //[0 4 8 12 16 20 24 28 32 36 40 44 48 52 56 60 64 68 72 76 80 84 88 92 96 100 104 108 112 116 120 124 128 132 136 140 144 148 152 156 160 164 168 172 176 180 184 188 192 196 200 204 208 212 216 220 224 228 232 236 240 244 248 252 255]
  #define AURORA_DOWN_I 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]

  #define ENDER_NEBULA
  #define AURORA
  #define ROUND_SUN_MOON
//#define VANILLA_SKYBOX
  #define SKYBOX_BRIGHTNESS 2.00 //[0.01 0.02 0.03 0.05 0.07 0.10 0.15 0.20 0.25 0.35 0.40 0.45 0.50 0.60 0.75 1.00 1.25 1.50 1.75 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00]
  
  #define SKY_DAY 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00]
  #define SKY_NOON 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00]
  #define SKY_NIGHT 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00]
  #define SKY_RAIN_DAY 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00]
  #define SKY_RAIN_NIGHT 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00]

  #define CLOUDS
  #define CLOUD_THICKNESS 4.00 //[0.25 0.50 0.75 1.00 2.00 3.00 4.00 5.00 6.00 7.00 8.00]
  #define CLOUD_AMOUNT 10.5 //[14.0 13.5 13.0 12.5 12.0 11.5 11.0 10.5 10.0 9.5 9.0 8.5 8.0 7.5 7.0 6.5 6.0]
  #define CLOUD_HEIGHT 30.0 //[2.5 5.0 10.0 15.0 20.0 25.0 30.0 35.0 40.0 45.0 50.0]
  #define CLOUD_SPEED 1.00 //[0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.50 3.00 3.50 4.00 5.00]
  #define CLOUD_OPACITY 0.6 //[0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0]
  #define CLOUD_BRIGHTNESS 2.00 //[0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00]

  #define LIGHTSHAFT_ENDURANCE 1.20 //[0.10 0.25 0.40 0.50 0.60 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.10 1.20 1.30 1.40 1.50 1.75 2.00 2.50 3.00 4.00 5.00 5.50 10.00]
  #define LIGHTSHAFT_MIN_DISTANCE 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.75 2.00 2.50 3.00 4.00 5.00 7.50 10.00]
  #define LIGHTSHAFT_MAX_DISTANCE 96.0 //[32.0 64.0 96.0 128.0 160.0 192.0 224.0 256.0 320.0 384.0 448.0 512.0]
  #define LIGHTSHAFT_DISTANCE_EXPONENT 1.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0 8.2 8.4 8.6 8.8 9.0 9.2 9.4 9.6 9.8 10.0 10.2 10.4 10.6 10.8 11.0 11.2 11.4 11.6 11.8 12.0 12.2 12.4 12.6 12.8 13.0 13.2 13.4 13.6 13.8 14.0 14.2 14.4 14.6 14.8 15.0 15.2 15.4 15.6 15.8 16.0]
  #define LIGHTSHAFT_BREAK 1 //[0 1]
  #define LIGHTSHAFT_SAMPLE_INTENSITY 7.8 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.2 1.4 1.6 1.8 2.0 2.2 2.4 2.6 2.8 3.0 3.2 3.4 3.6 3.8 4.0 4.2 4.4 4.6 4.8 5.0 5.2 5.4 5.6 5.8 6.0 6.2 6.4 6.6 6.8 7.0 7.2 7.4 7.6 7.8 8.0 8.2 8.4 8.6 8.8 9.0 9.2 9.4 9.6 9.8 10.0 10.2 10.4 10.6 10.8 11.0 11.2 11.4 11.6 11.8 12.0 12.2 12.4 12.6 12.8 13.0 13.2 13.4 13.6 13.8 14.0 14.2 14.4 14.6 14.8 15.0 15.2 15.4 15.6 15.8 16.0 18.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0 36.0 40.0 44.0 48.0 52.0 56.0 60.0 64.0]
  #define LIGHTSHAFT_SAMPLE_COUNT 9 //[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 17 20 25 30 35 40 50 60 70 80 90 100 120 150 200 250 300 350 400 500 700 1000]
  

//#define GALAXIES
  #define GALAXY_BRIGHTNESS 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define SHADER_STARS
  #define STAR_BRIGHTNESS 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define STAR_AMOUNT 1 //[1 2]
  #define SUNSET_STARS

  #define WATER_TYPE 0 //[0 1 2]
//#define WATER_DISPLACEMENT
  #define WATER_PARALLAX
  #define WATER_BUMP 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 5.50 6.00 6.50 7.00 7.50 8.00]
  #define WATER_NOISE_1 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
  #define WATER_NOISE_2 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
  #define WATER_NOISE_3 0.40 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
  #define WATER_NOISE_4 0.30 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
  #define SUN_MOON_WATER_REF 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00 3.25 3.50 3.75 4.00 4.25 4.50 4.75 5.00 5.50 6.00 6.50 7.00 7.50 8.00 8.50 9.00 9.50 10.0 11.0 12.0 13.0 14.0 15.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0]
  #define MOON_WATER_REF 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.40 1.50 1.60 1.70 1.80 1.90 2.00 2.25 2.50 2.75 3.00]
  #define WATER_SHARPNESS 0.25 //[0.01 0.02 0.03 0.05 0.07 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50]
  #define WATER_SIZE 450.0 //[25.0 50.0 100.0 150.0 200.0 250.0 300.0 350.0 400.0 450.0 500.0 550.0 600.0 650.0 700.0 750.0 800.0 850.0 900.0 950.0 1000.0 1100.0 1200.0 1300.0 1400.0 1500.0]
  #define WATER_SPEED 1.25 //[0.05 0.10 0.15 0.20 0.25 0.35 0.50 0.60 0.75 0.90 1.00 1.10 1.25 1.50 1.75 2.00 2.50 3.00 3.50 4.00 4.25 4.50 4.75 5.00 5.50 6.00 6.50 7.00 7.50 8.00]
  #define UNDERWATER_DISTORT 1.0 //[0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 100.0 1000.0]

//#define WHITE_WORLD
  #define NETHER_FOG
//#define NETHER_SMOKE
  #define FOG1
  #define FOG1_DISTANCE 10 //[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 18 20 22 24 26 28 30 32 36 40 44 48 52 56 60 64]
  #define FOG1_TYPE 1 //[0 1 2]
  #define FOG2
  #define FOG2_ALTITUDE_MODE
  #define FOG2_BRIGHTNESS 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define FOG2_END_BRIGHTNESS 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00]
  #define FOG2_DISTANCE 10.0 //[0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0 9.5 10.0 11.0 12.0 13.0 14.0 15.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0 36.0 40.0 44.0 48.0 52.0 56.0 60.0 64.0]
  #define FOG2_ALTITUDE 95 //[0 5 10 15 20 25 30 35 40 45 50 55 60 65 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300]
  #define FOG2_OPACITY 0.30 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define FOG2_END_DISTANCE 8.0 //[0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 7.5 8.0 8.5 9.0 9.5 10.0 11.0 12.0 13.0 14.0 15.0 16.0 18.0 20.0 22.0 24.0 26.0 28.0 30.0 32.0 36.0 40.0 44.0 48.0 52.0 56.0 60.0 64.0]
  #define FOG2_END_ALTITUDE 80 //[0 5 10 15 20 25 30 35 40 45 50 55 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 110 120 130 140 150 160 170 180 190 200 210 220 230 240 250 260 270 280 290 300]
  #define FOG2_END_OPACITY 0.65 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define FOG2_RAIN_OPACITY_M 3.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00 4.25 4.50 4.75 5.00 5.25 5.50 5.75 6.00 6.25 6.50 6.75 7.00 7.50 8.00 8.50 9.00 9.50 10.0]
  #define FOG2_RAIN_BRIGHTNESS_M 1.00 //[0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00 4.25 4.50 4.75 5.00 5.25 5.50 5.75 6.00 6.25 6.50 6.75 7.00 7.50 8.00 8.50 9.00 9.50 10.0]
  #define FOG2_RAIN_ALTITUDE_M 0.25 //[0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00]
  #define FOG2_RAIN_DISTANCE_M 1.00 //[-1.00 -0.95 -0.90 -0.85 -0.80 -0.75 -0.70 -0.65 -0.60 -0.55 -0.50 -0.45 -0.40 -0.35 -0.30 -0.25 -0.20 -0.15 -0.10 -0.05 0.00 0.05 0.10 0.15 0.20 0.25 0.30 0.35 0.40 0.45 0.50 0.55 0.60 0.65 0.70 0.75 0.80 0.85 0.90 0.95 1.00 1.05 1.10 1.15 1.20 1.25 1.30 1.35 1.40 1.45 1.50 1.55 1.60 1.65 1.70 1.75 1.80 1.85 1.90 1.95 2.00 2.05 2.10 2.15 2.20 2.25 2.30 2.35 2.40 2.45 2.50 2.55 2.60 2.65 2.70 2.75 2.80 2.85 2.90 2.95 3.00 3.05 3.10 3.15 3.20 3.25 3.30 3.35 3.40 3.45 3.50 3.55 3.60 3.65 3.70 3.75 3.80 3.85 3.90 3.95 4.00 4.25 4.50 4.75 5.00 5.25 5.50 5.75 6.00 6.25 6.50 6.75 7.00 7.50 8.00 8.50 9.00 9.50 10.0]
//#define WORLD_CURVATURE
  #define OVERWORLD_CURVATURE_SIZE 2048 //[-256 -512 -1024 -2048 -4096 -8192 -16384 -32768 999999 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16]
  #define NETHER_CURVATURE_SIZE 2048 //[-256 -512 -1024 -2048 -4096 -8192 -16384 -32768 999999 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16]
  #define END_CURVATURE_SIZE 2048 //[-256 -512 -1024 -2048 -4096 -8192 -16384 -32768 999999 32768 16384 8192 4096 2048 1024 512 256 128 64 32 16]
  #define WORLD_TIME_ANIMATION 1 //[0 1 2]
  #define ANIMATION_SPEED 1.00 //[0.00 0.25 0.50 0.75 1.00 1.25 1.50 1.75 2.00 2.50 3.00 3.50 4.00 5.00 6.00 7.00 8.00 16.00 32.00 64.00 128.00]
  #define MIN_LIGHT 32 //[0 1 2 4 8 16 32 64 128 256 512 1024 2048]
//#define NO_PARTICLES
//#define BLOCKLIGHT_FLICKER
  #define BLOCKLIGHT_FLICKER_STRENGTH 0.60 //[0.00 0.10 0.20 0.30 0.40 0.50 0.60 0.70 0.80 0.90 1.00 1.50 2.00 3.00 4.00]

//Define Handling//
  #if (RP_SUPPORT == 1 && !defined COMPATIBILITY_MODE) || RP_SUPPORT > 2 
    #define ADV_MAT
  #endif

  #if !defined COMPATIBILITY_MODE && RP_SUPPORT == 1
    #define COMPBR
    #undef PARALLAX
    #undef SELF_SHADOW
    #undef DIRECTIONAL_LIGHTMAP
    #ifndef GENERATED_NORMALS
      #undef NORMAL_MAPPING
    #endif
  #endif
  
  #ifndef NORMAL_MAPPING
    #undef PARALLAX
    #undef SELF_SHADOW
    #undef DIRECTIONAL_LIGHTMAP
  #endif

  #if defined ENTITY_NORMAL_FIX && MC_VERSION >= 11500 && MC_VERSION < 11700 && (defined GBUFFERS_ENTITIES || defined GBUFFERS_HAND || defined GBUFFERS_BLOCK)
    #undef PARALLAX
    #undef SELF_SHADOW
    #undef DIRECTIONAL_LIGHTMAP
    #undef NORMAL_MAPPING
  #endif

  #ifndef SHADOWS
    #undef LIGHT_SHAFTS
  #endif

  #ifdef COMPATIBILITY_MODE
    #undef LIGHTNING_BOLTS_FIX
    #undef FLICKERING_FIX
    #ifndef DO_WAVING_ON_COMPATIBILITY
      #undef WAVING_FOLIAGE
      #undef WAVING_LEAVES
      #undef WAVING_CROPS
      #undef WAVING_VINES
      #undef WAVING_LILY_PADS
    #endif
  #endif

  #if defined ADV_MAT && !defined COMPATIBILITY_MODE && defined COLORED_LIGHT_DEFINE
    #define COLORED_LIGHT
    #undef RANDOM_BLOCKLIGHT
  #endif

//Dimension Undefine//
  #ifdef NETHER
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
  #endif

  #ifdef END
    #undef LENS_FLARE
  #endif
  
  #ifdef SEVEN_2
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
    #undef CLOUDS
  #endif
  
  #ifdef TWO
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
  #endif

  #ifdef SEVEN
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
  #endif

  #ifdef TWO
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
  #endif

  #ifdef ONESEVEN
    #undef LIGHT_SHAFTS
  #endif

  #ifdef TWENTY
    #undef LIGHT_SHAFTS
    #undef LENS_FLARE
  #endif

//Shenanigans//
  #ifdef GLOWING_ENTITY_FIX
  #endif
  #ifdef NETHER_BLUR
  #endif
  #ifdef DOF_IS_ON
  #endif
  #ifdef ENTITY_NORMAL_FIX
  #endif
  #ifdef WATER_DISPLACEMENT
  #endif
  #ifdef NO_PARTICLES
  #endif
  #ifdef FOG2_ALTITUDE_MODE
  #endif
  #ifdef HAND_BLOOM_REDUCTION
  #endif
  #ifdef EMISSIVE_NETHER_PORTAL
  #endif
  #ifdef FOG1_CHECK
  #endif
  #ifdef LIGHTSHAFT_WATER_CAUSTICS
  #endif
  #ifdef OUTLINE_ON_EVERYTHING
  #endif
  #ifdef FOG2
  #endif
  #ifdef CLOUD_SHADOW
  #endif
  #ifdef LIGHT_SHAFTS
  #endif
  #ifdef NETHER_FOG
  #endif
  #ifdef REFLECTION_SPECULAR
  #endif
  #ifdef GENERATED_NORMALS
  #endif
  #ifdef VANILLA_SKYBOX
  #endif
  #ifdef COLORED_LIGHT_DEFINE
  #endif

//Very Common Functions//
float pow2(float number) {
    return number * number;
}

float sqrt1(float number) { // Faster sqrt() for numbers that are between 0 and 1
    number = 1.0 - number;
    number *= number;
    return 1.0 - number;
}

float sqrt2(float number) {
    number = 1.0 - number;
    number *= number;
    number *= number;
    return 1.0 - number;
}
float sqrt3(float number) {
    number = 1.0 - number;
    number *= number;
    number *= number;
    number *= number;
    return 1.0 - number;
}
float sqrt4(float number) {
    number = 1.0 - number;
    number *= number;
    number *= number;
    number *= number;
    number *= number;
    return 1.0 - number;
}
float sqrt5(float number) { // Barely faster than pow(number, 0.03125)
    number = 1.0 - number;
    number *= number;
    number *= number;
    number *= number;
    number *= number;
    number *= number;
    return 1.0 - number;
}

float sqrt1inv(float number) {
    number = 1.0 - number;
    number *= number;
    return number;
}

vec3 sqrt1vec3(vec3 vector) {
    vector = vec3(1.0) - vector;
    vector *= vector;
    return vec3(1.0) - vector;
}

vec3 TextureSample3R(sampler2D texture, vec2 coord) {
    vec3 result = texture2D(texture, coord).rgb;
    return result;
}

//Varyings//
varying float mat;
varying float mipmapDisabling;
varying float quarterNdotUfactor;
varying float specR, specG, specB;

varying vec2 texCoord, lmCoord;

varying vec3 normal;
varying vec3 sunVec, upVec;

varying vec4 color;

#ifdef OLD_LIGHTING_FIX
varying vec3 eastVec, northVec;
#endif

#ifdef ADV_MAT
	#if defined PARALLAX || defined SELF_SHADOW
		varying float dist;
		varying vec3 viewVector;
	#endif

	#if !defined COMPBR || defined NORMAL_MAPPING
		varying vec4 vTexCoord;
		varying vec4 vTexCoordAM;
	#endif

	#if defined NORMAL_MAPPING || defined REFLECTION_RAIN
		varying vec3 binormal, tangent;
	#endif
#endif

#ifdef SNOW_MODE
varying float noSnow;
#endif

#ifdef COLORED_LIGHT
varying float lightVarying;
#endif

//////////Fragment Shader//////////Fragment Shader//////////Fragment Shader//////////
#ifdef FSH

//Uniforms//
uniform int frameCounter;
uniform int isEyeInWater;
uniform int worldTime;
uniform int moonPhase;

#ifdef DYNAMIC_SHADER_LIGHT
	uniform int heldItemId, heldItemId2;

	uniform int heldBlockLightValue;
	uniform int heldBlockLightValue2;
#endif

uniform float frameTimeCounter;
uniform float nightVision;
uniform float rainStrengthS;
uniform float screenBrightness; 
uniform float shadowFade;
uniform float timeAngle, timeBrightness, moonBrightness;
uniform float viewWidth, viewHeight;

uniform ivec2 eyeBrightnessSmooth;

uniform vec3 fogColor;
uniform vec3 cameraPosition;

uniform mat4 gbufferProjectionInverse;
uniform mat4 gbufferModelViewInverse;
uniform mat4 gbufferModelView;
uniform mat4 shadowProjection;
uniform mat4 shadowModelView;

uniform sampler2D texture;
uniform sampler2D noisetex;

#ifdef ADV_MAT
	#ifndef COMPBR
		uniform sampler2D specular;
		uniform sampler2D normals;
	#endif

	#ifdef REFLECTION_RAIN
		uniform float wetness;
	#endif

	#if defined PARALLAX || defined SELF_SHADOW
		uniform int blockEntityId;
	#endif

	#if defined NORMAL_MAPPING && defined GENERATED_NORMALS
		uniform mat4 gbufferProjection;
	#endif
#endif

#ifdef REFLECTION_RAIN
	uniform float isDry, isRainy, isSnowy;
#endif

#ifdef COLORED_LIGHT
uniform ivec2 eyeBrightness;

uniform sampler2D colortex9;
#endif

//Common Variables//
float eBS = eyeBrightnessSmooth.y / 240.0;
float sunVisibility  = clamp(dot( sunVec,upVec) + 0.0625, 0.0, 0.125) * 8.0;
float vsBrightness = clamp(screenBrightness, 0.0, 1.0);

#if WORLD_TIME_ANIMATION >= 2
float frametime = float(worldTime) * 0.05 * ANIMATION_SPEED;
#else
float frametime = frameTimeCounter * ANIMATION_SPEED;
#endif

#if defined ADV_MAT && RP_SUPPORT > 2
vec2 dcdx = dFdx(texCoord.xy);
vec2 dcdy = dFdy(texCoord.xy);
#endif

#ifdef OVERWORLD
	vec3 lightVec = sunVec * ((timeAngle < 0.5325 || timeAngle > 0.9675) ? 1.0 : -1.0);
#else
	vec3 lightVec = sunVec;
#endif
 
//Common Functions//
float GetLuminance(vec3 color) {
	return dot(color,vec3(0.299, 0.587, 0.114));
}

float InterleavedGradientNoise() {
	float n = 52.9829189 * fract(0.06711056 * gl_FragCoord.x + 0.00583715 * gl_FragCoord.y);
	return fract(n + frameCounter / 8.0);
}

//Includes//
#ifndef COLORED_LIGHT
vec3 blocklightColSqrt = vec3(BLOCKLIGHT_R, BLOCKLIGHT_G, BLOCKLIGHT_B) * BLOCKLIGHT_I / 255.0;
vec3 blocklightCol = blocklightColSqrt * blocklightColSqrt;
#else
vec3 blocklightColSqrt = vec3(0.387, 0.31, 0.247);
vec3 blocklightCol = vec3(0.15, 0.096, 0.061);
#endif
#if defined OVERWORLD || defined SEVEN
vec3 lightMorning    = vec3(LIGHT_MR, LIGHT_MG, LIGHT_MB) * LIGHT_MI / 255.0;
vec3 lightDay        = vec3(LIGHT_DR, LIGHT_DG, LIGHT_DB) * LIGHT_DI / 255.0;
vec3 lightEvening    = vec3(LIGHT_ER, LIGHT_EG, LIGHT_EB) * LIGHT_EI / 255.0;
#ifndef ONESEVEN
vec3 lightNight      = vec3(LIGHT_NR, LIGHT_NG, LIGHT_NB) * LIGHT_NI * (vsBrightness*0.125 + 0.80) * 0.4 / 255.0;
#else
vec3 lightNight      = (vec3(LIGHT_NR, LIGHT_NG, LIGHT_NB) * LIGHT_NI * 0.195 / 255.0) + vec3(0.37, 0.31, 0.25) * 0.35 ;
#endif

vec3 ambientMorning  = vec3(AMBIENT_MR, AMBIENT_MG, AMBIENT_MB) * AMBIENT_MI * 1.1 / 255.0;
vec3 ambientDay      = vec3(AMBIENT_DR, AMBIENT_DG, AMBIENT_DB) * AMBIENT_DI * 1.1 / 255.0;
vec3 ambientEvening  = vec3(AMBIENT_ER, AMBIENT_EG, AMBIENT_EB) * AMBIENT_EI * 1.1 / 255.0;
vec3 ambientNight    = vec3(AMBIENT_NR, AMBIENT_NG, AMBIENT_NB) * AMBIENT_NI * (vsBrightness*0.20 + 0.70) * 0.495 / 255.0;

vec3 weatherCol = vec3(WEATHER_RR, WEATHER_RG, WEATHER_RB) * WEATHER_RI / 255.0;
vec3 weatherIntensity = vec3(WEATHER_RI);

float mefade = 1.0 - clamp(abs(timeAngle - 0.5) * 8.0 - 1.5, 0.0, 1.0);
float dfade = 1.0 - timeBrightness;

vec3 CalcLightColor(vec3 morning, vec3 day, vec3 afternoon, vec3 night, vec3 weatherCol) {
	vec3 me = mix(morning, afternoon, mefade);
	float dfadeModified = dfade * dfade;
	vec3 dayAll = mix(me, day, 1.0 - dfadeModified * dfadeModified);
	vec3 c = mix(night, dayAll, sunVisibility);
	c = mix(c, dot(c, vec3(0.299, 0.587, 0.114)) * weatherCol, rainStrengthS*0.6);
	return c * c;
}

vec3 lightCol   = CalcLightColor(lightMorning,   lightDay,   lightEvening,   lightNight,
								 weatherCol * (vsBrightness*0.1 + 0.9));
vec3 ambientCol = CalcLightColor(ambientMorning, ambientDay, ambientEvening, ambientNight,
								 weatherCol * (vsBrightness*0.1 + 0.9));
#endif

#ifdef NETHER
#if MC_VERSION <= 11600
vec3 netherColSqrt = vec3(NETHER_R, NETHER_G, NETHER_B) * 0.25 * NETHER_I / 255.0;
vec3 netherCol = netherColSqrt * netherColSqrt;
#else
vec3 netherCol = fogColor * (1 - length(fogColor / 3.0)) * 0.25 * NETHER_I;
#endif
#endif

#ifdef END
vec3 endColSqrt = vec3(END_R, END_G, END_B) * 2.25 / 255.0;
vec3 endCol = endColSqrt * endColSqrt;
#endif
#define diagonal3(m) vec3((m)[0].x, (m)[1].y, m[2].z)
#define projMAD(m, v) (diagonal3(m) * (v) + (m)[3].xyz)

vec3 ToNDC(vec3 pos) {
	vec4 iProjDiag = vec4(gbufferProjectionInverse[0].x,
						  gbufferProjectionInverse[1].y,
						  gbufferProjectionInverse[2].zw);
    vec3 p3 = pos * 2.0 - 1.0;
    vec4 viewPos = iProjDiag * p3.xyzz + gbufferProjectionInverse[3];
    return viewPos.xyz / viewPos.w;
}

vec3 ToWorld(vec3 pos) {
	return mat3(gbufferModelViewInverse) * pos + gbufferModelViewInverse[3].xyz;
}

vec3 ToShadow(vec3 pos) {
	vec3 shadowpos = mat3(shadowModelView) * pos + shadowModelView[3].xyz;
	return projMAD(shadowProjection, shadowpos);
}
vec4 underwaterColor = vec4(pow(fogColor, vec3(UNDERWATER_R, UNDERWATER_G, UNDERWATER_B)) * UNDERWATER_I * 0.2, 1.0);
vec4 waterColorSqrt = vec4(WATER_R, WATER_G, WATER_B, 255.0) * WATER_I / 255.0;
vec4 waterColor = waterColorSqrt * waterColorSqrt;

const float waterFog = WATER_FOG;

const float waterAlpha = WATER_OPACITY;
#if (defined OVERWORLD || defined END || defined SEVEN) && defined SHADOWS
uniform sampler2DShadow shadowtex0;

vec2 shadowoffsets[8] = vec2[8](    vec2( 0.0   , 1.0   ),
                                    vec2( 0.7071, 0.7071),
                                    vec2( 1.0   , 0.0   ),
                                    vec2( 0.7071,-0.7071),
                                    vec2( 0.0   ,-1.0   ),
                                    vec2(-0.7071,-0.7071),
                                    vec2(-1.0   , 0.0   ),
                                    vec2(-0.7071, 0.7071));

vec2 offsetDist(float x, float s) {
	float n = fract(x * 1.414) * 3.1415;
    return vec2(cos(n), sin(n)) * 1.4 * x / s;
}

float SampleBasicShadow(vec3 shadowPos) {
    float shadow0 = shadow2D(shadowtex0, vec3(shadowPos.st, shadowPos.z)).x;

    return shadow0;
}

float SampleFilteredShadow(vec3 shadowPos, float offset) {
    float shadow = SampleBasicShadow(vec3(shadowPos.st, shadowPos.z)) * 2.0;

    for(int i = 0; i < 8; i++) {
        shadow+= SampleBasicShadow(vec3(offset * 1.2 * shadowoffsets[i] + shadowPos.st, shadowPos.z));
    }

    return shadow * 0.1;
}

float SampleTAAFilteredShadow(vec3 shadowPos, float offset) {
    float noise = InterleavedGradientNoise();
    float shadow = 0.0;
    offset = offset * (2.0 - 0.5 * (0.85 + 0.25 * (3072.0 / shadowMapResolution)));
    if (shadowMapResolution < 400.0) offset *= 30.0;

    for(int i = 0; i < 2; i++) {
        vec2 offset = offsetDist(noise + i, 2.0) * offset;
        shadow += SampleBasicShadow(vec3(shadowPos.st + offset, shadowPos.z));
        shadow += SampleBasicShadow(vec3(shadowPos.st - offset, shadowPos.z));
    }
    
    return shadow * 0.25;
}

float GetShadow(vec3 shadowPos, float offset) {

    #ifdef SHADOW_FILTER
        #if AA > 1
            float shadow = SampleTAAFilteredShadow(shadowPos, offset);
        #else
            float shadow = SampleFilteredShadow(shadowPos, offset);
        #endif
    #else
       float shadow = SampleBasicShadow(shadowPos);
    #endif

    return shadow;
}

	vec3 DistortShadow(inout vec3 worldPos, float distortFactor) {
		worldPos.xy /= distortFactor;
		worldPos.z *= 0.2;
		return worldPos * 0.5 + 0.5;
	}
#endif

#if defined WATER_CAUSTICS && defined OVERWORLD && !defined GBUFFERS_WATER
	#ifdef PROJECTED_CAUSTICS
		uniform sampler2DShadow shadowtex1;
		uniform sampler2D shadowcolor0;
	#endif

float waterH(vec3 pos) {
	float noise = 0;
	vec2 wind = vec2(frametime) * 0.35 * WATER_SPEED;
	noise+= texture2D(noisetex,(pos.xz + wind - pos.y * 0.7) / 1024.0 * 1.1).r * 1.0;
	noise+= texture2D(noisetex,(pos.xz - wind - pos.y * 0.7) / 1024.0 * 1.5).r * 0.8;
	noise-= texture2D(noisetex,(pos.xz + wind + pos.y * 0.7) / 1024.0 * 2.5).r * 0.6;
	noise+= texture2D(noisetex,(pos.xz - wind - pos.y * 0.7) / 1024.0 * 5.0).r * 0.4;
	noise-= texture2D(noisetex,(pos.xz + wind + pos.y * 0.7) / 1024.0 * 8.0).r * 0.2;

	return noise;
	}

float getCausticWaves(vec3 pos) {
	float deltaPos = 0.1;
	float caustic_h0 = waterH(pos);
	float caustic_h1 = waterH(pos + vec3( deltaPos, 0.0,  0.0));
	float caustic_h2 = waterH(pos + vec3(-deltaPos, 0.0,  0.0));
	float caustic_h3 = waterH(pos + vec3( 0.0,      0.0,  deltaPos));
	float caustic_h4 = waterH(pos + vec3( 0.0,      0.0, -deltaPos));

	float caustic = max((1.0-abs(0.5-caustic_h0))*(1.0-(abs(caustic_h1-caustic_h2)+abs(caustic_h3-caustic_h4))),0.0);
		  caustic = max(pow(caustic,3.5),0.0)*2.0;
		  
	return caustic;
}
#endif

float GetFakeShadow(float skyLight) {
	float fakeShadow = 0.0;

	#ifndef END
		if (isEyeInWater == 0) skyLight = pow(skyLight, 30.0);
		fakeShadow = skyLight;
	#else
		#ifdef SHADOWS
			fakeShadow = 1.0;
		#else
			fakeShadow = 0.0;
		#endif
	#endif

	return fakeShadow;
}

void GetLighting(inout vec3 albedo, inout float shadow, inout vec3 lightAlbedo, vec3 viewPos, float lViewPos, vec3 worldPos,
                 vec2 lightmap, float smoothLighting, float NdotL, float quarterNdotU,
                 float parallaxShadow, float emissive, float subsurface, float leaves, float materialAO) {
	float fullShadow = 0.0;
	float fakeShadow = 0.0;
	float shadowMult = 1.0;
	float shadowTime = 1.0;

	#if defined WATER_CAUSTICS && defined OVERWORLD && !defined GBUFFERS_WATER && defined PROJECTED_CAUSTICS
		float water = 0.0;
	#endif

    #if defined OVERWORLD || defined END || defined SEVEN
		#ifdef SHADOWS
			if ((NdotL > 0.0 || subsurface > 0.001)) {
				float shadowLengthX = length(worldPos.xy);
				float shadowLengthZ = length(worldPos.yz);
				float shadowLength = shadowDistance - max(shadowLengthX, shadowLengthZ) - shadowDistance / 12.0;

				#if (defined OVERWORLD || defined SEVEN) && defined LIGHT_LEAK_FIX
					if (isEyeInWater == 0) shadowLength *= float(lightmap.y > 0.001);
				#endif

				if (shadowLength > 0.000001) {
					vec3 shadowPos = ToShadow(worldPos);
					float distb = sqrt(shadowPos.x * shadowPos.x + shadowPos.y * shadowPos.y);
					float distortFactor = distb * shadowMapBias + (1.0 - shadowMapBias);
					shadowPos = DistortShadow(shadowPos, distortFactor);

					#ifdef NORMAL_MAPPING
						float NdotLm = clamp(dot(normal, lightVec) * 1.01 - 0.01, 0.0, 1.0) * 0.99 + 0.01;
						NdotL = min(NdotL, NdotLm);
					#else
						float NdotLm = NdotL * 0.99 + 0.01;
					#endif

					float dotWorldPos = dot(worldPos.xyz, worldPos.xyz);
					
					float biasFactor = sqrt(1.0 - NdotLm * NdotLm) / NdotLm;
					float distortBias = distortFactor * shadowDistance / 256.0;
					distortBias *= 8.0 * distortBias;
					
					float bias = (distortBias * biasFactor + dotWorldPos * 0.000005 + 0.05) / shadowMapResolution;
					float offset = 1.0 / shadowMapResolution;

					if (subsurface > 0.001) {
						bias = 0.0002;
						offset = 0.002;
					}
					if (isEyeInWater == 1) offset *= 5.0;

					shadowPos.z -= bias;
					shadow = GetShadow(shadowPos, offset);

					#if defined WATER_CAUSTICS && defined OVERWORLD && !defined GBUFFERS_WATER && defined PROJECTED_CAUSTICS
						if (isEyeInWater == 0) {
							if (shadow < 0.999) {
								water = texture2D(shadowcolor0, shadowPos.st).r
									* shadow2D(shadowtex1, vec3(shadowPos.st, shadowPos.z)).x;
								#ifdef SHADOW_FILTER
									shadowPos.z -= bias * shadowMapResolution / 2048.0;
									for(int i = 0; i < 8; i++) {
										vec2 shadowOffset = 0.002 * shadowoffsets[i];
										water += texture2D(shadowcolor0, shadowOffset + shadowPos.st).r
											* shadow2D(shadowtex1, vec3(shadowOffset + shadowPos.st, shadowPos.z)).x;
									}
									water *= 0.1;
									water *= water;
								#endif
								water *= NdotL;
							}
						}
					#endif
				} else {
					//albedo.rgb *= 0.0;
				}
				float shadowLength2 = shadowLength;
				float shadowSmooth = 16.0;
				if (shadowLength2 < shadowSmooth) {
					float shadowLengthDecider = max(shadowLength2 / shadowSmooth, 0.0);
					float skyLightShadow = GetFakeShadow(lightmap.y);
					shadow = mix(skyLightShadow, shadow, shadowLengthDecider);
					subsurface *= mix(subsurface * 0.5, subsurface, shadowLengthDecider);
					fakeShadow = mix(1.0, fakeShadow, shadowLengthDecider);
					fakeShadow = 1.0 - fakeShadow;
					fakeShadow *= fakeShadow;
					fakeShadow = 1.0 - fakeShadow;
				}
			}
		#else
			shadow = GetFakeShadow(lightmap.y);
		#endif
		
		#if defined CLOUD_SHADOW && defined OVERWORLD
			float cloudSize = 0.000025;
			vec2 wind = vec2(frametime, 0.0) * CLOUD_SPEED * 6.0;
			float cloudShadow = texture2D(noisetex, cloudSize * (wind + (worldPos.xz + cameraPosition.xz))).r;
			cloudShadow += texture2D(noisetex, cloudSize * (vec2(1000.0) + wind + (worldPos.xz + cameraPosition.xz))).r;
			cloudShadow = clamp(cloudShadow, 0.0, 1.0);
			cloudShadow *= cloudShadow;
			cloudShadow *= cloudShadow;
			shadow *= cloudShadow;
		#endif

		#ifdef ADV_MAT
			#ifdef SELF_SHADOW
				shadow *= mix(1.0, parallaxShadow, NdotL);
			#endif
		#endif
		
		fullShadow = shadow * max(NdotL, subsurface * (1.0 - max(rainStrengthS, (1.0 - sunVisibility)) * 0.40));
		
		#if defined OVERWORLD && !defined TWO
			shadowMult = 1.0 * (1.0 - 0.9 * rainStrengthS);
			
			shadowTime = abs(sunVisibility - 0.5) * 2.0;
			shadowTime *= shadowTime;
			shadowMult *= shadowTime * shadowTime;
			
			#ifndef LIGHT_LEAK_FIX
				ambientCol *= pow(lightmap.y, 2.5);
			#else
				if (isEyeInWater == 1) ambientCol *= pow(lightmap.y, 2.5);
			#endif
			
			vec3 lightingCol = pow(lightCol, vec3(1.0 + sunVisibility));
			#ifdef SHADOWS
				lightingCol *= (1.0 + 0.5 * leaves);
			#else
				lightingCol *= (1.0 + 0.4 * leaves);
			#endif
			float shadowDecider = fullShadow * shadowMult;
			if (isEyeInWater == 1) shadowDecider *= pow(min(lightmap.y * 1.03, 1.0), 200.0);
			vec3 sceneLighting = mix(ambientCol * AMBIENT_GROUND, lightingCol * LIGHT_GROUND, shadowDecider);
			
			#ifdef LIGHT_LEAK_FIX
				if (isEyeInWater == 0) sceneLighting *= pow(lightmap.y, 2.5);
			#endif
		#endif

		#ifdef END
			vec3 ambientEnd = endCol * 0.07;
			vec3 lightEnd   = endCol * 0.17;
			float shadowDecider = fullShadow;
			vec3 sceneLighting = mix(ambientEnd, lightEnd, shadowDecider);
			sceneLighting *= END_I * (0.7 + 0.4 * vsBrightness);
		#endif

		#ifdef TWO
			#ifndef ABYSS
				vec3 sceneLighting = vec3(0.0003, 0.0004, 0.002) * 10.0;
			#else
				vec3 sceneLighting = pow(fogColor, vec3(0.2)) * 0.125;
			#endif
		#endif
		
		#if defined SEVEN && !defined SEVEN_2
			sceneLighting = vec3(0.005, 0.006, 0.018) * 133 * (0.3 * fullShadow + 0.025);
		#endif
		#ifdef SEVEN_2
			vec3 sceneLighting = vec3(0.005, 0.006, 0.018) * 33 * (1.0 * fullShadow + 0.025);
		#endif
		#if defined SEVEN || defined SEVEN_2
			sceneLighting *= lightmap.y * lightmap.y;
		#endif
		
		#ifdef SHADOWS
			if (subsurface > 0.001) {
				float VdotL = clamp(dot(normalize(viewPos.xyz), lightVec), 0.0, 1.0);
				sceneLighting *= 5.0 * (1.0 - fakeShadow) * shadowTime * fullShadow * (1.0 + leaves) * pow(VdotL, 10.0) + 1.0;
			}
		#endif
    #else
		#ifdef NETHER
			#if MC_VERSION <= 11600
			#else
				if (quarterNdotU < 0.5625) quarterNdotU = 0.5625 + (0.4 - quarterNdotU * 0.7111111111111111);
			#endif
		
			vec3 sceneLighting = netherCol * (1 - pow(length(fogColor / 3), 0.25)) * NETHER_I * (vsBrightness*0.5 + 0.5);
		#else
			vec3 sceneLighting = vec3(0.0);
		#endif
    #endif

	#ifdef DYNAMIC_SHADER_LIGHT
		float handLight = min(float(heldBlockLightValue2 + heldBlockLightValue), 15.0) / 15.0;

		if (heldItemId == 12001 || heldItemId2 == 12001) // Lava Bucket
			#if defined GBUFFERS_HAND && defined COMPBR
				handLight = 0.87, emissive = max(albedo.r * 2.0 - albedo.g - albedo.b, 0.0) * 0.5;
			#else
				handLight = 1.0;
			#endif
		if (heldItemId == 12002 || heldItemId2 == 12002) // Optifine Item Emissives
			handLight = min(handLight + 0.5, 1.0);

		float handLightFactor = 1.0 - min(DYNAMIC_LIGHT_DISTANCE * handLight, lViewPos) / (DYNAMIC_LIGHT_DISTANCE * handLight);
		#ifdef GBUFFERS_WATER
			if (mat > 0.05) handLight *= 0.9;
		#endif
		#ifdef GBUFFERS_HAND
			handLight = min(handLight, 0.95);
		#endif
		float finalHandLight = handLight * handLightFactor;
		lightmap.x = max(finalHandLight * 0.95, lightmap.x);
	#endif

	float newLightmap  = pow(lightmap.x, 10.0) * 5 + max((lightmap.x - 0.05) * 0.925, 0.0) * (vsBrightness*0.25 + 0.9);
	
	#ifdef BLOCKLIGHT_FLICKER
		float frametimeM = frametime * 0.5;
		float lightFlicker = min(((1 - clamp(sin(fract(frametimeM*2.7) + frametimeM*3.7) - 0.75, 0.0, 0.25) * BLOCKLIGHT_FLICKER_STRENGTH)
					* max(fract(frametimeM*1.4), (1 - BLOCKLIGHT_FLICKER_STRENGTH * 0.25))) / (1.0 - BLOCKLIGHT_FLICKER_STRENGTH * 0.2)
					, 0.8) * 1.25
					* 0.8 + 0.2 * clamp((cos(fract(frametimeM*0.47) * fract(frametimeM*1.17) + fract(frametimeM*2.17))) * 1.5, 1.0 - BLOCKLIGHT_FLICKER_STRENGTH * 0.25, 1.0);
		newLightmap *= lightFlicker;
	#endif

	#ifdef RANDOM_BLOCKLIGHT
		float CLr = texture2D(noisetex, 0.00006 * (worldPos.xz + cameraPosition.xz)).r;
		float CLg = texture2D(noisetex, 0.00009 * (worldPos.xz + cameraPosition.xz)).r;
		float CLb = texture2D(noisetex, 0.00014 * (worldPos.xz + cameraPosition.xz)).r;
		blocklightCol = vec3(CLr, CLg, CLb);
		blocklightCol *= blocklightCol * BLOCKLIGHT_I * 2.22;
	#endif

	#ifdef COLORED_LIGHT
		#ifdef GBUFFERS_TERRAIN
			if (lightVarying > 0.5) {
				if (lightVarying < 1.5) {
					lightAlbedo = albedo;
				}
				else if (lightVarying < 2.5) {
					#ifdef COMPBR
					lightAlbedo = float(eyeBrightness.x < 144) * emissive * albedo;
					#else
					lightAlbedo = float(eyeBrightness.x < 144) * albedo;
					#endif
				}
				else if (lightVarying < 3.5) {
					lightAlbedo = vec3(0.7, 0.5, 0.2);
				}
				else if (lightVarying < 4.5) { // Sea Lantern, Beacon, End Rod
					lightAlbedo = albedo * vec3(0.6, 0.85, 1.0);
				}
			}
			//if (lViewPos > 16.0) lightAlbedo = vec3(0.0);
		#endif

		vec3 blocklightComplex = texture2D(colortex9, texCoord).rgb;
		blocklightComplex *= 0.75 + 2.0 * blocklightComplex.b;
		
		//float colorDistance = 24.0;
		//colorDistance = max(colorDistance- lViewPos, 0.0) / colorDistance;
		//colorDistance = 0.7 * colorDistance;

		blocklightCol = mix(blocklightCol, blocklightComplex, 0.7);

		#ifdef DYNAMIC_SHADER_LIGHT
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
vec3 glowstoneColor     = vec3(0.9, 0.5, 0.2);
vec3 sealanternColor    = vec3(0.5, 0.57, 0.78);
vec3 shroomlightColor   = vec3(1.0, 0.3, 0.125);
vec3 jackolanternColor  = vec3(0.9, 0.5, 0.2);
vec3 beaconColor        = vec3(0.33, 0.51, 0.6);
vec3 endrodColor        = vec3(0.53, 0.5, 0.47);
vec3 redstonetorchColor = vec3(1.0, 0.0, 0.0);
vec3 lanternColor       = vec3(0.9, 0.5, 0.2);
vec3 soullanternColor   = vec3(0.0, 0.7, 1.0);
vec3 torchColor         = vec3(0.9, 0.5, 0.2);
vec3 soultorchColor     = vec3(0.0, 0.7, 1.0);
vec3 respawnanchorColor = vec3(0.3, 0.0, 1.0);
vec3 campfireColor      = vec3(0.94, 0.5, 0.2);
vec3 soulcampfireColor  = vec3(0.0, 0.7, 1.0);
vec3 lavabucketColor    = vec3(0.94, 0.5, 0.2);
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
vec3 heldLightAlbedo1 = vec3(0.0);
vec3 heldLightAlbedo2 = vec3(0.0);
if (heldItemId < 11012.5) {
    if (heldItemId < 11005.5) {
        if (heldItemId == 11001) // Glowstone
            heldLightAlbedo1 = glowstoneColor;
        else if (heldItemId == 11002) // Sea Lantern
            heldLightAlbedo1 = sealanternColor;
        else if (heldItemId == 11004) // Shroomlight
            heldLightAlbedo1 = shroomlightColor;
    } else {
        if (heldItemId == 11007) // Jack o'Lantern
            heldLightAlbedo1 = jackolanternColor;
        else if (heldItemId == 11008) // Beacon
            heldLightAlbedo1 = beaconColor;
        else if (heldItemId == 11009) // End Rod
            heldLightAlbedo1 = endrodColor;
        else if (heldItemId == 11012) // Redstone Torch
            heldLightAlbedo1 = redstonetorchColor;
    }
} else {
    if (heldItemId < 11022.5) {
        if (heldItemId == 11017) // Lantern
            heldLightAlbedo1 = lanternColor;
        else if (heldItemId == 11018) // Soul Lantern
            heldLightAlbedo1 = soullanternColor;
        else if (heldItemId == 11021) // Torch
            heldLightAlbedo1 = torchColor;
        else if (heldItemId == 11022) // Soul Torch
            heldLightAlbedo1 = soultorchColor;
    } else {
        if (heldItemId == 11023) // Crying Obsidian, Respawn Anchor
            heldLightAlbedo1 = respawnanchorColor;
        else if (heldItemId == 11024) // Campfire
            heldLightAlbedo1 = campfireColor;
        else if (heldItemId == 11025) // Soul Campfire
            heldLightAlbedo1 = soulcampfireColor;
        else if (heldItemId == 12001) // Lava Bucket
            heldLightAlbedo1 = lavabucketColor;
    }
}
if (heldItemId2 < 11012.5) {
    if (heldItemId2 < 11005.5) {
        if (heldItemId2 == 11001) // Glowstone
            heldLightAlbedo2 = glowstoneColor;
        else if (heldItemId2 == 11002) // Sea Lantern
            heldLightAlbedo2 = sealanternColor;
        else if (heldItemId2 == 11004) // Shroomlight
            heldLightAlbedo2 = shroomlightColor;
    } else {
        if (heldItemId2 == 11007) // Jack o'Lantern
            heldLightAlbedo2 = jackolanternColor;
        else if (heldItemId2 == 11008) // Beacon
            heldLightAlbedo2 = beaconColor;
        else if (heldItemId2 == 11009) // End Rod
            heldLightAlbedo2 = endrodColor;
        else if (heldItemId2 == 11012) // Redstone Torch
            heldLightAlbedo2 = redstonetorchColor;
    }
} else {
    if (heldItemId2 < 11022.5) {
        if (heldItemId2 == 11017) // Lantern
            heldLightAlbedo2 = lanternColor;
        else if (heldItemId2 == 11018) // Soul Lantern
            heldLightAlbedo2 = soullanternColor;
        else if (heldItemId2 == 11021) // Torch
            heldLightAlbedo2 = torchColor;
        else if (heldItemId2 == 11022) // Soul Torch
            heldLightAlbedo2 = soultorchColor;
    } else {
        if (heldItemId2 == 11023) // Crying Obsidian, Respawn Anchor
            heldLightAlbedo2 = respawnanchorColor;
        else if (heldItemId2 == 11024) // Campfire
            heldLightAlbedo2 = campfireColor;
        else if (heldItemId2 == 11025) // Soul Campfire
            heldLightAlbedo2 = soulcampfireColor;
        else if (heldItemId2 == 12001) // Lava Bucket
            heldLightAlbedo2 = lavabucketColor;
    }
}
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
vec3 heldLightAlbedo = heldLightAlbedo1 + heldLightAlbedo2;

if (dot(heldLightAlbedo, heldLightAlbedo) > 0.001) {
    heldLightAlbedo /= length(heldLightAlbedo);
    heldLightAlbedo *= BLOCKLIGHT_I * 0.4;
    float mixFactor = finalHandLight * finalHandLight;
    blocklightCol = mix(blocklightCol, heldLightAlbedo, max(mixFactor, 0.0));
}
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
		#endif
	#endif

    vec3 blockLighting = blocklightCol * newLightmap * newLightmap;

	#ifndef MIN_LIGHT_EVERYWHERE
		float minLighting = 0.000000000001 + (MIN_LIGHT * 0.0035 * (vsBrightness*0.08 + 0.01)) * (1.0 - eBS);
	#else
		float minLighting = 0.000000000001 + (MIN_LIGHT * 0.0035 * (vsBrightness*0.08 + 0.01));
	#endif
	#ifdef GBUFFERS_WATER
		if (mat > 0.05) minLighting += MIN_LIGHT * 0.0035 * (vsBrightness*0.08 + 0.01);
	#endif
	
	float shade = pow(quarterNdotU, SHADING_STRENGTH);

	vec3 emissiveLighting = albedo.rgb * emissive * 20.0 / shade;

    float nightVisionLighting = nightVision * 0.25;

	smoothLighting = clamp(smoothLighting, 0.0, 1.0);
	smoothLighting = pow(smoothLighting, 
						(2.0 - min(length(fullShadow * shadowMult), 1.5)) * VAO_STRENGTH
						);

	if (materialAO < 1.0) {
		smoothLighting *= pow(materialAO, max(1.0 - shadowTime * length(shadow) * NdotL - lmCoord.x, 0.0));
	}

    albedo *= sceneLighting + blockLighting + emissiveLighting + nightVisionLighting + minLighting;
	albedo *= shade;
	if (smoothLighting > 0.01) albedo *= smoothLighting;

	#if defined WATER_CAUSTICS && defined OVERWORLD && !defined GBUFFERS_WATER
		#ifdef PROJECTED_CAUSTICS
		if (water > 0.0 || isEyeInWater == 1) {
		#else
		if (isEyeInWater == 1) {
		#endif
			vec3 albedoCaustic = albedo;

			float skyLightMap = lightmap.y * lightmap.y * (3.0 - 2.0 * lightmap.y);
			
			float causticfactor = 1.0 - lightmap.x * 0.8;

			vec3 causticpos = worldPos.xyz + cameraPosition.xyz;
			float caustic = getCausticWaves(causticpos * 0.75);
			vec3 causticcol = underwaterColor.rgb / UNDERWATER_I;
			
			#ifdef PROJECTED_CAUSTICS
				if (isEyeInWater == 0) {
					//causticfactor *= (1.0 - skyLightMap * skyLightMap);
					causticfactor *= 1.0 - pow2(pow2((1.0 - skyLightMap)));
					causticfactor *= 10.0;

					causticcol *= causticcol;
					causticcol *= causticcol;
					albedoCaustic = albedo.rgb * mix(underwaterColor.rgb * 20.0, causticcol * 1000.0, sunVisibility);
					causticcol *= 120.0;
				} else {
			#endif
					causticfactor *= (1.0 - skyLightMap * skyLightMap) * shadow * NdotL * (1.0 - rainStrengthS);
					causticfactor *= 0.1 + 0.9 * (1.0 - pow2(1.0 - skyLightMap));

					albedoCaustic = (albedo.rgb + albedo.rgb * underwaterColor.rgb * 16.0) * 0.225;
					causticcol = sqrt(causticcol) * 30.0;
			#ifdef PROJECTED_CAUSTICS
				}
			#endif

			vec3 lightcaustic = caustic * causticfactor * causticcol * UNDERWATER_I;
			albedoCaustic *= 1.0 + lightcaustic;

			#ifdef PROJECTED_CAUSTICS
				if (isEyeInWater == 0) albedo = mix(albedo, albedoCaustic, max(water - rainStrengthS, 0.0));
				else albedo = albedoCaustic;
			#else
				albedo = albedoCaustic;
			#endif
		}
	#endif

	#if defined GBUFFERS_HAND && defined HAND_BLOOM_REDUCTION
		float albedoStrength = (albedo.r + albedo.g + albedo.b) / 10.0;
		if (albedoStrength > 1.0) albedo.rgb = albedo.rgb * max(2.0 - pow(albedoStrength, 1.0), 0.34);
	#endif

	//if (water > 0.0) albedo = vec3(1.0, 0.0, 1.0);
}

#if AA == 2 || AA == 3
//Jitter offset from Chocapic13
uniform float framemod8;

vec2 jitterOffsets[8] = vec2[8]( // LiteTAA Jitter
							vec2( 0.125,-0.375),
							vec2(-0.125, 0.375),
							vec2( 0.625, 0.125),
							vec2( 0.375,-0.625),
							vec2(-0.625, 0.625),
							vec2(-0.875,-0.125),
							vec2( 0.375,-0.875),
							vec2( 0.875, 0.875)
						);
							   
vec2 TAAJitter(vec2 coord, float w) {
	vec2 offset = jitterOffsets[int(framemod8)] *0.125* (w / vec2(viewWidth, viewHeight));
	return coord + offset;
}
#endif
#if AA == 4
//Jitter offset from Chocapic13
uniform float framemod8;

vec2 jitterOffsets[8] = vec2[8](
							vec2( 0.125,-0.375),
							vec2(-0.125, 0.375),
							vec2( 0.625, 0.125),
							vec2( 0.375,-0.625),
							vec2(-0.625, 0.625),
							vec2(-0.875,-0.125),
							vec2( 0.375,-0.875),
							vec2( 0.875, 0.875)
						);
							   
vec2 TAAJitter(vec2 coord, float w) {
	vec2 offset = jitterOffsets[int(framemod8)] * (w / vec2(viewWidth, viewHeight));
	return coord + offset;
}
#endif

#ifdef ADV_MAT
//Spheremap Transform from https://aras-p.info/texts/CompactNormalStorage.html
vec2 EncodeNormal(vec3 n) {
    float f = sqrt(n.z * 8.0 + 8.0);
    return n.xy / f + 0.5;
}

vec3 DecodeNormal(vec2 enc) {
    vec2 fenc = enc * 4.0 - 2.0;
    float f = dot(fenc,fenc);
    float g = sqrt(1.0 - f / 4.0);
    vec3 n;
    n.xy = fenc * g;
    n.z = 1.0 - f / 2.0;
    return n;
}
//GGX area light approximation from Horizon Zero Dawn
float GetNoHSquared(float radiusTan, float NoL, float NoV, float VoL) {
    float radiusCos = 1.0 / sqrt(1.0 + radiusTan * radiusTan);
    
    float RoL = 2.0 * NoL * NoV - VoL;
    if (RoL >= radiusCos)
        return 1.0;

    float rOverLengthT = radiusCos * radiusTan / sqrt(1.0 - RoL * RoL);
    float NoTr = rOverLengthT * (NoV - RoL * NoL);
    float VoTr = rOverLengthT * (2.0 * NoV * NoV - 1.0 - RoL * VoL);

    float triple = sqrt(clamp(1.0 - NoL * NoL - NoV * NoV - VoL * VoL + 2.0 * NoL * NoV * VoL, 0.0, 1.0));
    
    float NoBr = rOverLengthT * triple, VoBr = rOverLengthT * (2.0 * triple * NoV);
    float NoLVTr = NoL * radiusCos + NoV + NoTr, VoLVTr = VoL * radiusCos + 1.0 + VoTr;
    float p = NoBr * VoLVTr, q = NoLVTr * VoLVTr, s = VoBr * NoLVTr;    
    float xNum = q * (-0.5 * p + 0.25 * VoBr * NoLVTr);
    float xDenom = p * p + s * ((s - 2.0 * p)) + NoLVTr * ((NoL * radiusCos + NoV) * VoLVTr * VoLVTr + 
                   q * (-0.5 * (VoLVTr + VoL * radiusCos) - 0.5));
    float twoX1 = 2.0 * xNum / (xDenom * xDenom + xNum * xNum);
    float sinTheta = twoX1 * xDenom;
    float cosTheta = 1.0 - twoX1 * xNum;
    NoTr = cosTheta * NoTr + sinTheta * NoBr;
    VoTr = cosTheta * VoTr + sinTheta * VoBr;
    
    float newNoL = NoL * radiusCos + NoTr;
    float newVoL = VoL * radiusCos + VoTr;
    float NoH = NoV + newNoL;
    float HoH = 2.0 * newVoL + 2.0;
    return clamp(NoH * NoH / HoH, 0.0, 1.0);
}

float SchlickGGX(float NoL, float NoV, float roughness) {
    float k = roughness * 0.5;
        
    float smithL = 0.5 / (NoL * (1.0 - k) + k);
    float smithV = 0.5 / (NoV * (1.0 - k) + k);

    return smithL * smithV;
}

float GGX(vec3 normal, vec3 viewPos, vec3 lightVec, float smoothness, float f0, float sunSize) {
    float roughness = 1.0 - smoothness;
    if (roughness < 0.05) roughness = 0.05;
    float roughnessP = roughness;
    roughness *= roughness; roughness *= roughness;
    
    vec3 halfVec = normalize(lightVec - viewPos);

    float dotLH = clamp(dot(halfVec, lightVec), 0.0, 1.0);
    float dotNL = clamp(dot(normal,  lightVec), 0.0, 1.0);
    float dotNV = dot(normal, -viewPos);
    float dotNH = GetNoHSquared(sunSize, dotNL, dotNV, dot(-viewPos, lightVec));
    
    float denom = dotNH * roughness - dotNH + 1.0;
    float D = roughness / (3.141592653589793 * denom * denom);
    float F = exp2((-5.55473 * dotLH - 6.98316) * dotLH) * (1.0 - f0) + f0;
    float k2 = roughness * 0.5;

    float specular = max(dotNL * dotNL * D * F / (dotLH * dotLH * (1.0 - k2) + k2), 0.0);
    specular = max(specular, 0.0);
    specular = specular / (0.125 * specular + 1.0);

    float schlick = SchlickGGX(dotNL, dotNV, roughness);
    schlick = pow(schlick * 0.5, roughnessP);
    specular *= clamp(schlick, 0.0, 1.25);

    if (sunVisibility == 0.0) specular *= float(moonPhase == 0) * 0.35 + 0.65 - float(moonPhase == 4) * 0.65;
    else specular *= 1.5;

    return specular * (1.0 - isEyeInWater*0.75);
}

float stylisedGGX(vec3 normal, vec3 oldNormal, vec3 nViewPos, vec3 lightVec, float f0) {

    vec3 halfVec = normalize(lightVec - nViewPos);

    float dotLH = clamp(dot(halfVec, lightVec), 0.0, 1.0);
    float dotOldL = clamp(dot(oldNormal,  lightVec), 0.0, 1.0);
    float dotNmOL = clamp(dot(normal - oldNormal,  lightVec), 0.0, 1.0);

    float sunSize = 0.037;
    
    float dotNH = GetNoHSquared(sunSize, dotOldL, dot(oldNormal, -nViewPos), dot(-nViewPos, lightVec));

    dotOldL *= dotOldL;
    
    float roughness = 0.05;
    
    float denom = dotNH * roughness - dotNH + 1.0;
    float D = roughness / (3.141592653589793 * denom * denom);
    float F = exp2((-5.55473 * dotLH - 6.98316) * dotLH) * (1.0 - f0) + f0;
    float k2 = roughness * 0.25;

    float specular = max(dotOldL * D * F / (dotLH * dotLH * (1.0 - k2) + k2), 0.0);
    specular = max(specular, 0.0);
    specular = specular / (0.125 * specular + 1.0);

    dotNmOL *= dotNH * dotNH;
    dotNmOL *= dotNmOL * 350.0 * SUN_MOON_WATER_REF;
    dotNmOL *= dotNmOL;
    dotNmOL = max(dotNmOL * 0.25, sunVisibility * pow2(dotNmOL * dotNmOL));
    specular *= 0.075 + 9.0 * min(dotNmOL * 6.0, 50.0);
    specular *= 0.4 + 1.71 * dotOldL;

    if (sunVisibility == 0.0) {
        specular *= 0.25 * MOON_WATER_REF;
        specular *= float(moonPhase == 0) * 0.35 + 0.65 - float(moonPhase == 4) * 0.65;
    }

    return max(specular * (1.0 - isEyeInWater*0.75), 0.0);
}

vec3 GetMetalCol(float f0) {
    int metalidx = int(f0 * 255.0);

    if (metalidx == 230) return vec3(0.24867, 0.22965, 0.21366);
    if (metalidx == 231) return vec3(0.88140, 0.57256, 0.11450);
    if (metalidx == 232) return vec3(0.81715, 0.82021, 0.83177);
    if (metalidx == 233) return vec3(0.27446, 0.27330, 0.27357);
    if (metalidx == 234) return vec3(0.84430, 0.48677, 0.22164);
    if (metalidx == 235) return vec3(0.36501, 0.35675, 0.37653);
    if (metalidx == 236) return vec3(0.42648, 0.37772, 0.31138);
    if (metalidx == 237) return vec3(0.91830, 0.89219, 0.83662);
    return vec3(1.0);
}

vec3 GetSpecularHighlight(float smoothness, float metalness, float f0, vec3 specularColor,
                          vec3 rawAlbedo, float shadow, vec3 normal, vec3 viewPos) {
    #ifndef SHADOWS
        return vec3(0.0);
    #endif
                              
    if (dot(shadow, shadow) < 0.001) return vec3(0.0);

    #ifdef END
        smoothness *= 0.0;
    #endif

    float specular = GGX(normal, normalize(viewPos), lightVec, smoothness, f0,
                         0.01 * sunVisibility + 0.06);
    specular *= sqrt1inv(rainStrengthS);

    #ifdef SHADOWS
        specular *= shadowFade;
    #endif
    
    specularColor = pow(specularColor, vec3(1.0 - 0.5 * metalness));
	
	#ifdef COMPBR
		specularColor *= pow(rawAlbedo, vec3(metalness * 0.8));
	#else
		#if RP_SUPPORT == 3
            if (metalness > 0.5) {
                if (f0 < 1.0) specularColor *= GetMetalCol(f0);
                else specularColor *= rawAlbedo;
            }
		#else
		    specularColor *= pow(rawAlbedo, vec3(metalness));
		#endif
	#endif

    return specular * specularColor * shadow;
}

#ifndef COMPBR
void GetMaterials(out float smoothness, out float metalness, out float f0, out float metalData, 
                  inout float emissive, out float ao, out vec3 normalMap,
                  vec2 newCoord, vec2 dcdx, vec2 dcdy) {
	#ifdef MC_SPECULAR_MAP 
		#ifdef WRONG_MIPMAP_FIX
			vec4 specularMap = texture2DLod(specular, newCoord, 0.0);
		#else
			vec4 specularMap = texture2D(specular, newCoord);
		#endif
	#else
		vec4 specularMap = vec4(0.0, 0.0, 0.0, 1.0);
	#endif

	#ifdef NORMAL_MAPPING
		normalMap = texture2DGradARB(normals, newCoord, dcdx, dcdy).xyz;
	#else
		normalMap = texture2D(normals, newCoord).xyz;
	#endif

	normalMap += vec3(0.5, 0.5, 0.0);
	normalMap = pow(normalMap, vec3(NORMAL_MULTIPLIER));
	normalMap -= vec3(0.5, 0.5, 0.0);
	
	#if RP_SUPPORT == 4
		smoothness = specularMap.r;
		
		metalness = specularMap.g;
		f0 = 0.78 * metalness + 0.02;
		metalData = metalness;

		emissive = mix(specularMap.b, 1.0, emissive);
		ao = 1.0;

		normalMap = normalMap * 2.0 - 1.0;
	#else
		smoothness = specularMap.r;

		f0 = specularMap.g;
		metalness = f0 >= 0.9 ? 1.0 : 0.0;
		metalData = f0;
		
		ao = texture2D(normals, newCoord).z;
		ao *= ao;

		emissive = mix(specularMap.a < 1.0 ? specularMap.a : 0.0, 1.0, emissive);
		
		normalMap = normalMap * 2.0 - 1.0;
		float normalCheck = normalMap.x + normalMap.y;
		if (normalCheck > -1.999) {
			if (length(normalMap.xy) > 1.0) normalMap.xy = normalize(normalMap.xy);
			normalMap.z = sqrt(1.0 - dot(normalMap.xy, normalMap.xy));
			normalMap = normalize(clamp(normalMap, vec3(-1.0), vec3(1.0)));
		} else {
			normalMap = vec3(0.0, 0.0, 1.0);
			ao = 1.0;
		}
	#endif

	#ifdef COMPATIBILITY_MODE
		emissive *= 0.25;
	#endif
	
	emissive *= EMISSIVE_MULTIPLIER;
	
	ao = clamp(ao, 0.01, 1.0);
}
#endif

#if defined PARALLAX || defined SELF_SHADOW
//Thanks to Jessie for dithering
float Bayer2  (vec2 c) { c = 0.5 * floor(c); return fract(1.5 * fract(c.y) + c.x); }
float Bayer4  (vec2 c) { return 0.25 * Bayer2  (0.5 * c) + Bayer2(c); }
float Bayer8  (vec2 c) { return 0.25 * Bayer4  (0.5 * c) + Bayer2(c); }
float Bayer16 (vec2 c) { return 0.25 * Bayer8  (0.5 * c) + Bayer2(c); }
float Bayer32 (vec2 c) { return 0.25 * Bayer16 (0.5 * c) + Bayer2(c); }
float Bayer64 (vec2 c) { return 0.25 * Bayer32 (0.5 * c) + Bayer2(c); }
float Bayer128(vec2 c) { return 0.25 * Bayer64 (0.5 * c) + Bayer2(c); }
float Bayer256(vec2 c) { return 0.25 * Bayer128(0.5 * c) + Bayer2(c); }
vec4 ReadNormal(vec2 coord) {
    coord = fract(coord) * vTexCoordAM.pq + vTexCoordAM.st;
	return texture2DGradARB(normals, coord, dcdx, dcdy);
}

void GetParallaxCoord(float parallaxFade, inout vec2 newCoord) {
    vec2 coord = vTexCoord.st;
	
    if (parallaxFade < 1.0) {
        vec3 normalMap = ReadNormal(vTexCoord.st).xyz * 2.0 - 1.0;
		
        float normalCheck = normalMap.x + normalMap.y;
        float minHeight = 1.0 - 1.0 / PARALLAX_QUALITY;

        if (viewVector.z < 0.0 && ReadNormal(vTexCoord.st).a < minHeight && normalCheck > -1.999) {
            float multiplier = 0.2 * (1.0 - parallaxFade) * PARALLAX_DEPTH /
                                (-viewVector.z * PARALLAX_QUALITY);
            vec2 interval = viewVector.xy * multiplier;
            for(int i = 0; i < PARALLAX_QUALITY; i++) {
                if (ReadNormal(coord).a < 1.0 - float(i) / PARALLAX_QUALITY) coord += interval;
                else break;
            }
            newCoord = fract(coord.st) * vTexCoordAM.pq + vTexCoordAM.st;
        }
    }
}

float GetParallaxShadow(float parallaxFade, vec2 coord, vec3 lightVec, mat3 tbn) {
    float parallaxshadow = 1.0;
    float minHeight = 1.0 - 1.0 / PARALLAX_QUALITY;

    if (dist < PARALLAX_DISTANCE + 32.0) {
        float height = texture2DGradARB(normals, coord, dcdx, dcdy).a;
        if (height < minHeight) {
            vec3 parallaxdir = tbn * lightVec;
            parallaxdir.xy *= 0.2 * SELF_SHADOW_ANGLE * PARALLAX_DEPTH;
            vec2 newvTexCoord = (coord - vTexCoordAM.st) / vTexCoordAM.pq;
            float step = 1.28 / PARALLAX_QUALITY;
            
            for(int i = 0; i < PARALLAX_QUALITY / 4; i++) {
                float currentHeight = height + parallaxdir.z * step * i;
                vec2 parallaxCoord = fract(newvTexCoord + parallaxdir.xy * i * step) * 
                                     vTexCoordAM.pq + vTexCoordAM.st;
                float offsetHeight = texture2DGradARB(normals, parallaxCoord, dcdx, dcdy).a;
                parallaxshadow *= clamp(1.0 - (offsetHeight - currentHeight) * 40.0, 0.0, 1.0);
                if (parallaxshadow < 0.01) break;
            }
            
            parallaxshadow = mix(parallaxshadow, 1.0, parallaxFade);
        }
    }

    return parallaxshadow;
}
#endif

#ifdef DIRECTIONAL_LIGHTMAP
mat3 GetLightmapTBN(vec3 viewPos) {
    mat3 lightmapTBN = mat3(normalize(dFdx(viewPos)), normalize(dFdy(viewPos)), vec3(0.0));
    lightmapTBN[2] = cross(lightmapTBN[0], lightmapTBN[1]);

    return lightmapTBN;
}

float DirectionalLightmap(float lightmap, float lightmapRaw, vec3 normal, mat3 lightmapTBN) {
    if (lightmap < 0.001) return lightmap;

    vec2 deriv = vec2(dFdx(lightmapRaw), dFdy(lightmapRaw)) * 256.0;
    vec3 dir = normalize(vec3(deriv.x * lightmapTBN[0] +
                              0.0005  * lightmapTBN[2] +
                              deriv.y * lightmapTBN[1]));
    
    float pwr = clamp(dot(normal, dir), -1.0, 1.0);
    if (abs(pwr) > 0.0)
        pwr = pow(abs(pwr), 9.0 / DIRECTIONAL_LIGHTMAP_STRENGTH) * sign(pwr) * lightmap;
    if (length(deriv) > 0.001)
        lightmap = pow(lightmap, 1.0 - pwr);

	return lightmap;
}
#endif

#if defined REFLECTION_RAIN && defined OVERWORLD
float GetPuddles(vec2 pos) {
	float noise = texture2D(noisetex, pos).r;
		  noise+= texture2D(noisetex, pos * 0.5).r    *2.0;
		  noise+= texture2D(noisetex, pos * 0.25).r   *4.0;
		  noise+= texture2D(noisetex, pos * 0.125).r  *8.0;

		noise *= REFLECTION_RAIN_COVERAGE * 0.055;
		noise = max((noise-15.5) * 0.8 - 1.2 , 0.0);
		#ifdef RAIN_REF_BIOME_CHECK
			noise *= isRainy;
		#endif
		#ifndef RAIN_REF_FORCED
			float wetnessM = wetness;
		#else
			float wetnessM = 1.0;
		#endif
		noise *= wetnessM;
		noise /= sqrt(noise * noise + 1.0);
		#if REFLECTION_RAIN_COVERAGE == 100
			noise = mix(noise, 1.0, min(sqrt1(wetnessM) * 2.0, 1.0));
		#endif

	noise = clamp((noise - 0.75) * 4.5, 0.0, 1.0);

	return noise;
}
#endif
#endif

//Program//
void irisMain() {
	vec4 albedo = vec4(0.0);
	vec3 albedoP = vec3(0.0);
	if (mipmapDisabling < 0.5) {
		albedoP = texture2D(texture, texCoord).rgb;
		#if defined END && defined COMPATIBILITY_MODE && !defined SEVEN
			albedo.a = texture2DLod(texture, texCoord, 0.0).a;
		#else
			albedo.a = texture2D(texture, texCoord).a;
		#endif
	} else {
		albedoP = texture2DLod(texture, texCoord, 0.0).rgb;
		albedo.a = texture2DLod(texture, texCoord, 0.0).a;
	}
	albedo.rgb = albedoP;
	if (mat < 10000.0) albedo.rgb *= color.rgb;
	albedo.rgb = clamp(albedo.rgb, vec3(0.0), vec3(1.0));
	
	float material = floor(mat); //Ah yes this is a floor mat
	vec3 newNormal = normal;
	vec3 lightAlbedo = vec3(0.0);
	#ifdef GREEN_SCREEN
		float greenScreen = 0.0;
	#endif

	#ifdef ADV_MAT
		float smoothness = 0.0, metalData = 0.0, metalness = 0.0, f0 = 0.0, skymapMod = 0.0;
		vec3 rawAlbedo = vec3(0.0), normalMap = vec3(0.0, 0.0, 1.0);

		#if !defined COMPBR || defined NORMAL_MAPPING
			vec2 newCoord = vTexCoord.st * vTexCoordAM.pq + vTexCoordAM.st;
		#endif
		
		#if defined PARALLAX || defined SELF_SHADOW
			float parallaxFade = clamp((dist - PARALLAX_DISTANCE) / 32.0, 0.0, 1.0);
		#endif

		#ifdef PARALLAX
			float skipParallax = float(blockEntityId == 63 || material == 4.0); // Fixes broken signs and lava having broken pom
			if (skipParallax < 0.5) {
				GetParallaxCoord(parallaxFade, newCoord);
				if (mipmapDisabling < 0.5) albedo = texture2DGradARB(texture, newCoord, dcdx, dcdy) * vec4(color.rgb, 1.0);
				else 					   albedo = texture2DLod(texture, newCoord, 0.0) * vec4(color.rgb, 1.0);
			}
		#endif
	#endif
	
	#ifndef COMPATIBILITY_MODE
		float albedocheck = albedo.a;
	#else
		float albedocheck = 1.0;
	#endif

	if (albedocheck > 0.00001) {
		float foliage = float(material == 1.0);
		float leaves  = float(material == 2.0);

		//Emission
		vec2 lightmap = clamp(lmCoord, vec2(0.0), vec2(1.0));
		float emissive = specB * 4.0;
		
		//Subsurface Scattering
		#if SHADOW_SUBSURFACE == 0
			float subsurface = 0.0;
		#elif SHADOW_SUBSURFACE == 1
			float subsurface = foliage * SCATTERING_FOLIAGE;
		#elif SHADOW_SUBSURFACE == 2
			float subsurface = foliage * SCATTERING_FOLIAGE + leaves * SCATTERING_LEAVES;
		#endif

		#ifndef SHADOWS
			if (leaves > 0.5) subsurface *= 0.5;
			else subsurface = pow2(subsurface * subsurface);
		#endif

		#ifdef COMPBR
			float lAlbedoP = length(albedoP);
		
			if (mat > 10000.0) { // More control over lAlbedoP at the cost of color.rgb
				if (mat > 17500.0) {
					if (mat > 25000.0) { // 30000 - Inverted lAlbedoP
						lAlbedoP = max(1.73 - lAlbedoP, 0.0) * color.r + color.g;
					} else { // 20000 - Channel Controlled lAlbedoP
						lAlbedoP = length(albedoP * max(color.rgb, vec3(0.0)));
						if (color.g < -0.0001) lAlbedoP = max(lAlbedoP + color.g * albedo.g * 0.1, 0.0);
					}
				} else { // 15000 - Difference Based lAlbedoP
					vec3 averageAlbedo = texture2DLod(texture, texCoord, 100.0).rgb;
					lAlbedoP = sqrt2(length(albedoP.rgb - averageAlbedo) + color.r) * color.g * 20.0;
					#ifdef GREEN_SCREEN
						if (albedo.g * 1.4 > albedo.r + albedo.b && albedo.g > 0.6 && albedo.r * 2.0 > albedo.b)
							greenScreen = 1.0;
					#endif
				}
				
			}

		//Integrated Emission
			if (specB > 1.02) {
				emissive = pow(lAlbedoP, specB) * fract(specB) * 20.0;
			}

		//Integrated Smoothness
			smoothness = specR;
			if (specR > 1.02) {
				float lAlbedoPsp = lAlbedoP;
				float spec = specR;
				if (spec > 1000.0) lAlbedoPsp = 2.0 - lAlbedoP, spec -= 1000.0;
				smoothness = pow(lAlbedoPsp, spec * 0.1) * fract(specR) * 5.0;
				smoothness = min(smoothness, 1.0);
			}

		//Integrated Metalness+
			metalness = specG;
			if (specG > 10.0) {
				metalness = 3.0 - lAlbedoP * specG * 0.01;
				metalness = min(metalness, 1.0);
			}
		#endif

		//Main
		vec3 screenPos = vec3(gl_FragCoord.xy / vec2(viewWidth, viewHeight), gl_FragCoord.z);
		#if AA > 1
			vec3 viewPos = ToNDC(vec3(TAAJitter(screenPos.xy, -0.5), screenPos.z));
		#else
			vec3 viewPos = ToNDC(screenPos);
		#endif
		vec3 worldPos = ToWorld(viewPos);
		float lViewPos = length(viewPos.xyz);

		float ao = 1.0;
		float cauldron = 0.0;

		#ifdef ADV_MAT
			#if defined REFLECTION_RAIN && defined RAIN_REF_BIOME_CHECK
				float noRain = float(material == 3.0);
			#endif

			#ifndef COMPBR
				GetMaterials(smoothness, metalness, f0, metalData, emissive, ao, normalMap, newCoord, dcdx, dcdy);
			#else
				if (mat > 100.5 && mat < 10000.0) {
				if (mat < 109.5) {
				if (mat < 104.5) {
					if (material == 101.0) { // Redstone Stuff
						float comPos = fract(worldPos.y + cameraPosition.y);
						if (comPos > 0.18) emissive = float((albedo.r > 0.65 && albedo.r > albedo.b * 1.0) || albedo.b > 0.99);
						else emissive = float(albedo.r > albedo.b * 3.0 && albedo.r > 0.5) * 0.125;
						emissive *= max(0.65 - 0.3 * dot(albedo.rgb, vec3(1.0, 1.0, 0.0)), 0.0);
						if (specB > 900.0) { // Observer
							emissive *= float(albedo.r > albedo.g * 1.5);
						}
					}
					#ifdef EMISSIVE_NETHER_STEMS
					else if (material == 102.0) { // Warped Stem+
						float core = float(albedo.r < 0.1);
						float edge = float(albedo.b > 0.35 && albedo.b < 0.401 && core == 0.0);
						emissive = core * 0.195 + 0.035 * edge;
					}
					else if (material == 103.0) { // Crimson Stem+
						emissive = float(albedo.b < 0.16);
						emissive = min(pow2(lAlbedoP * lAlbedoP) * emissive * 3.0, 0.3);
					}
					#endif
					else if (material == 104.0) { // Command Blocks
						vec3 comPos = fract(worldPos.xyz + cameraPosition.xyz);
						comPos = abs(comPos - vec3(0.5));
						float comPosM = min(max(comPos.x, comPos.y), min(max(comPos.x, comPos.z), max(comPos.y, comPos.z)));
						emissive = 0.0;
						if (comPosM < 0.1875) { // Command Block Center
							vec3 dif = vec3(albedo.r - albedo.b, albedo.r - albedo.g, albedo.b - albedo.g);
							dif = abs(dif);
							emissive = float(max(dif.r, max(dif.g, dif.b)) > 0.1) * 25.0;
							emissive *= float(albedo.r > 0.44 || albedo.g > 0.29);
						}
						smoothness = 0.385;
						metalness = 1.0;
					}
				} else {
					if (material == 105.0) { // Snowy Grass Block
						if (lAlbedoP > 1.0) smoothness = lAlbedoP * lAlbedoP * 0.165;
						else metalness = 0.003;
					}
					else if (material == 107.0) // Furnaces Lit
						emissive = 0.75 * float(albedo.r * albedo.r > albedo.b * 4.0 || (albedo.r > 0.9 && (albedo.r > albedo.b || albedo.r > 0.99)));
					else if (material == 108.0) // Torch, Soul Torch
						emissive = float(albedo.r > 0.9 || albedo.b > 0.65) * (1.4 - albedo.b * 1.05);
					else if (material == 109.0) { // Obsidian++
						smoothness = max(smoothness, 0.375);
						if (specB > 0.5) { // Crying Obsidian, Respawn Anchor
							emissive = (albedo.b - albedo.r) * albedo.r * 6.0;
							emissive *= emissive * emissive;
							emissive = clamp(emissive, 0.05, 1.0);
							if (lAlbedoP > 1.6 || albedo.r > albedo.b * 1.7) emissive = 1.0;
						} else {
							if (lAlbedoP > 0.75) { // Enchanting Table Diamond
								f0 = smoothness;
								smoothness = 0.9 - f0 * 0.1;
								metalness = 0.0;
							}
							if (albedo.r > albedo.g + albedo.b) { // Enchanting Table Cloth
								smoothness = max(smoothness - 0.45, 0.0);
								metalness = 0.0;
							}
						}
					}
				}
				} else {
				if (mat < 113.5) {
					if (material == 110.0) { // Campfires, Powered Lever
						if (albedo.g + albedo.b > albedo.r * 2.3 && albedo.g > 0.38 && albedo.g > albedo.b * 0.9) emissive = 0.09;
						if (albedo.r > albedo.b * 3.0 || albedo.r > 0.8) emissive = 0.65;
						emissive *= max(1.0 - albedo.b + albedo.r, 0.0);
						emissive *= lAlbedoP;
					}
					else if (material == 111.0) { // Cauldron, Hopper, Anvils
						if (color.r < 0.99) { // Cauldron
							cauldron = 1.0, smoothness = 1.0, metalness = 0.0;
							skymapMod = lmCoord.y * 0.475 + 0.515;
							#if defined REFLECTION_RAIN && defined RAIN_REF_BIOME_CHECK
								noRain = 1.0;
							#endif
							#if WATER_TYPE == 0
								albedo.rgb = waterColor.rgb;
							#elif WATER_TYPE == 1
								albedo.rgb = pow(albedo.rgb, vec3(1.3));
							#else
								albedo.rgb = vec3(0.4, 0.5, 0.4) * (pow(albedo.rgb, vec3(2.8)) + 4 * waterColor.rgb * pow(albedo.r, 1.8)
															+ 16 * waterColor.rgb * pow(albedo.g, 1.8) + 4 * waterColor.rgb * pow(albedo.b, 1.8));
								albedo.rgb = pow(albedo.rgb * 1.5, vec3(0.5, 0.6, 0.5)) * 0.6;
								albedo.rgb *= 1 + length(albedo.rgb) * pow(WATER_OPACITY, 32.0) * 2.0;
							#endif
							#ifdef NORMAL_MAPPING
								vec2 cauldronCoord1 = texCoord + fract(frametime * 0.003);
								float cauldronNoise1 = texture2D(noisetex, cauldronCoord1 * 2.0).r;
								vec2 cauldronCoord2 = texCoord - fract(frametime * 0.003);
								float cauldronNoise2 = texture2D(noisetex, cauldronCoord2 * 2.0).r;
								float waveFactor = 0.0166 + 0.05 * lightmap.y;
								normalMap.xy += (0.5 * waveFactor) * (cauldronNoise1 * cauldronNoise2 - 0.3);
								albedo.rgb *= (1.0 - waveFactor * 0.5) + waveFactor * cauldronNoise1 * cauldronNoise2;
							#endif
						}
					}
					else if (material == 112.0) { // Chorus Plant, Chorus Flower Age 5
						if (albedo.g > 0.55 && albedo.r < albedo.g * 1.1) {
							emissive = 1.0;
						}
					}
					else if (material == 113.0) { // Emissive Ores
						float stoneDif = max(abs(albedo.r - albedo.g), max(abs(albedo.r - albedo.b), abs(albedo.g - albedo.b)));
						float brightFactor = max(lAlbedoP - 1.5, 0.0);
						float ore = max(max(stoneDif - 0.175 + specG, 0.0), brightFactor);
						emissive *= sqrt4(ore) * 0.15 * ORE_EMISSION;
						metalness = 0.0;
						if (albedo.r > 0.95 && albedo.b + albedo.g < 1.1 && albedo.b + albedo.g > 0.5 && albedo.g < albedo.b + 0.1)
							// White pixels of the new Redstone Ore
							albedo.rgb *= vec3(0.8, 0.2, 0.2);
					}
				} else {
					if (material == 114.0) { // Wet Farmland
						if (lAlbedoP > 0.3) smoothness = lAlbedoP * 0.7;
						else smoothness = lAlbedoP * 2.7;
						smoothness = min(smoothness, 1.0);
					}
					else if (material == 115.0) { // Beacon
						vec3 comPos = fract(worldPos.xyz + cameraPosition.xyz);
						comPos = abs(comPos - vec3(0.5));
						float comPosM = max(max(comPos.x, comPos.y), comPos.z);
						if (comPosM < 0.4 && albedo.b > 0.5) { // Beacon Core
							albedo.rgb = vec3(0.625, 1.0, 0.975);
							emissive = 1.9;
						}
					}
					else if (material == 116.0) { // End Rod
						if (lAlbedoP > 1.3) {
							smoothness = 0.0;
							emissive = 0.45;
						}
					}
					else if (material == 117.0) { // Rails
						if (albedo.r > albedo.g * 2.0 + albedo.b) {
							if (lAlbedoP > 0.45) { // Rail Redstone Lit
								emissive = lAlbedoP;
							} else { // Rail Redstone Unlit
								smoothness = 0.4;
								metalness = 1.0;
							}
						} else {
							if (albedo.r > albedo.g + albedo.b || abs(albedo.r - albedo.b) < 0.1) { // Rail Gold, Rail Iron
								smoothness = 0.4;
								metalness = 1.0;
							}
						}
					}
				}
				}
				}

				#ifdef EMISSIVE_NETHER_ORES
					if (specR > 12.086 && specR < 12.088) {
						emissive = float(albedo.r + albedo.g > albedo.b * 2.0 && albedo.g > albedo.b * (1.2 - albedo.g * 0.5));
						emissive *= float(albedo.g < albedo.r * 1.2); // Eliminate Warped Nylium
						if (abs(albedo.g - albedo.b) < 0.1) emissive *= float(albedo.b > 0.35 || albedo.b < 0.05); // Eliminate Some Pixels On Quartz Ore
						emissive *= albedo.r * 0.05 * ORE_EMISSION;
						if (emissive > 0.01) // Desaturate Some Red-Looking Pixels
						albedo.rgb = mix(albedo.rgb, vec3(dot(albedo.rgb, vec3(0.4, 0.5, 0.07))), clamp((albedo.r - albedo.g) * 2.0, 0.0, 0.3));
					}
				#endif

				#ifdef METALLIC_WORLD
					metalness = 1.0;
					smoothness = sqrt1(smoothness);
				#endif

				f0 = 0.78 * metalness + 0.02;
				metalData = metalness;

				if (material == 106.0) { // Diamond Block, Emerald Block
					f0 = smoothness;
					smoothness = 0.9 - f0 * 0.1;
					if (albedo.g > albedo.b * 1.1) { // Emerald Block
						f0 *= f0 * 1.2;
						f0 *= f0;
						f0 = clamp(f0 * f0, 0.0, 1.0);
					}
				}
			#endif
			
			#ifdef NORMAL_MAPPING
				#if defined GENERATED_NORMALS && defined COMPBR
					float lOriginalAlbedo = length(albedoP);
					float fovScale = gbufferProjection[1][1] / 1.37;
					float scale = lViewPos / fovScale;
					float normalMult = clamp(10.0 - scale, 0.0, 8.0) * 0.25 * (1.0 - cauldron);
					float normalClamp = 0.05;
					if (normalMult > 0.0) {
						for(int i = 0; i < 2; i++) {
							vec2 offset = vec2(0.0, 0.0);
							if (i == 0) offset = vec2( 0.0,  1.0);
							if (i == 1) offset = vec2( 1.0,  0.0);
							vec2 offsetCoord = newCoord + offset * 0.0001220703125;

							if (vTexCoord.x > 1.0 - 0.0045 || vTexCoord.y > 1.0 - 0.0045) break;
							//albedo.rgb *= 0.0;

							float lNearbyAlbedo = length(texture2D(texture, offsetCoord).rgb);
							float dif = lOriginalAlbedo - lNearbyAlbedo;
							if (dif > 0.0) dif = max(dif - normalClamp, 0.0);
							else           dif = min(dif + normalClamp, 0.0);
							dif *= normalMult;
							dif = clamp(dif, -0.5, 0.5);
							if (i == 0) normalMap.y += dif;
							if (i == 1) normalMap.x += dif;
						}
					}
				#endif

				mat3 tbnMatrix = mat3(tangent.x, binormal.x, normal.x,
									  tangent.y, binormal.y, normal.y,
									  tangent.z, binormal.z, normal.z);

				if (normalMap.x > -0.999 && normalMap.y > -0.999)
					newNormal = clamp(normalize(normalMap * tbnMatrix), vec3(-1.0), vec3(1.0));
			#endif
		#endif

    	albedo.rgb = pow(albedo.rgb, vec3(2.2));

		#ifdef SNOW_MODE
			#ifdef OVERWORLD
				if (noSnow + cauldron < 0.5) {
					vec3 snowColor = vec3(0.5, 0.5, 0.65);
					float snowNoise = texture2D(noisetex, 0.125 * (vec2(worldPos.y + cameraPosition.y) + worldPos.xz + cameraPosition.xz)).r;
					snowColor *= 0.85 + 0.5 * snowNoise;
					float grassFactor = ((1.0 - abs(albedo.g - 0.3) * 4.0) - albedo.r * 2.0) * float(color.r < 0.999) * 2.0;
					float snowFactor = clamp(dot(newNormal, upVec), 0.0, 1.0);
					snowFactor *= snowFactor;
					if (grassFactor > 0.0) snowFactor = max(snowFactor * 0.75, grassFactor);
					snowFactor *= pow(lightmap.y, 16.0) * (1.0 - pow(lightmap.x + 0.1, 8.0) * 1.5);
					snowFactor = clamp(snowFactor, 0.0, 0.85);
					albedo.rgb = mix(albedo.rgb, snowColor, snowFactor);
					#ifdef ADV_MAT
						snowFactor = snowFactor * (0.75 + 0.5 * snowNoise);
						smoothness = mix(smoothness, 0.45, snowFactor);
						metalness = mix(metalness, 0.0, snowFactor);
					#endif
				}
			#endif
		#endif

		#ifdef WHITE_WORLD
			albedo.rgb = vec3(0.5);
		#endif

		float NdotL = clamp(dot(newNormal, lightVec) * 1.01 - 0.01, 0.0, 1.0);

		float fullNdotU = dot(newNormal, upVec);
		float quarterNdotUp = clamp(0.25 * fullNdotU + 0.75, 0.5, 1.0);
		float quarterNdotU = quarterNdotUp * quarterNdotUp;
			  quarterNdotU = mix(1.0, quarterNdotU, quarterNdotUfactor);

		float smoothLighting = color.a;
		#ifdef OLD_LIGHTING_FIX 
			//Probably not worth the %4 fps loss
			//Don't forget to apply the same fix to gbuffers_water if I end up making this an option
			if (smoothLighting < 0.9999999) {
				float absNdotE = abs(dot(newNormal, eastVec));
				float absNdotN = abs(dot(newNormal, northVec));
				float NdotD = abs(fullNdotU) * float(fullNdotU < 0.0);

				smoothLighting += 0.4 * absNdotE;
				smoothLighting += 0.2 * absNdotN;
				smoothLighting += 0.502 * NdotD;

				smoothLighting = clamp(smoothLighting, 0.0, 1.0);
				//albedo.rgb = mix(vec3(1, 0, 1), albedo.rgb, pow(smoothLighting, 10000.0));
			}
		#endif

		float parallaxShadow = 1.0;
		float materialAO = 1.0;
		#ifdef ADV_MAT
			rawAlbedo = albedo.rgb * 0.999 + 0.001;
			#ifdef COMPBR
				albedo.rgb *= ao;
				if (metalness > 0.801) {
					albedo.rgb *= (1.0 - metalness*0.65);
				}
			#else
				materialAO = ao;
				albedo.rgb *= (1.0 - metalness*0.65);
			#endif

			#if defined SELF_SHADOW && defined NORMAL_MAPPING
				float doParallax = 0.0;
				#ifdef OVERWORLD
					doParallax = float(lightmap.y > 0.0 && NdotL > 0.0);
				#endif
				#ifdef END
					doParallax = float(NdotL > 0.0);
				#endif
				if (doParallax > 0.5) {
					parallaxShadow = GetParallaxShadow(parallaxFade, newCoord, lightVec, tbnMatrix);
				}
			#endif

			#ifdef DIRECTIONAL_LIGHTMAP
				mat3 lightmapTBN = GetLightmapTBN(viewPos);
				lightmap.x = DirectionalLightmap(lightmap.x, lmCoord.x, newNormal, lightmapTBN);
				lightmap.y = DirectionalLightmap(lightmap.y, lmCoord.y, newNormal, lightmapTBN);
			#endif
		#endif
		
		float shadow = 0.0;
		GetLighting(albedo.rgb, shadow, lightAlbedo, viewPos, lViewPos, worldPos, lightmap, smoothLighting, NdotL, quarterNdotU,
					parallaxShadow, emissive, subsurface, leaves, materialAO);

		#ifdef ADV_MAT
			#if defined OVERWORLD || defined END
				#ifdef OVERWORLD
					#ifdef REFLECTION_RAIN
						if (quarterNdotUp > 0.85) {
							#ifdef RAIN_REF_BIOME_CHECK
							if (noRain < 0.1) {
							#endif
								vec2 rainPos = worldPos.xz + cameraPosition.xz;

								skymapMod = lmCoord.y * 16.0 - 15.5;
								float lmCX = pow(lmCoord.x * 1.3, 50.0);
								skymapMod = max(skymapMod - lmCX, 0.0);

								float puddleSize = 0.0025;
								skymapMod *= GetPuddles(rainPos * puddleSize);

								float skymapModx2 = skymapMod * 2.0;
								smoothness = mix(smoothness, 0.8 , skymapModx2);
								metalness  = mix(metalness , 0.0 , skymapModx2);
								metalData  = mix(metalData , 0.0 , skymapModx2);
								f0         = mix(f0        , 0.02, skymapModx2);

								mat3 tbnMatrix = mat3(tangent.x, binormal.x, normal.x,
													  tangent.y, binormal.y, normal.y,
													  tangent.z, binormal.z, normal.z);
								rainPos *= 0.02;
								vec2 wind = vec2(frametime) * 0.01;
								vec3 pnormalMap = vec3(0.0, 0.0, 1.0);
								float pnormalMultiplier = 0.05;

								vec2 pnormalCoord1 = rainPos + vec2(wind.x, wind.y);
								vec3 pnormalNoise1 = texture2D(noisetex, pnormalCoord1).rgb;
								vec2 pnormalCoord2 = rainPos + vec2(wind.x * -1.5, wind.y * -1.0);
								vec3 pnormalNoise2 = texture2D(noisetex, pnormalCoord2).rgb;

								pnormalMap += (pnormalNoise1 - vec3(0.5)) * pnormalMultiplier;
								pnormalMap += (pnormalNoise2 - vec3(0.5)) * pnormalMultiplier;
								vec3 puddleNormal = clamp(normalize(pnormalMap * tbnMatrix),vec3(-1.0),vec3(1.0));

								albedo.rgb *= 1.0 - sqrt(length(pnormalMap.xy)) * 0.8 * skymapModx2 * (rainStrengthS);
								//albedo.rgb *= 0.0;

								vec3 rainNormal = normalize(mix(newNormal, puddleNormal, rainStrengthS));

								newNormal = mix(newNormal, rainNormal, skymapModx2);
							#ifdef RAIN_REF_BIOME_CHECK
							}
							#endif
						}
					#endif

					vec3 lightME = mix(lightMorning, lightEvening, mefade);
					vec3 lightDayTint = lightDay * lightME * LIGHT_DI;
					vec3 lightDaySpec = mix(lightME, sqrt(lightDayTint), timeBrightness);
					vec3 specularColor = mix(sqrt(lightNight*0.3),
												lightDaySpec,
												sunVisibility);
					#ifdef WATER_CAUSTICS
						if (isEyeInWater == 1) specularColor *= underwaterColor.rgb * 8.0;
					#endif
					specularColor *= specularColor;

					#ifdef SPECULAR_SKY_REF
						float skymapModM = lmCoord.y;
						#if SKY_REF_FIX_1 == 1
							skymapModM = skymapModM * skymapModM;
						#elif SKY_REF_FIX_1 == 2
							skymapModM = max(skymapModM - 0.80, 0.0) * 5.0;
						#else
							skymapModM = max(skymapModM - 0.99, 0.0) * 100.0;
						#endif
						if (!(metalness <= 0.004 && metalness > 0.0)) skymapMod = max(skymapMod, skymapModM * 0.1);
					#endif
				#endif
				#ifdef END
					vec3 specularColor = endCol;
					#ifdef COMPBR
						if (cauldron > 0.0) skymapMod = (min(length(shadow), 0.475) + 0.515) * float(smoothness > 0.9);
						else
					#endif
					skymapMod = min(length(shadow), 0.5);
				#endif
				
				vec3 specularHighlight = vec3(0.0);
				specularHighlight = GetSpecularHighlight(smoothness - cauldron, metalness, f0, specularColor, rawAlbedo,
												shadow, newNormal, viewPos);
				#if defined LIGHT_LEAK_FIX && !defined END
					if (isEyeInWater == 0) specularHighlight *= pow(lightmap.y, 2.5);
					else specularHighlight *= 0.15 + 0.85 * pow(lightmap.y, 2.5);
				#endif
				albedo.rgb += specularHighlight;
			#endif
		#endif
		
		#ifdef SHOW_LIGHT_LEVELS
			if (lmCoord.x < 0.533334 && quarterNdotU > 0.99 && foliage + leaves < 0.1) {
				float showLightLevelFactor = fract(frameTimeCounter);
				if (showLightLevelFactor > 0.5) showLightLevelFactor = 1 - showLightLevelFactor;
				albedo.rgb += vec3(0.5, 0.0, 0.0) * showLightLevelFactor;
			}
		#endif
	} else discard;

	#ifdef GBUFFER_CODING
		albedo.rgb = vec3(1.0, 1.0, 170.0) / 255.0;
		albedo.rgb = pow(albedo.rgb, vec3(2.2)) * 0.5;
	#endif

	#if THE_FORBIDDEN_OPTION > 1
		albedo = min(albedo, vec4(1.0));
	#endif

	#ifdef GREEN_SCREEN
		if (greenScreen > 0.5) {
			albedo.rgb = vec3(0.0, 0.1, 0.0);
			#if defined ADV_MAT && defined REFLECTION_SPECULAR
				smoothness = 0.0;
				metalData = 0.0;
				skymapMod = 0.51;
			#endif
		}
	#endif

    /* DRAWBUFFERS:0 */
    gl_FragData[0] = albedo;

	#if defined ADV_MAT && defined REFLECTION_SPECULAR
		/* DRAWBUFFERS:0361 */
		gl_FragData[1] = vec4(smoothness, metalData, skymapMod, 1.0);
		gl_FragData[2] = vec4(EncodeNormal(newNormal), 0.0, 1.0);
		gl_FragData[3] = vec4(rawAlbedo, 1.0);

		#ifdef COLORED_LIGHT
			/* DRAWBUFFERS:03618 */
			gl_FragData[4] = vec4(lightAlbedo, 1.0);
		#endif
	#else
		#ifdef COLORED_LIGHT
			/* DRAWBUFFERS:08 */
			gl_FragData[1] = vec4(lightAlbedo, 1.0);
		#endif
	#endif
}

#endif

//////////Vertex Shader//////////Vertex Shader//////////Vertex Shader//////////
#ifdef VSH

//Uniforms//
uniform int worldTime;

uniform float frameTimeCounter;
uniform float timeAngle;

uniform vec3 cameraPosition;

uniform mat4 gbufferModelView, gbufferModelViewInverse;

#if AA > 1
uniform int frameCounter;

uniform float viewWidth, viewHeight;
#endif

#if defined FOG1 && defined FOG1_CHECK
uniform float far;
#endif

//Attributes//
attribute vec4 mc_Entity;
attribute vec4 mc_midTexCoord;

#ifdef ADV_MAT
attribute vec4 at_tangent;
#endif

//Common Variables//
#if WORLD_TIME_ANIMATION >= 2
float frametime = float(worldTime) * 0.05 * ANIMATION_SPEED;
#else
float frametime = frameTimeCounter * ANIMATION_SPEED;
#endif

#ifdef OVERWORLD
	float timeAngleM = timeAngle;
#else
	#if !defined SEVEN && !defined SEVEN_2
		float timeAngleM = 0.25;
	#else
		float timeAngleM = 0.5;
	#endif
#endif

//Includes//
float wavingTime = frametime * WAVING_SPEED;

const float PI = 3.1415927;
float pi2wt = 6.2831854 * (wavingTime * 24.0);

vec3 calcWave(vec3 pos, float fm, float mm, float ma, float f0, float f1, float f2, float f3, float f4, float f5) {
    vec3 ret;
    float magnitude, d0, d1, d2, d3;
    magnitude = sin(pi2wt * fm + pos.x*0.5 + pos.z*0.5 + pos.y*0.5) * mm + ma;
    d0 = sin(pi2wt * f0);
    d1 = sin(pi2wt * f1);
    d2 = sin(pi2wt * f2);
    ret.x = sin(pi2wt*f3 + d0 + d1 - pos.x + pos.z + pos.y) * magnitude;
    ret.z = sin(pi2wt*f4 + d1 + d2 + pos.x - pos.z + pos.y) * magnitude;
    ret.y = sin(pi2wt*f5 + d2 + d0 + pos.z + pos.y - pos.y) * magnitude;
    return ret;
}

vec3 calcMove(in vec3 pos, float f0, float f1, float f2, float f3, float f4, float f5, vec3 amp1, vec3 amp2) {
    vec3 move1 = calcWave(pos      , 0.0027, 0.0400, 0.0400, 0.0127, 0.0089, 0.0114, 0.0063, 0.0224, 0.0015) * amp1;
    vec3 move2 = calcWave(pos+move1, 0.0348, 0.0400, 0.0400, f0, f1, f2, f3, f4, f5) * amp2;
    vec3 returner = move1 + move2;
    #ifndef DO_WAVING_UNDERGROUND
        returner *= float(lmCoord.y > 0.9);
    #endif
    return returner;
}

float calcLilypadMove(vec3 worldpos) {
    float wave = sin(2 * PI * (wavingTime*0.7 + worldpos.x * 0.14 + worldpos.z * 0.07))
                + sin(2 * PI * (wavingTime*0.5 + worldpos.x * 0.10 + worldpos.z * 0.20));
    #ifndef DO_WAVING_UNDERGROUND
        wave *= lmCoord.y;
    #endif
    return wave * 0.0125;
}

vec3 WavingBlocks(vec3 position, float istopv) {
    vec3 wave = vec3(0.0);
    vec3 worldpos = position + cameraPosition;

    #ifdef WAVING_CROPS
    if (mc_Entity.x == 59 && (istopv > 0.9 || fract(worldpos.y + 0.0675) > 0.01)) { // Crops
        if (length(position) < 2.0) wave.xz += position.xz*max(5.0/pow(max(length(position*vec3(8.0,2.0,8.0)-vec3(0.0,2.0,0.0)),2.0),1.0)-0.625,0.0);
        wave += calcMove(worldpos, 0.0041, 0.0070, 0.0044, 0.0038, 0.0240, 0.0000, vec3(0.4,0.0,0.4), vec3(0.2,0.0,0.2));
    }
    if (mc_Entity.x == 104 && (istopv > 0.9 || fract(worldpos.y + 0.0675) > 0.01)) { // Stems
        wave += calcMove(worldpos, 0.0041, 0.0070, 0.0044, 0.0038, 0.0240, 0.0000, vec3(0.1,0.4,0.1), vec3(0.05,0.2,0.05));
	}
    #endif
    #ifdef WAVING_FOLIAGE
    if (mc_Entity.x == 31 && istopv > 0.9) { // Foliage
        if (length(position) < 2.0) wave.xz += position.xz*max(5.0/pow(max(length(position*vec3(8.0,2.0,8.0)-vec3(0.0,2.0,0.0)),2.0),1.0)-0.625,0.0);
        wave += calcMove(worldpos, 0.0041, 0.0070, 0.0044, 0.0038, 0.0063, 0.0000, vec3(0.8,0.0,0.8), vec3(0.4,0.0,0.4));
    }
    if (mc_Entity.x == 175 || (mc_Entity.x == 176.0 && (istopv > 0.9 || fract(worldpos.y+0.005)>0.01))) { // Double Plants
        wave += calcMove(worldpos, 0.0041, 0.005, 0.0044, 0.0038, 0.0240, 0.0000, vec3(0.8,0.1,0.8), vec3(0.4,0.0,0.4));
	}
    if (mc_Entity.x == 6 && (istopv > 0.9 || fract(worldpos.y + 0.005) > 0.01)) { // Plants
        wave += calcMove(worldpos, 0.0041, 0.005, 0.0044, 0.0038, 0.0240, 0.0000, vec3(0.6,0.0,0.6), vec3(0.3,0.0,0.3));
	}
    #endif
    #ifdef WAVING_LEAVES
    if (mc_Entity.x == 18) // Leaves
        wave += calcMove(worldpos, 0.0040, 0.0064, 0.0043, 0.0035, 0.0037, 0.0041, vec3(0.5,0.5,0.5), vec3(0.25,0.25,0.25));
    #endif
    #ifdef WAVING_VINES
    if (mc_Entity.x == 9600) // Vines
        wave += calcMove(worldpos, 0.0040, 0.0064, 0.0043, 0.0035, 0.0037, 0.0041, vec3(0.25,0.5,0.25), vec3(0.125,0.25,0.125));
    #endif
    #ifdef WAVING_LILY_PADS
    if (mc_Entity.x == 9100) // Lily Pads
        wave.y += calcLilypadMove(worldpos);
    #endif

    #ifdef WAVING_EVERYTHING
        wave += calcWave(worldpos, 0.0027, 0.0400, 0.0400, 0.0127, 0.0089, 0.0114, 0.0063, 0.0224, 0.0015);
    #endif

    return wave;
}

float WavingWater(vec3 worldPos) {
	float fractY = fract(worldPos.y + cameraPosition.y + 0.005);
	worldPos += cameraPosition.xyz;

    float waterWaveTime = frametime * WATER_SPEED * 0.8;
	
	float wave = sin(6.28 * (waterWaveTime * 0.7 + worldPos.x * 0.14 + worldPos.z * 0.07)) +
				sin(6.28 * (waterWaveTime * 0.5 + worldPos.x * 0.10 + worldPos.z * 0.20));
	if (fractY > 0.01) return wave * 0.0125;
	else return 0.0;
}

#if AA == 2 || AA == 3
//Jitter offset from Chocapic13
uniform float framemod8;

vec2 jitterOffsets[8] = vec2[8]( // LiteTAA Jitter
							vec2( 0.125,-0.375),
							vec2(-0.125, 0.375),
							vec2( 0.625, 0.125),
							vec2( 0.375,-0.625),
							vec2(-0.625, 0.625),
							vec2(-0.875,-0.125),
							vec2( 0.375,-0.875),
							vec2( 0.875, 0.875)
						);
							   
vec2 TAAJitter(vec2 coord, float w) {
	vec2 offset = jitterOffsets[int(framemod8)] *0.125* (w / vec2(viewWidth, viewHeight));
	return coord + offset;
}
#endif
#if AA == 4
//Jitter offset from Chocapic13
uniform float framemod8;

vec2 jitterOffsets[8] = vec2[8](
							vec2( 0.125,-0.375),
							vec2(-0.125, 0.375),
							vec2( 0.625, 0.125),
							vec2( 0.375,-0.625),
							vec2(-0.625, 0.625),
							vec2(-0.875,-0.125),
							vec2( 0.375,-0.875),
							vec2( 0.875, 0.875)
						);
							   
vec2 TAAJitter(vec2 coord, float w) {
	vec2 offset = jitterOffsets[int(framemod8)] * (w / vec2(viewWidth, viewHeight));
	return coord + offset;
}
#endif

#ifdef WORLD_CURVATURE
float WorldCurvature(vec2 pos) {
    #if defined END
        float curvature = dot(pos, pos) / END_CURVATURE_SIZE;
        #if END_CURVATURE_SIZE == 999999
            curvature *= 0.0;
        #endif
    #elif defined NETHER
        float curvature = dot(pos, pos) / NETHER_CURVATURE_SIZE;
        #if NETHER_CURVATURE_SIZE == 999999
            curvature *= 0.0;
        #endif
    #else
        float curvature = dot(pos, pos) / OVERWORLD_CURVATURE_SIZE;
        #if OVERWORLD_CURVATURE_SIZE == 999999
            curvature *= 0.0;
        #endif
    #endif

    return curvature;
}
#endif

//Program//
void irisMain() {
	vec4 position = gbufferModelViewInverse * gl_ModelViewMatrix * gl_Vertex;
	
	#if defined FOG1 && defined FOG1_CHECK
		float lWorldPos = length(position.xz) * 1;
		float fog = lWorldPos / far * 1.5 * (10/FOG1_DISTANCE);
		fog = 1.0 - exp(-0.1 * pow(fog, 10.0));
		if (fog > 0.9) {
			gl_Position = vec4(0.0, 0.0, 1000.0, 0.0);
			return;
		}
	#endif
	
	#if THE_FORBIDDEN_OPTION > 1
		if (length(position.xz) > 0.0) {
			gl_Position = gl_ProjectionMatrix * gbufferModelView * position;
			return;
		}
	#endif

	texCoord = (iris_TextureMat * gl_MultiTexCoord0).xy;
    
	lmCoord = (iris_LightmapTextureMatrix * gl_MultiTexCoord1).xy;
	lmCoord = clamp((lmCoord - 0.03125) * 1.06667, 0.0, 1.0);

	normal = normalize(gl_NormalMatrix * gl_Normal);

	#ifdef ADV_MAT
		#if defined NORMAL_MAPPING || defined REFLECTION_RAIN
			binormal = normalize(gl_NormalMatrix * cross(at_tangent.xyz, gl_Normal.xyz) * at_tangent.w);
			tangent  = normalize(gl_NormalMatrix * at_tangent.xyz);
			
			#if defined PARALLAX || defined SELF_SHADOW
				mat3 tbnMatrix = mat3(tangent.x, binormal.x, normal.x,
									  tangent.y, binormal.y, normal.y,
									  tangent.z, binormal.z, normal.z);
			
				viewVector = tbnMatrix * (gl_ModelViewMatrix * gl_Vertex).xyz;
				dist = length(gl_ModelViewMatrix * gl_Vertex);
			#endif
		#endif

		vec2 midCoord = (iris_TextureMat * mc_midTexCoord).st;
		vec2 texMinMidCoord = texCoord - midCoord;

		#ifdef COMPBR
			float texCoordDist = length(texMinMidCoord);
		#endif
		#if !defined COMPBR || defined NORMAL_MAPPING
			vTexCoordAM.pq  = abs(texMinMidCoord) * 2;
			vTexCoordAM.st  = min(texCoord, midCoord - texMinMidCoord);
			
			vTexCoord.xy    = sign(texMinMidCoord) * 0.5 + 0.5;
		#endif
	#endif
    
	color = gl_Color;

	#ifdef SNOW_MODE
		noSnow = 0.0;
	#endif
	#ifdef COLORED_LIGHT
		lightVarying = 0.0;
	#endif
	
	mat = 0.0; quarterNdotUfactor = 1.0; mipmapDisabling = 0.0; specR = 0.0; specG = 0.0; specB = 0.0;

	if (mc_Entity.x ==  31 || mc_Entity.x ==   6 || mc_Entity.x ==  59 || 
		mc_Entity.x == 175 || mc_Entity.x == 176 || mc_Entity.x ==  83 || 
		mc_Entity.x == 104 || mc_Entity.x == 105 || mc_Entity.x == 11019) // Foliage
		mat = 1.0, lmCoord.x = clamp(lmCoord.x, 0.0, 0.87), quarterNdotUfactor = 0.0;
		
	if (mc_Entity.x == 18 || mc_Entity.x == 9600 || mc_Entity.x == 9100 || mc_Entity.x == 10231) // Leaves, Vine, Lily Pad, Cave Vines
		#ifdef COMPBR
			specR = 12.07, specG = 0.003,
		#endif
		mat = 2.0;

	if (mc_Entity.x == 10) // Lava
		#ifdef COLORED_LIGHT
			lightVarying = 3.0,
		#endif
		mat = 4.0,
		specB = 0.25, quarterNdotUfactor = 0.0, color.a = 1.0, lmCoord.x = 0.9,
		color.rgb = normalize(color.rgb) * vec3(LAVA_INTENSITY * 1.45);
	if (mc_Entity.x == 1010) // Fire
		#ifdef COLORED_LIGHT
			lightVarying = 3.0,
		#endif
		specB = 0.25, lmCoord.x = 0.98, color.a = 1.0, color.rgb = vec3(FIRE_INTENSITY * 0.67);
	if (mc_Entity.x == 210) // Soul Fire
		#ifdef COLORED_LIGHT
			lightVarying = 2.0,
		#endif
		#ifdef SNOW_MODE
			noSnow = 1.0,
		#endif
		specB = 0.25, lmCoord.x = 0.0, color.a = 1.0, color.rgb = vec3(FIRE_INTENSITY * 0.53);

	if (mc_Entity.x == 12345) // Custom Emissive
		lmCoord = vec2(0.0), specB = 2.05;

	#ifdef COMPBR
	if (mc_Entity.x < 10218.5) {
    if (mc_Entity.x < 10115.5) {
    if (mc_Entity.x < 10052.5) {
    if (mc_Entity.x < 10008.5) {
	if (mc_Entity.x < 10002.5) {
        if (mc_Entity.x == 10000) { // Grass Block
			if (color.b < 0.99) { // Grass Block Grass
				specR = 8.034, specG = 0.003;
			} else { // Grass Block Dirt
				specR = 2.035, specG = 0.003;
			}
		}
		else if (mc_Entity.x == 10001) // Snowy Grass Block
			mat = 105.0,
			specR = 2.035;
		else if (mc_Entity.x == 10002) // Sand
			specR = 80.004, mat = 3.0;
	} else {
		if (mc_Entity.x == 10003) // Stone+, Deepslate+
			specR = 20.04;
		else if (mc_Entity.x == 10007) // Dirt, Coarse Dirt, Podzol, Grass Path, Dirt Path, Farmland Dry
			specR = 2.035, specG = 0.003;
		else if (mc_Entity.x == 10008) // Glass, Glass Pane
			specR = 0.8, lmCoord.x = clamp(lmCoord.x, 0.0, 0.87), mipmapDisabling = 1.0;
	}
    } else {
	if (mc_Entity.x < 10012.5) {
		if (mc_Entity.x == 10009) // Snow, Snow Block
			specR = 18.037, mat = 3.0;
		else if (mc_Entity.x == 10010) // Gravel
			specR = 32.06;
		else if (mc_Entity.x == 10012) // Cobblestone+, Clay
			specR = 18.037;
	} else {
		if (mc_Entity.x == 10050) // Red Sand
			specR = 80.115, mat = 3.0;
		else if (mc_Entity.x == 10051) // Andesite, Diorite, Granite, Basalt+, Calcite, Tuff, Dripstone+
			specR = 12.05;
		else if (mc_Entity.x == 10052) // Terracottas
			specR = 2.045, mat = 15000.0, color.rgb = vec3(0.03, 1.0, 0.0);
    }
	}
    } else {
    if (mc_Entity.x < 10106.5) {
	if (mc_Entity.x < 10102.5) {
		if (mc_Entity.x == 10053) // Packed Ice, Blue Ice, Purpur Block+
			specR = 20.055;

		else if (mc_Entity.x == 10101) // Birch Log+
			specR = 3.055;
		else if (mc_Entity.x == 10102) // Oak Log+, Bone Block
			specR = 8.055;
	} else {
		if (mc_Entity.x == 10103) // Jungle Log+, Acacia Log+
			specR = 6.055;
		else if (mc_Entity.x == 10105) // Spruce Log+, Scaffolding, Cartography Table, Bee Nest, Beehive
			specR = 6.06;
		else if (mc_Entity.x == 10106) // Warped Log+
			specR = 10.07, mat = 102.0,
			mipmapDisabling = 1.0;
	}
    } else {
	if (mc_Entity.x < 10111.5) {
		if (mc_Entity.x == 10107) // Crimson Log+
			specR = 10.07, mat = 103.0,
			mipmapDisabling = 1.0;
		else if (mc_Entity.x == 10108) // Dark Oak Log+
			specR = 2.04;		
		else if (mc_Entity.x == 10111) // Birch Planks+, Fletching Table, Loom
			specR = 20.036;
	} else {
		if (mc_Entity.x == 10112) // Oak Planks+, Jungle Planks+, Bookshelf, Composter
			specR = 20.055;
		else if (mc_Entity.x == 10114) // Acacia Planks+, Barrel, Honeycomb Block
			specR = 20.075;
		else if (mc_Entity.x == 10115) // Spruce Planks+, Smithing Table
			specR = 20.12;
    }
	}
    }
    } else {
    if (mc_Entity.x < 10207.5) {
	if (mc_Entity.x < 10201.5) {
	if (mc_Entity.x < 10118.5) {
		if (mc_Entity.x == 10116) // Warped Planks+
			specR = 12.075;
		else if (mc_Entity.x == 10117) // Crimson Planks+, Note Block, Jukebox
			specR = 12.095;
		else if (mc_Entity.x == 10118) // Dark Oak Planks+
			specR = 20.4;
	} else {
		if (mc_Entity.x == 10199) // Stone Bricks++
			specR = 20.09;
		else if (mc_Entity.x == 10200) // Netherrack, Crimson/Warped Nylium, Nether Ores, Blackstone++
			specR = 12.087, mat = 20000.0, color.rgb = vec3(1.0, 0.7, 1.0);
		else if (mc_Entity.x == 10201) // Polished Andesite, Polished Diorite, Polished Granite, Melon
			specR = 6.085;
	}
	} else {
	if (mc_Entity.x < 10205.5) {
		if (mc_Entity.x == 10202) // Nether Bricks+
			specR = 12.375, mat = 20000.0, color.rgb = vec3(0.55, 1.0, 1.0);
		else if (mc_Entity.x == 10203 || mc_Entity.x == 10204) // Iron Block+
			specR = 6.07, specG = 131.0;
		else if (mc_Entity.x == 10205) // Gold Block+
			specR = 8.1, mat = 30000.0, color.rgb = vec3(1.0, 1.0, 1.0), specG = 1.0;
	} else {
		if (mc_Entity.x == 10206) // Diamond Block
			specR = 100.007, mat = 106.0;
		else if (mc_Entity.x == 10207) // Emerald Block
			specR = 7.2, mat = 106.0;
	}
	}
    } else {
	if (mc_Entity.x < 10212.5) {
	if (mc_Entity.x < 10209.5) {
		if (mc_Entity.x == 10208) // Netherite Block
			specR = 12.135, specG = 0.7;
		else if (mc_Entity.x == 10209) // Ancient Debris
			#ifdef GLOWING_DEBRIS
				specB = 6.0 + min(0.3 * ORE_EMISSION, 0.9), color.a = 1.0,
			#endif
			specR = 8.07, specG = 0.7;
	} else {
		if (mc_Entity.x == 10210) // Block of Redstone
			#ifdef GLOWING_REDSTONE_BLOCK
				specB = 7.99, mat = 20000.0, color.rgb = vec3(1.1), color.a = 1.0,
			#endif
			specR = 8.05, specG = 1.0;
		else if (mc_Entity.x == 10211) // Lapis Lazuli Block
			#ifdef GLOWING_LAPIS_BLOCK
				specB = 6.99, mat = 20000.0, color.rgb = vec3(1.13), color.a = 1.0,
			#endif
			specR = 16.11;
		else if (mc_Entity.x == 10212) // Carpets, Wools
			specR = 2.02, mat = 15000.0, color.rgb = vec3(0.03, 1.0, 0.0), specG = 0.003, lmCoord.x *= 0.96;
	}
	} else {
	if (mc_Entity.x < 10215.5) {
		if (mc_Entity.x == 10213) // Obsidian
			specR = 2.15, specG = 0.6, mat = 109.0;
		else if (mc_Entity.x == 10214) // Enchanting Table
			specR = 2.15, specG = 0.6, mat = 109.0;
		else if (mc_Entity.x == 10215) // Chain
			specR = 0.5, specG = 1.0,
			lmCoord.x = clamp(lmCoord.x, 0.0, 0.87);
	} else {
		if (mc_Entity.x == 10216) // Cauldron, Hopper, Anvils
			specR = 1.08, specG = 1.0, mat = 111.0,
			lmCoord.x = clamp(lmCoord.x, 0.0, 0.87);
		else if (mc_Entity.x == 10217) // Sandstone+
			specR = 24.029;
		else if (mc_Entity.x == 10218) // Red Sandstone+
			specR = 24.085;
	}
	}
    }
    }
    } else {
	if (mc_Entity.x < 11009.5) {
	if (mc_Entity.x < 10231.5) {
	if (mc_Entity.x < 10225.5) {
	if (mc_Entity.x < 10221.5) {
		if (mc_Entity.x == 10219) // Quartz+, Daylight Detector, Dried Kelp Block
			specR = 16.082;
		else if (mc_Entity.x == 10220) // Chorus Plant, Chorus Flower Age 5
			mat = 112.0, specR = 6.1,
			mipmapDisabling = 1.0, lmCoord.x = clamp(lmCoord.x, 0.0, 0.87);
		else if (mc_Entity.x == 10221) // Chorus Flower Age<=4
			specB = 5.0001, specR = 5.07,
			mipmapDisabling = 1.0, lmCoord.x = clamp(lmCoord.x, 0.0, 0.87);
	} else {
		if (mc_Entity.x == 10222) // End Stone++, Smooth Stone+, Lodestone, TNT, Pumpkin+, Mushroom Blocks, Polished Deepslate+
			specR = 12.065;
		else if (mc_Entity.x == 10224) // Concretes
			specR = 3.044, mat = 15000.0, color.rgb = vec3(0.03, 1.0, 0.0);
		else if (mc_Entity.x == 10225) // Concrete Powders
			specR = 6.014, mat = 15000.0, color.rgb = vec3(0.01, 1.0, 0.0);
	}
	} else {
	if (mc_Entity.x < 10228.5) {
		if (mc_Entity.x == 10226) // Bedrock
			specR = 16.0675;
		else if (mc_Entity.x == 10227) // Hay Block, Target
			specR = 16.085, specG = 0.003, mat = 20000.0, color.rgb = vec3(1.0, 0.0, 0.0);
		else if (mc_Entity.x == 10228) // Bricks+, Furnaces Unlit, Dispenser, Dropper
			specR = 10.07;
	} else {
		if (mc_Entity.x == 10229) // Farmland Wet
			mat = 114.0;
		else if (mc_Entity.x == 10230) // Crafting Table
			specR = 24.06;
		else if (mc_Entity.x == 10231) // Cave Vines (Hanging Glow Berries)
			specB = 8.3, mat = 20000.0, color.rgb = vec3(1.2, -5.0, 0.0),
			mipmapDisabling = 1.0, lmCoord.x = clamp(lmCoord.x, 0.0, 0.87);
	}
	}
	} else {
	if (mc_Entity.x < 11003.5) {
	if (mc_Entity.x < 10234.5) {
		if (mc_Entity.x == 10232) // Prismarine+
			specR = 3.08, specG = 0.75;
		else if (mc_Entity.x == 10233) // Dark Prismarine+
			specR = 3.11, specG = 0.75;
		else if (mc_Entity.x == 10234) // Glazed Terracottas
			specR = 0.5;
	} else {
		if (mc_Entity.x == 11001) // Glowstone
			#ifdef COLORED_LIGHT
				lightVarying = 3.0,
			#endif
			lmCoord.x = 0.87, specB = 3.075, color.rgb = vec3(0.69, 0.68, 0.65),
			mipmapDisabling = 1.0;
		else if (mc_Entity.x == 11002) // Sea Lantern
			#ifdef COLORED_LIGHT
				lightVarying = 4.0,
			#endif
			lmCoord.x = 0.93, specB = 9.0055, color.rgb = vec3(0.62, 0.60, 0.657),
			quarterNdotUfactor = 0.0, mipmapDisabling = 1.0;
		else if (mc_Entity.x == 11003) // Magma Block
			lmCoord.x = 0.0, specB = 2.05, color.rgb = vec3(0.85, 0.84, 0.7),
			quarterNdotUfactor = 0.0, mipmapDisabling = 1.0;
	}
	} else {
	if (mc_Entity.x < 11006.5) {
		if (mc_Entity.x == 11004) // Shroomlight
			#ifdef COLORED_LIGHT
				lightVarying = 1.0,
			#endif
			lmCoord.x = 0.93, specB = 16.005, color.rgb = vec3(0.45),
			quarterNdotUfactor = 0.0;
		else if (mc_Entity.x == 11005) // Redstone Lamp Lit
			#ifdef COLORED_LIGHT
				lightVarying = 3.0,
			#endif
			lmCoord.x = 0.915, specB = 5.099, color.rgb = vec3(0.6), quarterNdotUfactor = 0.0,
			specG = 0.63, specR = 0.55, mipmapDisabling = 1.0;
		else if (mc_Entity.x == 11006) // Redstone Lamp Unlit
			specG = 0.63, specR = 3.15,	mipmapDisabling = 1.0;
	} else {
		if (mc_Entity.x == 11007) // Jack o'Lantern
			#ifdef COLORED_LIGHT
				lightVarying = 3.0,
			#endif
			specR = 12.065, lmCoord.x = 0.87, specB = 16.0001, color.rgb = vec3(1.0, 1.0, 1.15), mipmapDisabling = 1.0;
		else if (mc_Entity.x == 11008) // Beacon
			#ifdef COLORED_LIGHT
				lightVarying = 4.0,
			#endif
			mat = 115.0, lmCoord.x = 0.87;
		else if (mc_Entity.x == 11009) // End Rod
			#ifdef COLORED_LIGHT
				lightVarying = 4.0,
			#endif
			specR = 1.0, lmCoord.x = 0.88, mat = 116.0;
	}
	}
	}
	} else {
	if (mc_Entity.x < 11021.5) {
	if (mc_Entity.x < 11015.5) {
	if (mc_Entity.x < 11012.5) {
		if (mc_Entity.x == 11010) // Dragon Egg
			#ifdef SNOW_MODE
				noSnow = 1.0,
			#endif
			specB = 4.1, mat = 20000.0, color.rgb = vec3(10.0);
		else if (mc_Entity.x == 11011) // Redstone Wire
			#ifdef SNOW_MODE
				noSnow = 1.0,
			#endif
			specB = smoothstep(0.0, 1.0, pow2(length(color.rgb))) * 0.07;
		else if (mc_Entity.x == 11012) // Redstone Torch
			#ifdef COLORED_LIGHT
				lightVarying = 2.0,
			#endif
			#ifdef SNOW_MODE
				noSnow = 1.0,
			#endif
			mat = 101.0, lmCoord.x = min(lmCoord.x, 0.86), mipmapDisabling = 1.0;
	} else {
		if (mc_Entity.x == 11013) // Redstone Repeater & Comparator Powered
			#ifdef SNOW_MODE
				noSnow = 1.0,
			#endif
			mat = 101.0, mipmapDisabling = 1.0;
		else if (mc_Entity.x == 11014) // Redstone Repeater & Comparator Unpowered
			#ifdef SNOW_MODE
				noSnow = 1.0,
			#endif
			mat = 101.0, mipmapDisabling = 1.0;
		else if (mc_Entity.x == 11015) // Observer
			#ifdef SNOW_MODE
				noSnow = 1.0,
			#endif
			specR = 10.07, mat = 101.0, specB = 1000.0;
	}
	} else {
	if (mc_Entity.x < 11018.5) {
		if (mc_Entity.x == 11016) // Command Blocks
			#ifdef SNOW_MODE
				noSnow = 1.0,
			#endif
			mat = 104.0, mipmapDisabling = 1.0;
		else if (mc_Entity.x == 11017) // Lantern
			#ifdef COLORED_LIGHT
				lightVarying = 3.0,
			#endif
			lmCoord.x = 0.87, specB = 3.4, mat = 20000.0, color.rgb = vec3(1.0, 0.0, 0.0),
			specR = 0.5, specG = 1.0;
		else if (mc_Entity.x == 11018) // Soul Lantern
			#ifdef COLORED_LIGHT
				lightVarying = 2.0,
			#endif
			lmCoord.x = min(lmCoord.x, 0.87), specB = 4.15, mat = 20000.0, color.rgb = vec3(0.0, 1.0, 0.0),
			specR = 0.5, specG = 1.0;
	} else {
		if (mc_Entity.x == 11019) // Crimson Fungus, Warped Fungus
			specB = 16.007, mat = 20000.0, color.rgb = vec3(1.0, 0.0, 0.0);
		else if (mc_Entity.x == 11020) // Furnaces Lit
			#ifdef COLORED_LIGHT
				lightVarying = 3.0,
			#endif
			specR = 10.07, mat = 107.0, lmCoord.x = pow(lmCoord.x, 1.5);
		if (mc_Entity.x == 11021) // Torch
			#ifdef COLORED_LIGHT
				lightVarying = 1.0,
			#endif
			lmCoord.x = min(lmCoord.x, 0.86), mat = 108.0, mipmapDisabling = 1.0;
	}
	}
	} else {
	if (mc_Entity.x < 11028.5) {
	if (mc_Entity.x < 11025.5) {
		if (mc_Entity.x == 11022) // Soul Torch
			#ifdef COLORED_LIGHT
				lightVarying = 2.0,
			#endif
			lmCoord.x = min(lmCoord.x, 0.86), mat = 108.0, mipmapDisabling = 1.0;
		else if (mc_Entity.x == 11023) // Crying Obsidian, Respawn Anchor
			#ifdef COLORED_LIGHT
				lightVarying = 2.0,
			#endif
			specR = 2.15, specG = 0.6, mat = 109.0,
			specB = 0.75, lmCoord.x = min(lmCoord.x, 0.88), mipmapDisabling = 1.0;
		else if (mc_Entity.x == 11024) // Campfire, Powered Lever
			#ifdef COLORED_LIGHT
				lightVarying = 3.0,
			#endif
			lmCoord.x = min(lmCoord.x, 0.885), mat = 110.0;
		else if (mc_Entity.x == 11025) // Soul Campfire
			#ifdef COLORED_LIGHT
				lightVarying = 2.0,
			#endif
			lmCoord.x = min(lmCoord.x, 0.885), mat = 110.0;
	} else {
		if (mc_Entity.x == 11026) // Jigsaw Block, Structure Block
			#ifdef SNOW_MODE
				noSnow = 1.0,
			#endif
			specB = 8.004, quarterNdotUfactor = 0.0;
		else if (mc_Entity.x == 11027) // Sea Pickle
			specB = 12.0003, lmCoord.x = min(lmCoord.x, 0.885), mipmapDisabling = 1.0;
		else if (mc_Entity.x == 11028) // Spawner
			specR = 0.5, specG = 0.8, specB = 32.01, mat = 20000.0, color.rgb = vec3(2.6, 0.0, 0.0), mipmapDisabling = 1.0;
	}
	} else {
	if (mc_Entity.x < 11032.5) {
		if (mc_Entity.x == 11029) // Diamond Ore, Emerald Ore
			#ifdef EMISSIVE_ORES
				specB = 0.30, mat = 113.0, mipmapDisabling = 1.0,
			#endif
			specR = 20.04;
		else if (mc_Entity.x == 11030) // Gold Ore, Lapis Ore
			#ifdef EMISSIVE_ORES
				specB = 0.08, mat = 113.0, mipmapDisabling = 1.0,
			#endif
			specR = 20.04;
		else if (mc_Entity.x == 11031) // Redstone Ore Unlit
			#ifdef EMISSIVE_ORES
				specB = 4.27, mat = 113.0, mipmapDisabling = 1.0,
			#endif
			specR = 20.04;
		else if (mc_Entity.x == 11032) // Redstone Ore Lit
			#ifdef COLORED_LIGHT
				lightVarying = 2.0,
			#endif
			lmCoord.x *= 0.9,
			specB = 4.27, mat = 113.0, mipmapDisabling = 1.0,
			specR = 20.04;
	} else {
		if (mc_Entity.x == 11033) // Iron Ore
			#ifdef EMISSIVE_ORES
				specB = 0.05, mat = 113.0, mipmapDisabling = 1.0, specG = 0.07,
			#endif
			specR = 20.04;
		else if (mc_Entity.x == 11034) // Copper Ore
			#ifdef EMISSIVE_ORES
				specB = 0.20, mat = 113.0, mipmapDisabling = 1.0, specG = 0.175,
			#endif
			specR = 20.04;
		else if (mc_Entity.x == 11050) // Rails
			mat = 117.0, lmCoord.x = clamp(lmCoord.x, 0.0, 0.87), mipmapDisabling = 1.0;
    }
	}
	}
	}
	}

		// Too bright near a light source fix
		if (mc_Entity.x == 99 || mc_Entity.x == 10204)
			lmCoord.x = clamp(lmCoord.x, 0.0, 0.87);

		// No shading
		if (mc_Entity.x == 20091 || mc_Entity.x == 901 || mc_Entity.x == 97)
			quarterNdotUfactor = 0.0;

		// Mipmap Fix
		if (mc_Entity.x == 880 || mc_Entity.x == 76 || mc_Entity.x == 98 || mc_Entity.x == 95)
			mipmapDisabling = 1.0;
	#endif

	#if !defined COMPBR && defined COLORED_LIGHT
	if (mc_Entity.x < 11012.5) {
	if (mc_Entity.x < 11005.5) {
		if (mc_Entity.x == 11001) // Glowstone
			lightVarying = 3.0;
		else if (mc_Entity.x == 11002) // Sea Lantern
			lightVarying = 4.0;
		else if (mc_Entity.x == 11004) // Shroomlight
			lightVarying = 1.0;
		else if (mc_Entity.x == 11005) // Redstone Lamp Lit
			lightVarying = 3.0;
	} else {
		if (mc_Entity.x == 11007) // Jack o'Lantern
			lightVarying = 3.0;
		else if (mc_Entity.x == 11008) // Beacon
			lightVarying = 4.0;
		else if (mc_Entity.x == 11009) // End Rod
			lightVarying = 4.0;
		else if (mc_Entity.x == 11012) // Redstone Torch
			lightVarying = 2.0;
	}
	} else {
	if (mc_Entity.x < 11022.5) {
		if (mc_Entity.x == 11017) // Lantern
			lightVarying = 3.0;
		else if (mc_Entity.x == 11018) // Soul Lantern
			lightVarying = 2.0;
		else if (mc_Entity.x == 11020) // Furnaces Lit
			lightVarying = 3.0;
		else if (mc_Entity.x == 11021) // Torch
			lightVarying = 1.0;
		else if (mc_Entity.x == 11022) // Soul Torch
			lightVarying = 2.0;
	} else {
		if (mc_Entity.x == 11023) // Crying Obsidian, Respawn Anchor
			lightVarying = 2.0;
		else if (mc_Entity.x == 11024) // Campfire
			lightVarying = 3.0;
		else if (mc_Entity.x == 11025) // Soul Campfire
			lightVarying = 2.0;
		else if (mc_Entity.x == 11032) // Redstone Ore Lit
			lightVarying = 2.0;
	}
	}
	#endif

	if (mc_Entity.x == 300) // No Vanilla AO
		color.a = 1.0;

	if (lmCoord.x > 0.99) // Clamp full bright emissives
		lmCoord.x = 0.9, quarterNdotUfactor = 0.0;

	mat += 0.25;
	
	const vec2 sunRotationData = vec2(cos(sunPathRotation * 0.01745329251994), -sin(sunPathRotation * 0.01745329251994));
	float ang = fract(timeAngleM - 0.25);
	ang = (ang + (cos(ang * 3.14159265358979) * -0.5 + 0.5 - ang) / 3.0) * 6.28318530717959;
	sunVec = normalize((gbufferModelView * vec4(vec3(-sin(ang), cos(ang) * sunRotationData) * 2000.0, 1.0)).xyz);

	upVec = normalize(gbufferModelView[1].xyz);

	#ifdef OLD_LIGHTING_FIX
		eastVec = normalize(gbufferModelView[0].xyz);
		northVec = normalize(gbufferModelView[2].xyz);
	#endif

	float istopv = gl_MultiTexCoord0.t < mc_midTexCoord.t ? 1.0 : 0.0;
	vec3 wave = WavingBlocks(position.xyz, istopv);
	position.xyz += wave;

    #ifdef WORLD_CURVATURE
		position.y -= WorldCurvature(position.xz);
    #endif

	gl_Position = gl_ProjectionMatrix * gbufferModelView * position;
	
	#if AA > 1
		gl_Position.xy = TAAJitter(gl_Position.xy, gl_Position.w);
	#endif
}

#endif

void main() {
    irisMain();

// alpha test disabled
}
